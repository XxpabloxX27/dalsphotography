import { __decorate, __extends } from "tslib";
import { CommonModule } from '@angular/common';
import { Component, ElementRef, EventEmitter, HostBinding, Input, NgModule, Output, Renderer2, ViewChild, ContentChild, AfterViewInit } from '@angular/core';
import { IgxProcessBarTextTemplateDirective, IgxProgressBarGradientDirective, } from './progressbar.common';
import { IgxDirectionality } from '../services/direction/directionality';
var ONE_PERCENT = 0.01;
var MIN_VALUE = 0;
export var IgxTextAlign;
(function (IgxTextAlign) {
    IgxTextAlign["START"] = "start";
    IgxTextAlign["CENTER"] = "center";
    IgxTextAlign["END"] = "end";
})(IgxTextAlign || (IgxTextAlign = {}));
export var IgxProgressType;
(function (IgxProgressType) {
    IgxProgressType["ERROR"] = "error";
    IgxProgressType["INFO"] = "info";
    IgxProgressType["WARNING"] = "warning";
    IgxProgressType["SUCCESS"] = "success";
})(IgxProgressType || (IgxProgressType = {}));
var BaseProgress = /** @class */ (function () {
    function BaseProgress() {
        /**
         * @hidden
         */
        this.requestAnimationId = undefined;
        /**
         * @hidden
         */
        this._valueInPercent = MIN_VALUE;
        /**
         * @hidden
         */
        this._max = 100;
        /**
         * @hidden
         */
        this._value = MIN_VALUE;
        /**
         * @hidden
         */
        this._animate = true;
    }
    Object.defineProperty(BaseProgress.prototype, "valueInPercent", {
        /**
         *Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
         *public valuePercent(event){
         *    let percentValue = this.progressBar.valueInPercent;
         *    alert(percentValue);
         *}
         *```
         */
        get: function () {
            return this._valueInPercent;
        },
        /**
         *Sets the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
         *    public setValue(event){
         *    this.progressBar.valueInPercent = 56;
         *}
         * //...
         *```
         *```html
         *<button igxButton="fab" igxRipple="" (click)="setValue()">setValue</button>
         *```
         */
        set: function (value) {
            this._valueInPercent = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    BaseProgress.prototype.runAnimation = function (val, step) {
        var _this = this;
        this.requestAnimationId = requestAnimationFrame(function () { return _this.updateProgressSmoothly.call(_this, val, step); });
    };
    /**
     * @hidden
     */
    BaseProgress.prototype.updateProgressSmoothly = function (val, step) {
        var _this = this;
        this._value += step;
        var passedValue = convertInPercentage(val, this._max);
        var progressValue = convertInPercentage(this._value, this._max);
        if (this.valueInPercent === passedValue) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else if (this.isInLimitRange(progressValue, passedValue, step)) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else {
            this.valueInPercent = progressValue;
            this.requestAnimationId = requestAnimationFrame(function () { return _this.updateProgressSmoothly.call(_this, val, step); });
        }
    };
    /**
     * @hidden
     */
    BaseProgress.prototype.updateProgressDirectly = function (val) {
        this._value = val;
        this.valueInPercent = convertInPercentage(this._value, this._max);
    };
    /**
     * @hidden
     */
    BaseProgress.prototype.directionFlow = function (currentValue, prevValue, step) {
        if (currentValue < prevValue) {
            return step;
        }
        return -step;
    };
    /**
     * @hidden
     */
    BaseProgress.prototype.isInLimitRange = function (val, comparator, step) {
        return this.isExceedingUpperLimit(val, comparator, step) || this.isExceedingLowerLimit(val, comparator, step);
    };
    /**
     * @hidden
     *
     *
     * @param val
     * @param comparator
     * @param step
     */
    BaseProgress.prototype.isExceedingUpperLimit = function (val, comparator, step) {
        return val > comparator && step > 0;
    };
    /**
     * @hidden
     *
     * @param val
     * @param comparator
     * @param step
     */
    BaseProgress.prototype.isExceedingLowerLimit = function (val, comparator, step) {
        return val < comparator && step < 0;
    };
    /**
     * @hidden
     * @param step
     */
    BaseProgress.prototype.updateProgress = function (val) {
        this._value = val;
        this.valueInPercent = convertInPercentage(this._value, this._max);
    };
    return BaseProgress;
}());
export { BaseProgress };
var NEXT_LINEAR_ID = 0;
var NEXT_CIRCULAR_ID = 0;
var NEXT_GRADIENT_ID = 0;
var IgxLinearProgressBarComponent = /** @class */ (function (_super) {
    __extends(IgxLinearProgressBarComponent, _super);
    function IgxLinearProgressBarComponent() {
        var _this = _super.call(this) || this;
        _this.valueMin = 0;
        _this.cssClass = 'igx-linear-bar';
        /**
         *Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
         *```html
         *<igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         *```
         */
        _this.striped = false;
        /**
         *Set `IgxLinearProgressBarComponent` to have indeterminate. By default it is set to false.
         *```html
         *<igx-linear-bar [indeterminate]="true"></igx-linear-bar>
         *```
         */
        _this.indeterminate = false;
        /**An @Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
         * ```html
         *<igx-linear-bar role="progressbar"></igx-linear-bar>
         * ```
         */
        _this.role = 'progressbar';
        /**An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         *<igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        _this.id = "igx-linear-bar-" + NEXT_LINEAR_ID++;
        /**
         *Set the position that defines where the text is aligned.
         Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
         *```typescript
         *public positionCenter: IgxTextAlign;
         *public ngOnInit() {
         *    this.positionCenter = IgxTextAlign.CENTER;
         *}
         * //...
         *```
         * ```html
         *<igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
         *```
         */
        _this.textAlign = IgxTextAlign.START;
        /**
         *Set the text to be visible. By default it is set to true.
         * ```html
         *<igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
         *```
         */
        _this.textVisibility = true;
        /**
         *Set the position that defines if the text should be aligned above the progress line. By default is set to false.
         *```html
         *<igx-linear-bar type="error" [textTop]="true"></igx-linear-bar>
         *```
         */
        _this.textTop = false;
        /**
         *Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `error`.
         *```html
         *<igx-linear-bar [striped]="false" [max]="100" [value]="0" type="error"></igx-linear-bar>
         *```
         */
        _this.type = 'default';
        /**
         *An event, which is triggered after a progress is changed.
         *```typescript
         *public progressChange(event) {
         *    alert("Progress made!");
         *}
         * //...
         *```
         *```html
         *<igx-linear-bar (onProgressChanged)="progressChange($event)" type="success">
         *```
         */
        _this.onProgressChanged = new EventEmitter();
        return _this;
    }
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "animate", {
        /**
         *Returns whether the `IgxLinearProgressBarComponent` has animation true/false.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxLinearProgressBarComponent;
         *public animationStatus(event) {
         *    let animationStatus = this.progressBar.animate;
         *    alert(animationStatus);
         *}
         *```
         */
        get: function () {
            return this._animate;
        },
        /**
         *Animation on progress `IgxLinearProgressBarComponent`. By default it is set to true.
         *```html
         *<igx-linear-bar [animate]="false" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         *```
         */
        set: function (animate) {
            this._animate = animate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "max", {
        /**
         *Returns the the maximum progress value of the `IgxLinearProgressBarComponent`.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxLinearProgressBarComponent;
         *public maxValue(event) {
         *    let max = this.progressBar.max;
         *    alert(max);
         *}
         *```
         */
        get: function () {
            return this._max;
        },
        /**
         *Set maximum value that can be passed. By default it is set to 100.
         *```html
         *<igx-linear-bar [striped]="false" [max]="200" [value]="0"></igx-linear-bar>
         *```
         */
        set: function (maxNum) {
            this._max = maxNum;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "step", {
        /**
         *Returns the value which update the progress indicator of the `IgxLinearProgressBarComponent`.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxLinearProgressBarComponent;
         *public stepValue(event) {
         *    let step = this.progressBar.step;
         *    alert(step);
         *}
         *```
         */
        get: function () {
            if (this._step) {
                return this._step;
            }
            return this._max * ONE_PERCENT;
        },
        /**
         *Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
         *```html
         *<igx-linear-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-linear-bar>
         *```
         */
        set: function (val) {
            this._step = Number(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "value", {
        /**
        *Returns value that indicates the current `IgxLinearProgressBarComponent` position.
        *```typescript
        *@ViewChild("MyProgressBar")
        *public progressBar: IgxLinearProgressBarComponent;
        *public getValue(event) {
        *    let value = this.progressBar.value;
        *    alert(value);
        *}
        *```
        */
        get: function () {
            return this._value;
        },
        /**
         *Set value that indicates the current `IgxLinearProgressBarComponent` position.
         *```html
         *<igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
         *```
         */
        set: function (val) {
            val = Number(val);
            if (this._value === val || this.indeterminate) {
                return;
            }
            var valueInRange = getValueInProperRange(val, this.max);
            if (isNaN(valueInRange)) {
                return;
            }
            var changedValues = {
                currentValue: valueInRange,
                previousValue: this._value
            };
            var updateValue = _super.prototype.directionFlow.call(this, this._value, val, this.step);
            if (this._animate && val >= this.step) {
                _super.prototype.runAnimation.call(this, valueInRange, updateValue);
            }
            else {
                _super.prototype.updateProgressDirectly.call(this, valueInRange);
            }
            this.onProgressChanged.emit(changedValues);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "error", {
        /**
         * @hidden
         */
        get: function () {
            return this.type === IgxProgressType.ERROR;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "info", {
        /**
         * @hidden
         */
        get: function () {
            return this.type === IgxProgressType.INFO;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "warning", {
        /**
         * @hidden
         */
        get: function () {
            return this.type === IgxProgressType.WARNING;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "success", {
        /**
         * @hidden
         */
        get: function () {
            return this.type === IgxProgressType.SUCCESS;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        Input()
    ], IgxLinearProgressBarComponent.prototype, "animate", null);
    __decorate([
        HostBinding('attr.aria-valuemax'),
        Input()
    ], IgxLinearProgressBarComponent.prototype, "max", null);
    __decorate([
        Input()
    ], IgxLinearProgressBarComponent.prototype, "step", null);
    __decorate([
        HostBinding('attr.aria-valuemin')
    ], IgxLinearProgressBarComponent.prototype, "valueMin", void 0);
    __decorate([
        HostBinding('class.igx-linear-bar')
    ], IgxLinearProgressBarComponent.prototype, "cssClass", void 0);
    __decorate([
        HostBinding('class.igx-linear-bar--striped'),
        Input()
    ], IgxLinearProgressBarComponent.prototype, "striped", void 0);
    __decorate([
        HostBinding('class.igx-linear-bar--indeterminate'),
        Input()
    ], IgxLinearProgressBarComponent.prototype, "indeterminate", void 0);
    __decorate([
        HostBinding('attr.role'),
        Input()
    ], IgxLinearProgressBarComponent.prototype, "role", void 0);
    __decorate([
        HostBinding('attr.id'),
        Input()
    ], IgxLinearProgressBarComponent.prototype, "id", void 0);
    __decorate([
        Input()
    ], IgxLinearProgressBarComponent.prototype, "textAlign", void 0);
    __decorate([
        Input()
    ], IgxLinearProgressBarComponent.prototype, "textVisibility", void 0);
    __decorate([
        Input()
    ], IgxLinearProgressBarComponent.prototype, "textTop", void 0);
    __decorate([
        Input()
    ], IgxLinearProgressBarComponent.prototype, "text", void 0);
    __decorate([
        Input()
    ], IgxLinearProgressBarComponent.prototype, "type", void 0);
    __decorate([
        HostBinding('attr.aria-valuenow'),
        Input()
    ], IgxLinearProgressBarComponent.prototype, "value", null);
    __decorate([
        Output()
    ], IgxLinearProgressBarComponent.prototype, "onProgressChanged", void 0);
    __decorate([
        HostBinding('class.igx-linear-bar--danger')
    ], IgxLinearProgressBarComponent.prototype, "error", null);
    __decorate([
        HostBinding('class.igx-linear-bar--info')
    ], IgxLinearProgressBarComponent.prototype, "info", null);
    __decorate([
        HostBinding('class.igx-linear-bar--warning')
    ], IgxLinearProgressBarComponent.prototype, "warning", null);
    __decorate([
        HostBinding('class.igx-linear-bar--success')
    ], IgxLinearProgressBarComponent.prototype, "success", null);
    IgxLinearProgressBarComponent = __decorate([
        Component({
            selector: 'igx-linear-bar',
            template: "<div class=\"igx-linear-bar__base\">\n    <div class=\"igx-linear-bar__indicator\" [style.width.%]=\"valueInPercent\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n"
        })
    ], IgxLinearProgressBarComponent);
    return IgxLinearProgressBarComponent;
}(BaseProgress));
export { IgxLinearProgressBarComponent };
var IgxCircularProgressBarComponent = /** @class */ (function (_super) {
    __extends(IgxCircularProgressBarComponent, _super);
    function IgxCircularProgressBarComponent(renderer, _directionality) {
        var _this = _super.call(this) || this;
        _this.renderer = renderer;
        _this._directionality = _directionality;
        _this.STROKE_OPACITY_DVIDER = 100;
        _this.STROKE_OPACITY_ADDITION = .2;
        /** @hidden */
        _this.cssClass = 'igx-circular-bar';
        /**
         *An event, which is triggered after a progress is changed.
         *```typescript
         *public progressChange(event) {
         *    alert("Progress made!");
         *}
         * //...
         *```
         *```html
         *<igx-circular-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-circular-bar>
         *```
         */
        _this.onProgressChanged = new EventEmitter();
        /**
         *An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         *```html
         *<igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
         *```
         */
        _this.id = "igx-circular-bar-" + NEXT_CIRCULAR_ID++;
        /**
         * @hidden
         */
        _this.gradientId = "igx-circular-gradient-" + NEXT_GRADIENT_ID++;
        /**
         *An @Input property that sets the value of the `indeterminate` attribute. If not provided it will be automatically set to false.
         *```html
         *<igx-circular-bar [indeterminate]="true"></igx-circular-bar>
         *```
         */
        _this.indeterminate = false;
        /**
         *Sets the text visibility. By default it is set to true.
         *```html
         *<igx-circular-bar [textVisibility]="false"></igx-circular-bar>
         *```
         */
        _this.textVisibility = true;
        _this._circleRadius = 46;
        _this._circumference = 2 * Math.PI * _this._circleRadius;
        return _this;
    }
    Object.defineProperty(IgxCircularProgressBarComponent.prototype, "context", {
        /**
         * @hidden
        */
        get: function () {
            return {
                $implicit: { value: this.value, valueInPercent: this.valueInPercent, max: this.max }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCircularProgressBarComponent.prototype, "animate", {
        /**
         *Returns whether the `IgxCircularProgressBarComponent` has animation true/false.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxCircularProgressBarComponent;
         *public animationStatus(event) {
         *    let animationStatus = this.progressBar.animate;
         *    alert(animationStatus);
         *}
         *```
         */
        get: function () {
            return this._animate;
        },
        /**
        *Animation on progress `IgxCircularProgressBarComponent`. By default it is set to true.
         *```html
         *<igx-circular-bar [animate]="false" [value]="50"></igx-circular-bar>
         *```
         */
        set: function (animate) {
            this._animate = animate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCircularProgressBarComponent.prototype, "max", {
        /**
         *Returns the the maximum progress value of the `IgxCircularProgressBarComponent`.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxCircularProgressBarComponent;
         *public maxValue(event) {
         *    let max = this.progressBar.max;
         *    alert(max);
         *}
         *```
         *```html
         *<igx-circular-bar [max]="245" [animate]="false" [value]="currentValue"></igx-circular-bar>
         *```
         */
        get: function () {
            return this._max;
        },
        /**
         *Set maximum value that can be passed. By default it is set to 100.
         *```html
         *<igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
         *```
         */
        set: function (maxNum) {
            this._max = maxNum;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCircularProgressBarComponent.prototype, "step", {
        /**
         *Returns the value which update the progress indicator of the `IgxCircularProgressBarComponent`.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxCircularProgressBarComponent;
         *public stepValue(event) {
         *    let step = this.progressBar.step;
         *    alert(step);
         *}
         *```
         */
        get: function () {
            if (this._step) {
                return this._step;
            }
            return this._max * ONE_PERCENT;
        },
        /**
         *Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
         *```html
         *<igx-circular-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-circular-bar>
         *```
        */
        set: function (val) {
            this._step = Number(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCircularProgressBarComponent.prototype, "value", {
        /**
         *Returns value that indicates the current `IgxCircularProgressBarComponent` position.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxCircularProgressBarComponent;
         *public getValue(event) {
         *    let value = this.progressBar.value;
         *    alert(value);
         *}
         *```
         *```html
         *<button igxButton="fab" igxRipple="" (click)="getValue()">Click</button>
         *```
         */
        get: function () {
            return this._value;
        },
        /**
         *Set value that indicates the current `IgxCircularProgressBarComponent` position.
         *```html
         *<igx-circular-bar [value]="50"></igx-circular-bar>
         *```
         */
        set: function (val) {
            val = Number(val);
            if (this._value === val || this.indeterminate) {
                return;
            }
            var valueInProperRange = getValueInProperRange(val, this.max);
            if (isNaN(valueInProperRange)) {
                return;
            }
            var changedValues = {
                currentValue: valueInProperRange,
                previousValue: this._value
            };
            var updateValue = _super.prototype.directionFlow.call(this, this._value, val, this.step);
            if (this.animate && val >= this.step) {
                _super.prototype.runAnimation.call(this, valueInProperRange, updateValue);
            }
            else {
                this.updateProgressDirectly(valueInProperRange);
            }
            this.onProgressChanged.emit(changedValues);
        },
        enumerable: true,
        configurable: true
    });
    IgxCircularProgressBarComponent.prototype.ngAfterViewInit = function () {
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke', "url(#" + this.gradientId + ")");
    };
    /**
     * @hidden
     */
    IgxCircularProgressBarComponent.prototype.updateProgressSmoothly = function (val, step) {
        // Set frames for the animation
        var FRAMES = [{
                strokeDashoffset: this.getProgress(this._value),
                strokeOpacity: (this._value / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }, {
                strokeDashoffset: this.getProgress(this.valueInPercent),
                strokeOpacity: (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }];
        this._svgCircle.nativeElement.animate(FRAMES, {
            easing: 'ease-out',
            fill: 'forwards'
        });
        _super.prototype.updateProgressSmoothly.call(this, val, step);
    };
    Object.defineProperty(IgxCircularProgressBarComponent.prototype, "textContent", {
        /**
         * @hidden
        */
        get: function () {
            return this.text;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
    */
    IgxCircularProgressBarComponent.prototype.updateProgressDirectly = function (val) {
        _super.prototype.updateProgressDirectly.call(this, val);
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-dashoffset', this.getProgress(this.valueInPercent));
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-opacity', (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION);
    };
    IgxCircularProgressBarComponent.prototype.getProgress = function (percentage) {
        return this._directionality.rtl ?
            this._circumference + (percentage * this._circumference / 100) :
            this._circumference - (percentage * this._circumference / 100);
    };
    IgxCircularProgressBarComponent.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: IgxDirectionality }
    ]; };
    __decorate([
        HostBinding('class.igx-circular-bar')
    ], IgxCircularProgressBarComponent.prototype, "cssClass", void 0);
    __decorate([
        Output()
    ], IgxCircularProgressBarComponent.prototype, "onProgressChanged", void 0);
    __decorate([
        HostBinding('attr.id'),
        Input()
    ], IgxCircularProgressBarComponent.prototype, "id", void 0);
    __decorate([
        HostBinding('class.igx-circular-bar--indeterminate'),
        Input()
    ], IgxCircularProgressBarComponent.prototype, "indeterminate", void 0);
    __decorate([
        Input()
    ], IgxCircularProgressBarComponent.prototype, "textVisibility", void 0);
    __decorate([
        Input()
    ], IgxCircularProgressBarComponent.prototype, "text", void 0);
    __decorate([
        ContentChild(IgxProcessBarTextTemplateDirective, { read: IgxProcessBarTextTemplateDirective })
    ], IgxCircularProgressBarComponent.prototype, "textTemplate", void 0);
    __decorate([
        ContentChild(IgxProgressBarGradientDirective, { read: IgxProgressBarGradientDirective })
    ], IgxCircularProgressBarComponent.prototype, "gradientTemplate", void 0);
    __decorate([
        Input()
    ], IgxCircularProgressBarComponent.prototype, "animate", null);
    __decorate([
        Input()
    ], IgxCircularProgressBarComponent.prototype, "max", null);
    __decorate([
        Input()
    ], IgxCircularProgressBarComponent.prototype, "step", null);
    __decorate([
        Input()
    ], IgxCircularProgressBarComponent.prototype, "value", null);
    __decorate([
        ViewChild('circle', { static: true })
    ], IgxCircularProgressBarComponent.prototype, "_svgCircle", void 0);
    IgxCircularProgressBarComponent = __decorate([
        Component({
            selector: 'igx-circular-bar',
            template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <svg:circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:text *ngIf=\"textVisibility\" text-anchor=\"middle\" x=\"50\" y=\"60\">\n        <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate;\n            context: context\">\n        </ng-container>\n    </svg:text>\n\n    <svg:defs>\n        <ng-container\n            *ngTemplateOutlet=\"gradientTemplate ? gradientTemplate.template : defaultGradientTemplate;\n            context: { $implicit: gradientId }\">\n        </ng-container>\n    </svg:defs>\n\n    <ng-template #defaultTextTemplate>\n        <svg:tspan class=\"igx-circular-bar__text\">\n            {{textContent ? textContent: valueInPercent + '%'}}\n        </svg:tspan>\n    </ng-template>\n\n    <ng-template #defaultGradientTemplate>\n        <svg:linearGradient [id]=\"gradientId\" gradientTransform=\"rotate(90)\">\n          <stop offset=\"0%\"   class=\"igx-circular-bar__gradient-start\" />\n          <stop offset=\"100%\" class=\"igx-circular-bar__gradient-end\" />\n        </svg:linearGradient>\n    </ng-template>\n</svg>\n\n"
        })
    ], IgxCircularProgressBarComponent);
    return IgxCircularProgressBarComponent;
}(BaseProgress));
export { IgxCircularProgressBarComponent };
export function getValueInProperRange(value, max, min) {
    if (min === void 0) { min = 0; }
    return Math.max(Math.min(value, max), min);
}
export function convertInPercentage(value, max) {
    return Math.floor(100 * value / max);
}
/**
 * @hidden
 */
var IgxProgressBarModule = /** @class */ (function () {
    function IgxProgressBarModule() {
    }
    IgxProgressBarModule = __decorate([
        NgModule({
            declarations: [
                IgxLinearProgressBarComponent,
                IgxCircularProgressBarComponent,
                IgxProcessBarTextTemplateDirective,
                IgxProgressBarGradientDirective,
            ],
            exports: [
                IgxLinearProgressBarComponent,
                IgxCircularProgressBarComponent,
                IgxProcessBarTextTemplateDirective,
                IgxProgressBarGradientDirective,
            ],
            imports: [CommonModule]
        })
    ], IgxProgressBarModule);
    return IgxProgressBarModule;
}());
export { IgxProgressBarModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3NiYXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9wcm9ncmVzc2Jhci9wcm9ncmVzc2Jhci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBQ0gsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osV0FBVyxFQUNYLEtBQUssRUFDTCxRQUFRLEVBQ1IsTUFBTSxFQUNOLFNBQVMsRUFDVCxTQUFTLEVBQ1QsWUFBWSxFQUNaLGFBQWEsRUFDaEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUNILGtDQUFrQyxFQUNsQywrQkFBK0IsR0FDbEMsTUFBTSxzQkFBc0IsQ0FBQztBQUU5QixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUV6RSxJQUFNLFdBQVcsR0FBRyxJQUFJLENBQUM7QUFDekIsSUFBTSxTQUFTLEdBQUcsQ0FBQyxDQUFDO0FBRXBCLE1BQU0sQ0FBTixJQUFZLFlBSVg7QUFKRCxXQUFZLFlBQVk7SUFDcEIsK0JBQWUsQ0FBQTtJQUNmLGlDQUFpQixDQUFBO0lBQ2pCLDJCQUFXLENBQUE7QUFDZixDQUFDLEVBSlcsWUFBWSxLQUFaLFlBQVksUUFJdkI7QUFFRCxNQUFNLENBQU4sSUFBWSxlQUtYO0FBTEQsV0FBWSxlQUFlO0lBQ3ZCLGtDQUFlLENBQUE7SUFDZixnQ0FBYSxDQUFBO0lBQ2Isc0NBQW1CLENBQUE7SUFDbkIsc0NBQW1CLENBQUE7QUFDdkIsQ0FBQyxFQUxXLGVBQWUsS0FBZixlQUFlLFFBSzFCO0FBT0Q7SUFBQTtRQUNJOztXQUVHO1FBQ0ssdUJBQWtCLEdBQVcsU0FBUyxDQUFDO1FBRS9DOztXQUVHO1FBQ08sb0JBQWUsR0FBRyxTQUFTLENBQUM7UUFDdEM7O1dBRUc7UUFDTyxTQUFJLEdBQUcs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QUMsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUMvQyxDQUFDO0FBRUQsTUFBTSxVQUFVLG1CQUFtQixDQUFDLEtBQWEsRUFBRSxHQUFXO0lBQzFELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFFRDs7R0FFRztBQWdCSDtJQUFBO0lBQW9DLENBQUM7SUFBeEIsb0JBQW9CO1FBZmhDLFFBQVEsQ0FBQztZQUNOLFlBQVksRUFBRTtnQkFDViw2QkFBNkI7Z0JBQzdCLCtCQUErQjtnQkFDL0Isa0NBQWtDO2dCQUNsQywrQkFBK0I7YUFDbEM7WUFDRCxPQUFPLEVBQUU7Z0JBQ0wsNkJBQTZCO2dCQUM3QiwrQkFBK0I7Z0JBQy9CLGtDQUFrQztnQkFDbEMsK0JBQStCO2FBQ2xDO1lBQ0QsT0FBTyxFQUFFLENBQUMsWUFBWSxDQUFDO1NBQzFCLENBQUM7T0FDVyxvQkFBb0IsQ0FBSTtJQUFELDJCQUFDO0NBQUEsQUFBckMsSUFBcUM7U0FBeEIsb0JBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIElucHV0LFxuICAgIE5nTW9kdWxlLFxuICAgIE91dHB1dCxcbiAgICBSZW5kZXJlcjIsXG4gICAgVmlld0NoaWxkLFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBBZnRlclZpZXdJbml0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgICBJZ3hQcm9jZXNzQmFyVGV4dFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIElneFByb2dyZXNzQmFyR3JhZGllbnREaXJlY3RpdmUsXG59IGZyb20gJy4vcHJvZ3Jlc3NiYXIuY29tbW9uJztcbmltcG9ydCB7IElCYXNlRXZlbnRBcmdzIH0gZnJvbSAnLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBJZ3hEaXJlY3Rpb25hbGl0eSB9IGZyb20gJy4uL3NlcnZpY2VzL2RpcmVjdGlvbi9kaXJlY3Rpb25hbGl0eSc7XG5cbmNvbnN0IE9ORV9QRVJDRU5UID0gMC4wMTtcbmNvbnN0IE1JTl9WQUxVRSA9IDA7XG5cbmV4cG9ydCBlbnVtIElneFRleHRBbGlnbiB7XG4gICAgU1RBUlQgPSAnc3RhcnQnLFxuICAgIENFTlRFUiA9ICdjZW50ZXInLFxuICAgIEVORCA9ICdlbmQnXG59XG5cbmV4cG9ydCBlbnVtIElneFByb2dyZXNzVHlwZSB7XG4gICAgRVJST1IgPSAnZXJyb3InLFxuICAgIElORk8gPSAnaW5mbycsXG4gICAgV0FSTklORyA9ICd3YXJuaW5nJyxcbiAgICBTVUNDRVNTID0gJ3N1Y2Nlc3MnXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUNoYW5nZVByb2dyZXNzRXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIHByZXZpb3VzVmFsdWU6IG51bWJlcjtcbiAgICBjdXJyZW50VmFsdWU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VQcm9ncmVzcyB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgcmVxdWVzdEFuaW1hdGlvbklkOiBudW1iZXIgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF92YWx1ZUluUGVyY2VudCA9IE1JTl9WQUxVRTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9tYXggPSAxMDA7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfdmFsdWUgPSBNSU5fVkFMVUU7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfYW5pbWF0ZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9zdGVwO1xuXG4gICAgLyoqXG4gICAgICpSZXR1cm5zIHRoZSBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgL2BJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50YCB2YWx1ZSBpbiBwZXJjZW50YWdlLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7IC8vIElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRcbiAgICAgKnB1YmxpYyB2YWx1ZVBlcmNlbnQoZXZlbnQpe1xuICAgICAqICAgIGxldCBwZXJjZW50VmFsdWUgPSB0aGlzLnByb2dyZXNzQmFyLnZhbHVlSW5QZXJjZW50O1xuICAgICAqICAgIGFsZXJ0KHBlcmNlbnRWYWx1ZSk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHZhbHVlSW5QZXJjZW50KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZUluUGVyY2VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlNldHMgdGhlIGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAvYElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHZhbHVlIGluIHBlcmNlbnRhZ2UuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDsgLy8gSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudFxuICAgICAqICAgIHB1YmxpYyBzZXRWYWx1ZShldmVudCl7XG4gICAgICogICAgdGhpcy5wcm9ncmVzc0Jhci52YWx1ZUluUGVyY2VudCA9IDU2O1xuICAgICAqfVxuICAgICAqIC8vLi4uXG4gICAgICpgYGBcbiAgICAgKmBgYGh0bWxcbiAgICAgKjxidXR0b24gaWd4QnV0dG9uPVwiZmFiXCIgaWd4UmlwcGxlPVwiXCIgKGNsaWNrKT1cInNldFZhbHVlKClcIj5zZXRWYWx1ZTwvYnV0dG9uPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIHNldCB2YWx1ZUluUGVyY2VudCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlSW5QZXJjZW50ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBydW5BbmltYXRpb24odmFsOiBudW1iZXIsIHN0ZXA6IG51bWJlcikge1xuICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICAgICAgICgpID0+IHRoaXMudXBkYXRlUHJvZ3Jlc3NTbW9vdGhseS5jYWxsKHRoaXMsIHZhbCwgc3RlcCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdXBkYXRlUHJvZ3Jlc3NTbW9vdGhseSh2YWw6IG51bWJlciwgc3RlcDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlICs9IHN0ZXA7XG4gICAgICAgIGNvbnN0IHBhc3NlZFZhbHVlID0gY29udmVydEluUGVyY2VudGFnZSh2YWwsIHRoaXMuX21heCk7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzVmFsdWUgPSBjb252ZXJ0SW5QZXJjZW50YWdlKHRoaXMuX3ZhbHVlLCB0aGlzLl9tYXgpO1xuICAgICAgICBpZiAodGhpcy52YWx1ZUluUGVyY2VudCA9PT0gcGFzc2VkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3ModmFsKTtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVxdWVzdEFuaW1hdGlvbklkKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSW5MaW1pdFJhbmdlKHByb2dyZXNzVmFsdWUsIHBhc3NlZFZhbHVlLCBzdGVwKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzcyh2YWwpO1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXF1ZXN0QW5pbWF0aW9uSWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUluUGVyY2VudCA9IHByb2dyZXNzVmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnVwZGF0ZVByb2dyZXNzU21vb3RobHkuY2FsbCh0aGlzLCB2YWwsIHN0ZXApKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdXBkYXRlUHJvZ3Jlc3NEaXJlY3RseSh2YWw6IG51bWJlcikge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbDtcbiAgICAgICAgdGhpcy52YWx1ZUluUGVyY2VudCA9IGNvbnZlcnRJblBlcmNlbnRhZ2UodGhpcy5fdmFsdWUsIHRoaXMuX21heCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkaXJlY3Rpb25GbG93KGN1cnJlbnRWYWx1ZTogbnVtYmVyLCBwcmV2VmFsdWU6IG51bWJlciwgc3RlcDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8IHByZXZWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gLXN0ZXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgaXNJbkxpbWl0UmFuZ2UodmFsOiBudW1iZXIsIGNvbXBhcmF0b3I6IG51bWJlciwgc3RlcDogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRXhjZWVkaW5nVXBwZXJMaW1pdCh2YWwsIGNvbXBhcmF0b3IsIHN0ZXApIHx8IHRoaXMuaXNFeGNlZWRpbmdMb3dlckxpbWl0KHZhbCwgY29tcGFyYXRvciwgc3RlcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICogQHBhcmFtIGNvbXBhcmF0b3JcbiAgICAgKiBAcGFyYW0gc3RlcFxuICAgICAqL1xuICAgIHByaXZhdGUgaXNFeGNlZWRpbmdVcHBlckxpbWl0KHZhbDogbnVtYmVyLCBjb21wYXJhdG9yOiBudW1iZXIsIHN0ZXA6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gdmFsID4gY29tcGFyYXRvciAmJiBzdGVwID4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICogQHBhcmFtIGNvbXBhcmF0b3JcbiAgICAgKiBAcGFyYW0gc3RlcFxuICAgICAqL1xuICAgIHByaXZhdGUgaXNFeGNlZWRpbmdMb3dlckxpbWl0KHZhbDogbnVtYmVyLCBjb21wYXJhdG9yOiBudW1iZXIsIHN0ZXA6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gdmFsIDwgY29tcGFyYXRvciAmJiBzdGVwIDwgMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQHBhcmFtIHN0ZXBcbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZVByb2dyZXNzKHZhbDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsO1xuICAgICAgICB0aGlzLnZhbHVlSW5QZXJjZW50ID0gY29udmVydEluUGVyY2VudGFnZSh0aGlzLl92YWx1ZSwgdGhpcy5fbWF4KTtcbiAgICB9XG59XG5sZXQgTkVYVF9MSU5FQVJfSUQgPSAwO1xubGV0IE5FWFRfQ0lSQ1VMQVJfSUQgPSAwO1xubGV0IE5FWFRfR1JBRElFTlRfSUQgPSAwO1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtbGluZWFyLWJhcicsXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvbGluZWFyLWJhci5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlUHJvZ3Jlc3Mge1xuXG4gICAgLyoqXG4gICAgICpBbmltYXRpb24gb24gcHJvZ3Jlc3MgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YC4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciBbYW5pbWF0ZV09XCJmYWxzZVwiIFtzdHJpcGVkXT1cInRydWVcIiBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCBhbmltYXRlKGFuaW1hdGU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZSA9IGFuaW1hdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpSZXR1cm5zIHdoZXRoZXIgdGhlIGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgaGFzIGFuaW1hdGlvbiB0cnVlL2ZhbHNlLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgYW5pbWF0aW9uU3RhdHVzKGV2ZW50KSB7XG4gICAgICogICAgbGV0IGFuaW1hdGlvblN0YXR1cyA9IHRoaXMucHJvZ3Jlc3NCYXIuYW5pbWF0ZTtcbiAgICAgKiAgICBhbGVydChhbmltYXRpb25TdGF0dXMpO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IGFuaW1hdGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqU2V0IG1heGltdW0gdmFsdWUgdGhhdCBjYW4gYmUgcGFzc2VkLiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byAxMDAuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgW3N0cmlwZWRdPVwiZmFsc2VcIiBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCIwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLXZhbHVlbWF4JylcbiAgICBASW5wdXQoKVxuICAgIHNldCBtYXgobWF4TnVtOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fbWF4ID0gbWF4TnVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqUmV0dXJucyB0aGUgdGhlIG1heGltdW0gcHJvZ3Jlc3MgdmFsdWUgb2YgdGhlIGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyBtYXhWYWx1ZShldmVudCkge1xuICAgICAqICAgIGxldCBtYXggPSB0aGlzLnByb2dyZXNzQmFyLm1heDtcbiAgICAgKiAgICBhbGVydChtYXgpO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IG1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlJldHVybnMgdGhlIHZhbHVlIHdoaWNoIHVwZGF0ZSB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yIG9mIHRoZSBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgc3RlcFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgbGV0IHN0ZXAgPSB0aGlzLnByb2dyZXNzQmFyLnN0ZXA7XG4gICAgICogICAgYWxlcnQoc3RlcCk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBzdGVwKCk6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLl9zdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RlcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXggKiBPTkVfUEVSQ0VOVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlNldHMgdGhlIHZhbHVlIGJ5IHdoaWNoIHByb2dyZXNzIGluZGljYXRvciBpcyB1cGRhdGVkLiBCeSBkZWZhdWx0IGl0IGlzIDElIG9mIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiMFwiIFtzdGVwXT1cIjFcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgc2V0IHN0ZXAodmFsOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fc3RlcCA9IE51bWJlcih2YWwpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLXZhbHVlbWluJylcbiAgICBwdWJsaWMgdmFsdWVNaW4gPSAwO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtbGluZWFyLWJhcicpXG4gICAgcHVibGljIGNzc0NsYXNzID0gJ2lneC1saW5lYXItYmFyJztcblxuICAgIC8qKlxuICAgICAqU2V0IGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgdG8gaGF2ZSBzdHJpcGVkIHN0eWxlLiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byBmYWxzZS5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciBbc3RyaXBlZF09XCJ0cnVlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtbGluZWFyLWJhci0tc3RyaXBlZCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc3RyaXBlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpTZXQgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YCB0byBoYXZlIGluZGV0ZXJtaW5hdGUuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIGZhbHNlLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFtpbmRldGVybWluYXRlXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtbGluZWFyLWJhci0taW5kZXRlcm1pbmF0ZScpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuXG4gICAgLyoqQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgdGhlIGByb2xlYCBhdHRyaWJ1dGUuIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIGBwcm9ncmVzc2JhcmAuXG4gICAgICogYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIHJvbGU9XCJwcm9ncmVzc2JhclwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHJvbGUgPSAncHJvZ3Jlc3NiYXInO1xuXG4gICAgLyoqQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgYGlkYCBhdHRyaWJ1dGUuIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciBbaWRdPVwiJ2lneC1saW5lYXItYmFyLTU1J1wiIFtzdHJpcGVkXT1cInRydWVcIiBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZCA9IGBpZ3gtbGluZWFyLWJhci0ke05FWFRfTElORUFSX0lEKyt9YDtcblxuICAgIC8qKlxuICAgICAqU2V0IHRoZSBwb3NpdGlvbiB0aGF0IGRlZmluZXMgd2hlcmUgdGhlIHRleHQgaXMgYWxpZ25lZC5cbiAgICAgUG9zc2libGUgb3B0aW9ucyAtIGBJZ3hUZXh0QWxpZ24uU1RBUlRgIChkZWZhdWx0KSwgYElneFRleHRBbGlnbi5DRU5URVJgLCBgSWd4VGV4dEFsaWduLkVORGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpwdWJsaWMgcG9zaXRpb25DZW50ZXI6IElneFRleHRBbGlnbjtcbiAgICAgKnB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgKiAgICB0aGlzLnBvc2l0aW9uQ2VudGVyID0gSWd4VGV4dEFsaWduLkNFTlRFUjtcbiAgICAgKn1cbiAgICAgKiAvLy4uLlxuICAgICAqYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIHR5cGU9XCJ3YXJuaW5nXCIgW3RleHRdPVwiJ0N1c3RvbSB0ZXh0J1wiIFt0ZXh0QWxpZ25dPVwicG9zaXRpb25DZW50ZXJcIiBbc3RyaXBlZF09XCJ0cnVlXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRleHRBbGlnbjogSWd4VGV4dEFsaWduID0gSWd4VGV4dEFsaWduLlNUQVJUO1xuXG4gICAgLyoqXG4gICAgICpTZXQgdGhlIHRleHQgdG8gYmUgdmlzaWJsZS4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgdHlwZT1cImRlZmF1bHRcIiBbdGV4dFZpc2liaWxpdHldPVwiZmFsc2VcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dFZpc2liaWxpdHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICpTZXQgdGhlIHBvc2l0aW9uIHRoYXQgZGVmaW5lcyBpZiB0aGUgdGV4dCBzaG91bGQgYmUgYWxpZ25lZCBhYm92ZSB0aGUgcHJvZ3Jlc3MgbGluZS4gQnkgZGVmYXVsdCBpcyBzZXQgdG8gZmFsc2UuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgdHlwZT1cImVycm9yXCIgW3RleHRUb3BdPVwidHJ1ZVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0ZXh0VG9wID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlNldCBhIGN1c3RvbSB0ZXh0IHRoYXQgaXMgZGlzcGxheWVkIGFjY29yZGluZyB0byB0aGUgZGVmaW5lZCBwb3NpdGlvbi5cbiAgICAgKiBgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgdHlwZT1cIndhcm5pbmdcIiBbdGV4dF09XCInQ3VzdG9tIHRleHQnXCIgW3RleHRBbGlnbl09XCJwb3NpdGlvbkNlbnRlclwiIFtzdHJpcGVkXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpTZXQgdHlwZSBvZiB0aGUgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YC4gUG9zc2libGUgb3B0aW9ucyAtIGBkZWZhdWx0YCwgYHN1Y2Nlc3NgLCBgaW5mb2AsIGB3YXJuaW5nYCwgYW5kIGBlcnJvcmAuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgW3N0cmlwZWRdPVwiZmFsc2VcIiBbbWF4XT1cIjEwMFwiIFt2YWx1ZV09XCIwXCIgdHlwZT1cImVycm9yXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdHlwZSA9ICdkZWZhdWx0JztcblxuICAgIC8qKlxuICAgICpSZXR1cm5zIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgcG9zaXRpb24uXG4gICAgKmBgYHR5cGVzY3JpcHRcbiAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDtcbiAgICAqcHVibGljIGdldFZhbHVlKGV2ZW50KSB7XG4gICAgKiAgICBsZXQgdmFsdWUgPSB0aGlzLnByb2dyZXNzQmFyLnZhbHVlO1xuICAgICogICAgYWxlcnQodmFsdWUpO1xuICAgICp9XG4gICAgKmBgYFxuICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtdmFsdWVub3cnKVxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHZhbHVlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlNldCB2YWx1ZSB0aGF0IGluZGljYXRlcyB0aGUgY3VycmVudCBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHBvc2l0aW9uLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgc2V0IHZhbHVlKHZhbCkge1xuICAgICAgICB2YWwgPSBOdW1iZXIodmFsKTtcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlID09PSB2YWwgfHwgdGhpcy5pbmRldGVybWluYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZUluUmFuZ2UgPSBnZXRWYWx1ZUluUHJvcGVyUmFuZ2UodmFsLCB0aGlzLm1heCk7XG4gICAgICAgIGlmIChpc05hTih2YWx1ZUluUmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbmdlZFZhbHVlcyA9IHtcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZTogdmFsdWVJblJhbmdlLFxuICAgICAgICAgICAgcHJldmlvdXNWYWx1ZTogdGhpcy5fdmFsdWVcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB1cGRhdGVWYWx1ZSA9IHN1cGVyLmRpcmVjdGlvbkZsb3codGhpcy5fdmFsdWUsIHZhbCwgdGhpcy5zdGVwKTtcbiAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGUgJiYgdmFsID49IHRoaXMuc3RlcCkge1xuICAgICAgICAgICAgc3VwZXIucnVuQW5pbWF0aW9uKHZhbHVlSW5SYW5nZSwgdXBkYXRlVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIudXBkYXRlUHJvZ3Jlc3NEaXJlY3RseSh2YWx1ZUluUmFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vblByb2dyZXNzQ2hhbmdlZC5lbWl0KGNoYW5nZWRWYWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqQW4gZXZlbnQsIHdoaWNoIGlzIHRyaWdnZXJlZCBhZnRlciBhIHByb2dyZXNzIGlzIGNoYW5nZWQuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NDaGFuZ2UoZXZlbnQpIHtcbiAgICAgKiAgICBhbGVydChcIlByb2dyZXNzIG1hZGUhXCIpO1xuICAgICAqfVxuICAgICAqIC8vLi4uXG4gICAgICpgYGBcbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciAob25Qcm9ncmVzc0NoYW5nZWQpPVwicHJvZ3Jlc3NDaGFuZ2UoJGV2ZW50KVwiIHR5cGU9XCJzdWNjZXNzXCI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgcHVibGljIG9uUHJvZ3Jlc3NDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjxJQ2hhbmdlUHJvZ3Jlc3NFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtbGluZWFyLWJhci0tZGFuZ2VyJylcbiAgICBwdWJsaWMgZ2V0IGVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBJZ3hQcm9ncmVzc1R5cGUuRVJST1I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWxpbmVhci1iYXItLWluZm8nKVxuICAgIHB1YmxpYyBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gSWd4UHJvZ3Jlc3NUeXBlLklORk87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWxpbmVhci1iYXItLXdhcm5pbmcnKVxuICAgIHB1YmxpYyBnZXQgd2FybmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gSWd4UHJvZ3Jlc3NUeXBlLldBUk5JTkc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWxpbmVhci1iYXItLXN1Y2Nlc3MnKVxuICAgIHB1YmxpYyBnZXQgc3VjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gSWd4UHJvZ3Jlc3NUeXBlLlNVQ0NFU1M7XG4gICAgfVxufVxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC1jaXJjdWxhci1iYXInLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGVzL2NpcmN1bGFyLWJhci5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudCBleHRlbmRzIEJhc2VQcm9ncmVzcyBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBTVFJPS0VfT1BBQ0lUWV9EVklERVIgPSAxMDA7XG4gICAgcHJpdmF0ZSByZWFkb25seSBTVFJPS0VfT1BBQ0lUWV9BRERJVElPTiA9IC4yO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1jaXJjdWxhci1iYXInKVxuICAgIHB1YmxpYyBjc3NDbGFzcyA9ICdpZ3gtY2lyY3VsYXItYmFyJztcblxuICAgIC8qKlxuICAgICAqQW4gZXZlbnQsIHdoaWNoIGlzIHRyaWdnZXJlZCBhZnRlciBhIHByb2dyZXNzIGlzIGNoYW5nZWQuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NDaGFuZ2UoZXZlbnQpIHtcbiAgICAgKiAgICBhbGVydChcIlByb2dyZXNzIG1hZGUhXCIpO1xuICAgICAqfVxuICAgICAqIC8vLi4uXG4gICAgICpgYGBcbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFt2YWx1ZV09XCJjdXJyZW50VmFsdWVcIiAob25Qcm9ncmVzc0NoYW5nZWQpPVwicHJvZ3Jlc3NDaGFuZ2UoJGV2ZW50KVwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvblByb2dyZXNzQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8SUNoYW5nZVByb2dyZXNzRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICpBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiBgaWRgIGF0dHJpYnV0ZS4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWNpcmN1bGFyLWJhciBbaWRdPVwiJ2lneC1jaXJjdWxhci1iYXItNTUnXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZCA9IGBpZ3gtY2lyY3VsYXItYmFyLSR7TkVYVF9DSVJDVUxBUl9JRCsrfWA7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdyYWRpZW50SWQgPSBgaWd4LWNpcmN1bGFyLWdyYWRpZW50LSR7TkVYVF9HUkFESUVOVF9JRCsrfWA7XG5cbiAgICAvKipcbiAgICAgKkFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIHRoZSBgaW5kZXRlcm1pbmF0ZWAgYXR0cmlidXRlLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byBmYWxzZS5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFtpbmRldGVybWluYXRlXT1cInRydWVcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1jaXJjdWxhci1iYXItLWluZGV0ZXJtaW5hdGUnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGluZGV0ZXJtaW5hdGUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqU2V0cyB0aGUgdGV4dCB2aXNpYmlsaXR5LiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byB0cnVlLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1jaXJjdWxhci1iYXIgW3RleHRWaXNpYmlsaXR5XT1cImZhbHNlXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dFZpc2liaWxpdHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSB0ZXh0IHRvIGJlIGRpc3BsYXllZCBpbnNpZGUgdGhlIGBpZ3hDaXJjdWxhckJhcmAuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWNpcmN1bGFyLWJhciB0ZXh0PVwiUHJvZ3Jlc3NcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKmxldCB0ZXh0ID0gdGhpcy5jaXJjdWxhckJhci50ZXh0O1xuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dDogc3RyaW5nO1xuXG4gICAgQENvbnRlbnRDaGlsZChJZ3hQcm9jZXNzQmFyVGV4dFRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IElneFByb2Nlc3NCYXJUZXh0VGVtcGxhdGVEaXJlY3RpdmUgfSlcbiAgICBwdWJsaWMgdGV4dFRlbXBsYXRlOiBJZ3hQcm9jZXNzQmFyVGV4dFRlbXBsYXRlRGlyZWN0aXZlO1xuXG4gICAgQENvbnRlbnRDaGlsZChJZ3hQcm9ncmVzc0JhckdyYWRpZW50RGlyZWN0aXZlLCB7IHJlYWQ6IElneFByb2dyZXNzQmFyR3JhZGllbnREaXJlY3RpdmUgfSlcbiAgICBwdWJsaWMgZ3JhZGllbnRUZW1wbGF0ZTogSWd4UHJvZ3Jlc3NCYXJHcmFkaWVudERpcmVjdGl2ZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgIHB1YmxpYyBnZXQgY29udGV4dCgpOiBhbnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJGltcGxpY2l0OiB7IHZhbHVlOiB0aGlzLnZhbHVlLCB2YWx1ZUluUGVyY2VudDogdGhpcy52YWx1ZUluUGVyY2VudCwgbWF4OiB0aGlzLm1heCB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKkFuaW1hdGlvbiBvbiBwcm9ncmVzcyBgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIHRydWUuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWNpcmN1bGFyLWJhciBbYW5pbWF0ZV09XCJmYWxzZVwiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IGFuaW1hdGUoYW5pbWF0ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9hbmltYXRlID0gYW5pbWF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlJldHVybnMgd2hldGhlciB0aGUgYElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIGhhcyBhbmltYXRpb24gdHJ1ZS9mYWxzZS5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgYW5pbWF0aW9uU3RhdHVzKGV2ZW50KSB7XG4gICAgICogICAgbGV0IGFuaW1hdGlvblN0YXR1cyA9IHRoaXMucHJvZ3Jlc3NCYXIuYW5pbWF0ZTtcbiAgICAgKiAgICBhbGVydChhbmltYXRpb25TdGF0dXMpO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IGFuaW1hdGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqU2V0IG1heGltdW0gdmFsdWUgdGhhdCBjYW4gYmUgcGFzc2VkLiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byAxMDAuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWNpcmN1bGFyLWJhciBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCIwXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZXQgbWF4KG1heE51bTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX21heCA9IG1heE51bTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlJldHVybnMgdGhlIHRoZSBtYXhpbXVtIHByb2dyZXNzIHZhbHVlIG9mIHRoZSBgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50O1xuICAgICAqcHVibGljIG1heFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgbGV0IG1heCA9IHRoaXMucHJvZ3Jlc3NCYXIubWF4O1xuICAgICAqICAgIGFsZXJ0KG1heCk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFttYXhdPVwiMjQ1XCIgW2FuaW1hdGVdPVwiZmFsc2VcIiBbdmFsdWVdPVwiY3VycmVudFZhbHVlXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IG1heCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqUmV0dXJucyB0aGUgdmFsdWUgd2hpY2ggdXBkYXRlIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3Igb2YgdGhlIGBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50YC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgc3RlcFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgbGV0IHN0ZXAgPSB0aGlzLnByb2dyZXNzQmFyLnN0ZXA7XG4gICAgICogICAgYWxlcnQoc3RlcCk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBzdGVwKCk6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLl9zdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RlcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXggKiBPTkVfUEVSQ0VOVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlNldHMgdGhlIHZhbHVlIGJ5IHdoaWNoIHByb2dyZXNzIGluZGljYXRvciBpcyB1cGRhdGVkLiBCeSBkZWZhdWx0IGl0IGlzIDElIG9mIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1jaXJjdWxhci1iYXIgW3N0cmlwZWRdPVwiZmFsc2VcIiBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCIwXCIgW3N0ZXBdPVwiMVwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKmBgYFxuICAgICovXG4gICAgc2V0IHN0ZXAodmFsOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fc3RlcCA9IE51bWJlcih2YWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqUmV0dXJucyB2YWx1ZSB0aGF0IGluZGljYXRlcyB0aGUgY3VycmVudCBgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgcG9zaXRpb24uXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50O1xuICAgICAqcHVibGljIGdldFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgbGV0IHZhbHVlID0gdGhpcy5wcm9ncmVzc0Jhci52YWx1ZTtcbiAgICAgKiAgICBhbGVydCh2YWx1ZSk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKmBgYGh0bWxcbiAgICAgKjxidXR0b24gaWd4QnV0dG9uPVwiZmFiXCIgaWd4UmlwcGxlPVwiXCIgKGNsaWNrKT1cImdldFZhbHVlKClcIj5DbGljazwvYnV0dG9uPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgdmFsdWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqU2V0IHZhbHVlIHRoYXQgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50YCBwb3NpdGlvbi5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHNldCB2YWx1ZSh2YWw6IG51bWJlcikge1xuICAgICAgICB2YWwgPSBOdW1iZXIodmFsKTtcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlID09PSB2YWwgfHwgdGhpcy5pbmRldGVybWluYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZUluUHJvcGVyUmFuZ2UgPSBnZXRWYWx1ZUluUHJvcGVyUmFuZ2UodmFsLCB0aGlzLm1heCk7XG4gICAgICAgIGlmIChpc05hTih2YWx1ZUluUHJvcGVyUmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGFuZ2VkVmFsdWVzID0ge1xuICAgICAgICAgICAgY3VycmVudFZhbHVlOiB2YWx1ZUluUHJvcGVyUmFuZ2UsXG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlOiB0aGlzLl92YWx1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHVwZGF0ZVZhbHVlID0gc3VwZXIuZGlyZWN0aW9uRmxvdyh0aGlzLl92YWx1ZSwgdmFsLCB0aGlzLnN0ZXApO1xuICAgICAgICBpZiAodGhpcy5hbmltYXRlICYmIHZhbCA+PSB0aGlzLnN0ZXApIHtcbiAgICAgICAgICAgIHN1cGVyLnJ1bkFuaW1hdGlvbih2YWx1ZUluUHJvcGVyUmFuZ2UsIHVwZGF0ZVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3NEaXJlY3RseSh2YWx1ZUluUHJvcGVyUmFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vblByb2dyZXNzQ2hhbmdlZC5lbWl0KGNoYW5nZWRWYWx1ZXMpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NpcmNsZVJhZGl1cyA9IDQ2O1xuICAgIHByaXZhdGUgX2NpcmN1bWZlcmVuY2UgPSAyICogTWF0aC5QSSAqIHRoaXMuX2NpcmNsZVJhZGl1cztcblxuICAgIEBWaWV3Q2hpbGQoJ2NpcmNsZScsIHsgc3RhdGljOiB0cnVlIH0pIHByaXZhdGUgX3N2Z0NpcmNsZTogRWxlbWVudFJlZjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBfZGlyZWN0aW9uYWxpdHk6IElneERpcmVjdGlvbmFsaXR5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKFxuICAgICAgICAgICAgdGhpcy5fc3ZnQ2lyY2xlLm5hdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICAnc3Ryb2tlJyxcbiAgICAgICAgICAgIGB1cmwoIyR7dGhpcy5ncmFkaWVudElkfSlgXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyB1cGRhdGVQcm9ncmVzc1Ntb290aGx5KHZhbDogbnVtYmVyLCBzdGVwOiBudW1iZXIpIHtcbiAgICAgICAgLy8gU2V0IGZyYW1lcyBmb3IgdGhlIGFuaW1hdGlvblxuICAgICAgICBjb25zdCBGUkFNRVMgPSBbe1xuICAgICAgICAgICAgc3Ryb2tlRGFzaG9mZnNldDogdGhpcy5nZXRQcm9ncmVzcyh0aGlzLl92YWx1ZSksXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAodGhpcy5fdmFsdWUgLyB0aGlzLlNUUk9LRV9PUEFDSVRZX0RWSURFUikgKyB0aGlzLlNUUk9LRV9PUEFDSVRZX0FERElUSU9OXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHN0cm9rZURhc2hvZmZzZXQ6IHRoaXMuZ2V0UHJvZ3Jlc3ModGhpcy52YWx1ZUluUGVyY2VudCksXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAodGhpcy52YWx1ZUluUGVyY2VudCAvIHRoaXMuU1RST0tFX09QQUNJVFlfRFZJREVSKSArIHRoaXMuU1RST0tFX09QQUNJVFlfQURESVRJT05cbiAgICAgICAgfV07XG4gICAgICAgIHRoaXMuX3N2Z0NpcmNsZS5uYXRpdmVFbGVtZW50LmFuaW1hdGUoRlJBTUVTLCB7XG4gICAgICAgICAgICBlYXNpbmc6ICdlYXNlLW91dCcsXG4gICAgICAgICAgICBmaWxsOiAnZm9yd2FyZHMnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN1cGVyLnVwZGF0ZVByb2dyZXNzU21vb3RobHkodmFsLCBzdGVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRleHRDb250ZW50KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICovXG4gICAgcHVibGljIHVwZGF0ZVByb2dyZXNzRGlyZWN0bHkodmFsOiBudW1iZXIpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlUHJvZ3Jlc3NEaXJlY3RseSh2YWwpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoXG4gICAgICAgICAgICB0aGlzLl9zdmdDaXJjbGUubmF0aXZlRWxlbWVudCxcbiAgICAgICAgICAgICdzdHJva2UtZGFzaG9mZnNldCcsXG4gICAgICAgICAgICB0aGlzLmdldFByb2dyZXNzKHRoaXMudmFsdWVJblBlcmNlbnQpKTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKFxuICAgICAgICAgICAgdGhpcy5fc3ZnQ2lyY2xlLm5hdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknLFxuICAgICAgICAgICAgKHRoaXMudmFsdWVJblBlcmNlbnQgLyB0aGlzLlNUUk9LRV9PUEFDSVRZX0RWSURFUikgKyB0aGlzLlNUUk9LRV9PUEFDSVRZX0FERElUSU9OKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFByb2dyZXNzKHBlcmNlbnRhZ2U6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uYWxpdHkucnRsID9cbiAgICAgICAgICAgIHRoaXMuX2NpcmN1bWZlcmVuY2UgKyAocGVyY2VudGFnZSAqIHRoaXMuX2NpcmN1bWZlcmVuY2UgLyAxMDApIDpcbiAgICAgICAgICAgIHRoaXMuX2NpcmN1bWZlcmVuY2UgLSAocGVyY2VudGFnZSAqIHRoaXMuX2NpcmN1bWZlcmVuY2UgLyAxMDApO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlSW5Qcm9wZXJSYW5nZSh2YWx1ZTogbnVtYmVyLCBtYXg6IG51bWJlciwgbWluID0gMCk6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHZhbHVlLCBtYXgpLCBtaW4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydEluUGVyY2VudGFnZSh2YWx1ZTogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICAgIHJldHVybiBNYXRoLmZsb29yKDEwMCAqIHZhbHVlIC8gbWF4KTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50LFxuICAgICAgICBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50LFxuICAgICAgICBJZ3hQcm9jZXNzQmFyVGV4dFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICBJZ3hQcm9ncmVzc0JhckdyYWRpZW50RGlyZWN0aXZlLFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudCxcbiAgICAgICAgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudCxcbiAgICAgICAgSWd4UHJvY2Vzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgSWd4UHJvZ3Jlc3NCYXJHcmFkaWVudERpcmVjdGl2ZSxcbiAgICBdLFxuICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdXG59KVxuZXhwb3J0IGNsYXNzIElneFByb2dyZXNzQmFyTW9kdWxlIHsgfVxuXG4iXX0=