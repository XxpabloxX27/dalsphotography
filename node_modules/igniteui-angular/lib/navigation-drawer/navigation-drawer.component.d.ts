import { AfterContentInit, ElementRef, EventEmitter, OnChanges, OnDestroy, OnInit, SimpleChange, Renderer2 } from '@angular/core';
import { IgxNavigationService, IToggleView } from '../core/navigation';
import { HammerGesturesManager } from '../core/touch';
import { IgxNavDrawerMiniTemplateDirective, IgxNavDrawerTemplateDirective } from './navigation-drawer.directives';
import { PlatformUtil } from '../core/utils';
/**
 * **Ignite UI for Angular Navigation Drawer** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navdrawer.html)
 *
 * The Ignite UI Navigation Drawer is a collapsible side navigation container commonly used in combination with the Navbar.
 *
 * Example:
 * ```html
 * <igx-nav-drawer id="navigation" [isOpen]="true">
 *   <ng-template igxDrawer>
 *     <nav>
 *       <span igxDrawerItem [isHeader]="true">Email</span>
 *       <span igxDrawerItem igxRipple>Inbox</span>
 *       <span igxDrawerItem igxRipple>Deleted</span>
 *       <span igxDrawerItem igxRipple>Sent</span>
 *     </nav>
 *   </ng-template>
 * </igx-nav-drawer>
 * ```
 */
import * as ɵngcc0 from '@angular/core';
export declare class IgxNavigationDrawerComponent implements IToggleView, OnInit, AfterContentInit, OnDestroy, OnChanges {
    private elementRef;
    private _state;
    protected renderer: Renderer2;
    private _touchManager;
    private platformUtil;
    private _isOpen;
    /** @hidden @internal */
    cssClass: boolean;
    /**
     * ID of the component
     *
     * ```typescript
     * // get
     * let myNavDrawerId = this.navdrawer.id;
     * ```
     *
     * ```html
     * <!--set-->
     *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
     * ```
     */
    id: string;
    /**
     * Position of the Navigation Drawer. Can be "left"(default) or "right".
     *
     * ```typescript
     * // get
     * let myNavDrawerPosition = this.navdrawer.position;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
     * ```
     */
    position: string;
    /**
     * Enables the use of touch gestures to manipulate the drawer:
     * - swipe/pan from edge to open, swipe-toggle and pan-drag.
     *
     * ```typescript
     * // get
     * let gesturesEnabled = this.navdrawer.enableGestures;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
     * ```
     */
    enableGestures: boolean;
    /**
     * State of the drawer.
     *
     * ```typescript
     * // get
     * let navDrawerIsOpen = this.navdrawer.isOpen;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <!--set-->
     * <igx-nav-drawer [(isOpen)]='model.isOpen'></igx-nav-drawer>
     * ```
     */
    get isOpen(): boolean;
    set isOpen(value: boolean);
    /**
     *@hidden
     */
    isOpenChange: EventEmitter<boolean>;
    /**
     * When pinned the drawer is relatively positioned instead of sitting above content.
     * May require additional layout styling.
     *
     * ```typescript
     * // get
     * let navDrawerIsPinned = this.navdrawer.pin;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
     * ```
     */
    pin: boolean;
    /**
     * Minimum device width required for automatic pin to be toggled.
     * Default is 1024, can be set to a falsy value to disable this behavior.
     *
     * ```typescript
     * // get
     * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
     * ```
     */
    pinThreshold: number;
    /**
     * Returns nativeElement of the component.
     *
     * @hidden
     */
    get element(): any;
    /**
     * Width of the drawer in its open state. Defaults to "280px".
     *
     * ```typescript
     * // get
     * let navDrawerWidth = this.navdrawer.width;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
     * ```
     */
    width: string;
    /**
     * Width of the drawer in its mini state. Defaults to 68px.
     *
     * ```typescript
     * // get
     * let navDrawerMiniWidth = this.navdrawer.miniWidth;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
     * ```
     */
    miniWidth: string;
    /**
     * Pinned state change output for two-way binding.
     *
     * ```html
     * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
     * ```
     */
    pinChange: EventEmitter<boolean>;
    /**
     * Event fired as the Navigation Drawer is about to open.
     *
     * ```html
     *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
     * ```
     */
    opening: EventEmitter<any>;
    /**
     * Event fired when the Navigation Drawer has opened.
     *
     * ```html
     * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
     * ```
     */
    opened: EventEmitter<any>;
    /**
     * Event fired as the Navigation Drawer is about to close.
     *
     * ```html
     * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
     * ```
     */
    closing: EventEmitter<any>;
    /**
     * Event fired when the Navigation Drawer has closed.
     *
     * ```html
     * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
     * ```
     */
    closed: EventEmitter<any>;
    /**
     * @hidden
     */
    get template(): import("@angular/core").TemplateRef<any>;
    private _miniTemplate;
    /**
     * @hidden
     */
    get miniTemplate(): IgxNavDrawerMiniTemplateDirective;
    /**
     * @hidden
     */
    set miniTemplate(v: IgxNavDrawerMiniTemplateDirective);
    /**
     * @hidden
     */
    protected contentTemplate: IgxNavDrawerTemplateDirective;
    /**
     * @hidden
     */
    get flexWidth(): string;
    /** @hidden */
    get isPinnedRight(): "0" | "1";
    private _gesturesAttached;
    private _widthCache;
    private _resizeObserver;
    private css;
    private _drawer;
    private _overlay;
    private _styleDummy;
    /**
      * @hidden
      */
    get drawer(): any;
    /**
     * @hidden
     */
    get overlay(): any;
    /**
     * @hidden
     */
    get styleDummy(): any;
    /** Pan animation properties */
    private _panning;
    private _panStartWidth;
    private _panLimit;
    /**
     * Property to decide whether to change width or translate the drawer from pan gesture.
     *
     * @hidden
     */
    get hasAnimateWidth(): boolean;
    private _maxEdgeZone;
    /**
     * Used for touch gestures (swipe and pan).
     * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
     *
     * @hidden
     */
    get maxEdgeZone(): number;
    /**
     * Gets the Drawer width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     *
     * @hidden
     */
    get expectedWidth(): number;
    /**
     * Get the Drawer mini width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     * @hidden
     */
    get expectedMiniWidth(): number;
    /**
     * @hidden
     */
    get touchManager(): HammerGesturesManager;
    /**
     * Exposes optional navigation service
     *
     * @hidden
     */
    get state(): IgxNavigationService;
    constructor(elementRef: ElementRef, _state: IgxNavigationService, renderer: Renderer2, _touchManager: HammerGesturesManager, platformUtil: PlatformUtil);
    /**
     * @hidden
     */
    ngOnInit(): void;
    /**
     * @hidden
     */
    ngAfterContentInit(): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    ngOnChanges(changes: {
        [propName: string]: SimpleChange;
    }): void;
    /**
     * Toggle the open state of the Navigation Drawer.
     *
     * ```typescript
     * this.navdrawer.toggle();
     * ```
     */
    toggle(): void;
    /**
     * Open the Navigation Drawer. Has no effect if already opened.
     *
     * ```typescript
     * this.navdrawer.open();
     * ```
     */
    open(): void;
    /**
     * Close the Navigation Drawer. Has no effect if already closed.
     *
     * ```typescript
     * this.navdrawer.close();
     * ```
     */
    close(): void;
    /**
     * @hidden
     */
    protected set_maxEdgeZone(value: number): void;
    /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @param [mini] - Request mini width instead
     */
    protected getExpectedWidth(mini?: boolean): number;
    private getWindowWidth;
    /**
     * Sets the drawer width.
     */
    private setDrawerWidth;
    /**
     * Get current Drawer width.
     */
    private getDrawerWidth;
    private ensureEvents;
    private updateEdgeZone;
    private checkPinThreshold;
    private swipe;
    private panstart;
    private pan;
    private panEnd;
    private resetPan;
    /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     * @param x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param opacity optional value to apply to the overlay
     */
    private setXSize;
    private toggleOpenedEvent;
    private toggleClosedEvent;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxNavigationDrawerComponent>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<IgxNavigationDrawerComponent, "igx-nav-drawer", never, {
    "id": "id";
    "position": "position";
    "enableGestures": "enableGestures";
    "pin": "pin";
    "pinThreshold": "pinThreshold";
    "width": "width";
    "miniWidth": "miniWidth";
    "isOpen": "isOpen";
}, {
    "isOpenChange": "isOpenChange";
    "pinChange": "pinChange";
    "opening": "opening";
    "opened": "opened";
    "closing": "closing";
    "closed": "closed";
}, ["miniTemplate", "contentTemplate"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdGlvbi1kcmF3ZXIuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbIm5hdmlnYXRpb24tZHJhd2VyLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeVZBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LCBTaW1wbGVDaGFuZ2UsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4TmF2aWdhdGlvblNlcnZpY2UsIElUb2dnbGVWaWV3IH0gZnJvbSAnLi4vY29yZS9uYXZpZ2F0aW9uJztcbmltcG9ydCB7IEhhbW1lckdlc3R1cmVzTWFuYWdlciB9IGZyb20gJy4uL2NvcmUvdG91Y2gnO1xuaW1wb3J0IHsgSWd4TmF2RHJhd2VyTWluaVRlbXBsYXRlRGlyZWN0aXZlLCBJZ3hOYXZEcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZSB9IGZyb20gJy4vbmF2aWdhdGlvbi1kcmF3ZXIuZGlyZWN0aXZlcyc7XG5pbXBvcnQgeyBQbGF0Zm9ybVV0aWwgfSBmcm9tICcuLi9jb3JlL3V0aWxzJztcbi8qKlxuICogKipJZ25pdGUgVUkgZm9yIEFuZ3VsYXIgTmF2aWdhdGlvbiBEcmF3ZXIqKiAtXG4gKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cuaW5mcmFnaXN0aWNzLmNvbS9wcm9kdWN0cy9pZ25pdGUtdWktYW5ndWxhci9hbmd1bGFyL2NvbXBvbmVudHMvbmF2ZHJhd2VyLmh0bWwpXG4gKlxuICogVGhlIElnbml0ZSBVSSBOYXZpZ2F0aW9uIERyYXdlciBpcyBhIGNvbGxhcHNpYmxlIHNpZGUgbmF2aWdhdGlvbiBjb250YWluZXIgY29tbW9ubHkgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSBOYXZiYXIuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxpZ3gtbmF2LWRyYXdlciBpZD1cIm5hdmlnYXRpb25cIiBbaXNPcGVuXT1cInRydWVcIj5cbiAqICAgPG5nLXRlbXBsYXRlIGlneERyYXdlcj5cbiAqICAgICA8bmF2PlxuICogICAgICAgPHNwYW4gaWd4RHJhd2VySXRlbSBbaXNIZWFkZXJdPVwidHJ1ZVwiPkVtYWlsPC9zcGFuPlxuICogICAgICAgPHNwYW4gaWd4RHJhd2VySXRlbSBpZ3hSaXBwbGU+SW5ib3g8L3NwYW4+XG4gKiAgICAgICA8c3BhbiBpZ3hEcmF3ZXJJdGVtIGlneFJpcHBsZT5EZWxldGVkPC9zcGFuPlxuICogICAgICAgPHNwYW4gaWd4RHJhd2VySXRlbSBpZ3hSaXBwbGU+U2VudDwvc3Bhbj5cbiAqICAgICA8L25hdj5cbiAqICAgPC9uZy10ZW1wbGF0ZT5cbiAqIDwvaWd4LW5hdi1kcmF3ZXI+XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4TmF2aWdhdGlvbkRyYXdlckNvbXBvbmVudCBpbXBsZW1lbnRzIElUb2dnbGVWaWV3LCBPbkluaXQsIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzIHtcbiAgICBwcml2YXRlIGVsZW1lbnRSZWY7XG4gICAgcHJpdmF0ZSBfc3RhdGU7XG4gICAgcHJvdGVjdGVkIHJlbmRlcmVyOiBSZW5kZXJlcjI7XG4gICAgcHJpdmF0ZSBfdG91Y2hNYW5hZ2VyO1xuICAgIHByaXZhdGUgcGxhdGZvcm1VdGlsO1xuICAgIHByaXZhdGUgX2lzT3BlbjtcbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBjc3NDbGFzczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBJRCBvZiB0aGUgY29tcG9uZW50XG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG15TmF2RHJhd2VySWQgPSB0aGlzLm5hdmRyYXdlci5pZDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogIDxpZ3gtbmF2LWRyYXdlciBpZD0nbmF2ZHJhd2VyJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGlkOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gb2YgdGhlIE5hdmlnYXRpb24gRHJhd2VyLiBDYW4gYmUgXCJsZWZ0XCIoZGVmYXVsdCkgb3IgXCJyaWdodFwiLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBteU5hdkRyYXdlclBvc2l0aW9uID0gdGhpcy5uYXZkcmF3ZXIucG9zaXRpb247XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbcG9zaXRpb25dPVwiJ2xlZnQnXCI+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwb3NpdGlvbjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIHVzZSBvZiB0b3VjaCBnZXN0dXJlcyB0byBtYW5pcHVsYXRlIHRoZSBkcmF3ZXI6XG4gICAgICogLSBzd2lwZS9wYW4gZnJvbSBlZGdlIHRvIG9wZW4sIHN3aXBlLXRvZ2dsZSBhbmQgcGFuLWRyYWcuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IGdlc3R1cmVzRW5hYmxlZCA9IHRoaXMubmF2ZHJhd2VyLmVuYWJsZUdlc3R1cmVzO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW2VuYWJsZUdlc3R1cmVzXT0ndHJ1ZSc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBlbmFibGVHZXN0dXJlczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTdGF0ZSBvZiB0aGUgZHJhd2VyLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBuYXZEcmF3ZXJJc09wZW4gPSB0aGlzLm5hdmRyYXdlci5pc09wZW47XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbaXNPcGVuXT0nZmFsc2UnPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUd28td2F5IGRhdGEgYmluZGluZy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbKGlzT3BlbildPSdtb2RlbC5pc09wZW4nPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGlzT3BlbigpOiBib29sZWFuO1xuICAgIHNldCBpc09wZW4odmFsdWU6IGJvb2xlYW4pO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIGlzT3BlbkNoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+O1xuICAgIC8qKlxuICAgICAqIFdoZW4gcGlubmVkIHRoZSBkcmF3ZXIgaXMgcmVsYXRpdmVseSBwb3NpdGlvbmVkIGluc3RlYWQgb2Ygc2l0dGluZyBhYm92ZSBjb250ZW50LlxuICAgICAqIE1heSByZXF1aXJlIGFkZGl0aW9uYWwgbGF5b3V0IHN0eWxpbmcuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG5hdkRyYXdlcklzUGlubmVkID0gdGhpcy5uYXZkcmF3ZXIucGluO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW3Bpbl09J2ZhbHNlJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHBpbjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGRldmljZSB3aWR0aCByZXF1aXJlZCBmb3IgYXV0b21hdGljIHBpbiB0byBiZSB0b2dnbGVkLlxuICAgICAqIERlZmF1bHQgaXMgMTAyNCwgY2FuIGJlIHNldCB0byBhIGZhbHN5IHZhbHVlIHRvIGRpc2FibGUgdGhpcyBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRcbiAgICAgKiBsZXQgbmF2RHJhd2VyUGluVHJlc2hvbGQgPSB0aGlzLm5hdmRyYXdlci5waW5UaHJlc2hvbGQ7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbcGluVHJlc2hvbGRdPScxMDI0Jz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHBpblRocmVzaG9sZDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmF0aXZlRWxlbWVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBlbGVtZW50KCk6IGFueTtcbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiB0aGUgZHJhd2VyIGluIGl0cyBvcGVuIHN0YXRlLiBEZWZhdWx0cyB0byBcIjI4MHB4XCIuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG5hdkRyYXdlcldpZHRoID0gdGhpcy5uYXZkcmF3ZXIud2lkdGg7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbd2lkdGhdPVwiJzIyOHB4J1wiPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgd2lkdGg6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiB0aGUgZHJhd2VyIGluIGl0cyBtaW5pIHN0YXRlLiBEZWZhdWx0cyB0byA2OHB4LlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBuYXZEcmF3ZXJNaW5pV2lkdGggPSB0aGlzLm5hdmRyYXdlci5taW5pV2lkdGg7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbbWluaVdpZHRoXT1cIiczNHB4J1wiPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgbWluaVdpZHRoOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogUGlubmVkIHN0YXRlIGNoYW5nZSBvdXRwdXQgZm9yIHR3by13YXkgYmluZGluZy5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgWyhwaW4pXT0naXNQaW5uZWQnPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcGluQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj47XG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgYXMgdGhlIE5hdmlnYXRpb24gRHJhd2VyIGlzIGFib3V0IHRvIG9wZW4uXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogIDxpZ3gtbmF2LWRyYXdlciAob3BlbmluZyk9J29uT3BlbmluZygpJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9wZW5pbmc6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIE5hdmlnYXRpb24gRHJhd2VyIGhhcyBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1uYXYtZHJhd2VyIChvcGVuZWQpPSdvbk9wZW5lZCgpJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9wZW5lZDogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgYXMgdGhlIE5hdmlnYXRpb24gRHJhd2VyIGlzIGFib3V0IHRvIGNsb3NlLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciAoY2xvc2luZyk9J29uQ2xvc2luZygpJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNsb3Npbmc6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIE5hdmlnYXRpb24gRHJhd2VyIGhhcyBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1uYXYtZHJhd2VyIChjbG9zZWQpPSdvbkNsb3NlZCgpJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNsb3NlZDogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCB0ZW1wbGF0ZSgpOiBpbXBvcnQoXCJAYW5ndWxhci9jb3JlXCIpLlRlbXBsYXRlUmVmPGFueT47XG4gICAgcHJpdmF0ZSBfbWluaVRlbXBsYXRlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgbWluaVRlbXBsYXRlKCk6IElneE5hdkRyYXdlck1pbmlUZW1wbGF0ZURpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IG1pbmlUZW1wbGF0ZSh2OiBJZ3hOYXZEcmF3ZXJNaW5pVGVtcGxhdGVEaXJlY3RpdmUpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY29udGVudFRlbXBsYXRlOiBJZ3hOYXZEcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGZsZXhXaWR0aCgpOiBzdHJpbmc7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBnZXQgaXNQaW5uZWRSaWdodCgpOiBcIjBcIiB8IFwiMVwiO1xuICAgIHByaXZhdGUgX2dlc3R1cmVzQXR0YWNoZWQ7XG4gICAgcHJpdmF0ZSBfd2lkdGhDYWNoZTtcbiAgICBwcml2YXRlIF9yZXNpemVPYnNlcnZlcjtcbiAgICBwcml2YXRlIGNzcztcbiAgICBwcml2YXRlIF9kcmF3ZXI7XG4gICAgcHJpdmF0ZSBfb3ZlcmxheTtcbiAgICBwcml2YXRlIF9zdHlsZUR1bW15O1xuICAgIC8qKlxuICAgICAgKiBAaGlkZGVuXG4gICAgICAqL1xuICAgIGdldCBkcmF3ZXIoKTogYW55O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgb3ZlcmxheSgpOiBhbnk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBzdHlsZUR1bW15KCk6IGFueTtcbiAgICAvKiogUGFuIGFuaW1hdGlvbiBwcm9wZXJ0aWVzICovXG4gICAgcHJpdmF0ZSBfcGFubmluZztcbiAgICBwcml2YXRlIF9wYW5TdGFydFdpZHRoO1xuICAgIHByaXZhdGUgX3BhbkxpbWl0O1xuICAgIC8qKlxuICAgICAqIFByb3BlcnR5IHRvIGRlY2lkZSB3aGV0aGVyIHRvIGNoYW5nZSB3aWR0aCBvciB0cmFuc2xhdGUgdGhlIGRyYXdlciBmcm9tIHBhbiBnZXN0dXJlLlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBoYXNBbmltYXRlV2lkdGgoKTogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9tYXhFZGdlWm9uZTtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciB0b3VjaCBnZXN0dXJlcyAoc3dpcGUgYW5kIHBhbikuXG4gICAgICogRGVmYXVsdHMgdG8gNTAgKGluIHB4KSBhbmQgaXMgZXh0ZW5kZWQgdG8gYXQgbGVhc3QgMTEwJSBvZiB0aGUgbWluaSB0ZW1wbGF0ZSB3aWR0aCBpZiBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IG1heEVkZ2Vab25lKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBEcmF3ZXIgd2lkdGggZm9yIHNwZWNpZmljIHN0YXRlLlxuICAgICAqIFdpbGwgYXR0ZW1wdCB0byBldmFsdWF0ZSByZXF1ZXN0ZWQgc3RhdGUgYW5kIGNhY2hlLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGV4cGVjdGVkV2lkdGgoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgRHJhd2VyIG1pbmkgd2lkdGggZm9yIHNwZWNpZmljIHN0YXRlLlxuICAgICAqIFdpbGwgYXR0ZW1wdCB0byBldmFsdWF0ZSByZXF1ZXN0ZWQgc3RhdGUgYW5kIGNhY2hlLlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBleHBlY3RlZE1pbmlXaWR0aCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCB0b3VjaE1hbmFnZXIoKTogSGFtbWVyR2VzdHVyZXNNYW5hZ2VyO1xuICAgIC8qKlxuICAgICAqIEV4cG9zZXMgb3B0aW9uYWwgbmF2aWdhdGlvbiBzZXJ2aWNlXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHN0YXRlKCk6IElneE5hdmlnYXRpb25TZXJ2aWNlO1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIF9zdGF0ZTogSWd4TmF2aWdhdGlvblNlcnZpY2UsIHJlbmRlcmVyOiBSZW5kZXJlcjIsIF90b3VjaE1hbmFnZXI6IEhhbW1lckdlc3R1cmVzTWFuYWdlciwgcGxhdGZvcm1VdGlsOiBQbGF0Zm9ybVV0aWwpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczoge1xuICAgICAgICBbcHJvcE5hbWU6IHN0cmluZ106IFNpbXBsZUNoYW5nZTtcbiAgICB9KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhlIG9wZW4gc3RhdGUgb2YgdGhlIE5hdmlnYXRpb24gRHJhd2VyLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMubmF2ZHJhd2VyLnRvZ2dsZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHRvZ2dsZSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIE5hdmlnYXRpb24gRHJhd2VyLiBIYXMgbm8gZWZmZWN0IGlmIGFscmVhZHkgb3BlbmVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMubmF2ZHJhd2VyLm9wZW4oKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBvcGVuKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIE5hdmlnYXRpb24gRHJhd2VyLiBIYXMgbm8gZWZmZWN0IGlmIGFscmVhZHkgY2xvc2VkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMubmF2ZHJhd2VyLmNsb3NlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgY2xvc2UoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHNldF9tYXhFZGdlWm9uZSh2YWx1ZTogbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIERyYXdlciB3aWR0aCBmb3Igc3BlY2lmaWMgc3RhdGUuIFdpbGwgYXR0ZW1wdCB0byBldmFsdWF0ZSByZXF1ZXN0ZWQgc3RhdGUgYW5kIGNhY2hlLlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBwYXJhbSBbbWluaV0gLSBSZXF1ZXN0IG1pbmkgd2lkdGggaW5zdGVhZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRFeHBlY3RlZFdpZHRoKG1pbmk/OiBib29sZWFuKTogbnVtYmVyO1xuICAgIHByaXZhdGUgZ2V0V2luZG93V2lkdGg7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZHJhd2VyIHdpZHRoLlxuICAgICAqL1xuICAgIHByaXZhdGUgc2V0RHJhd2VyV2lkdGg7XG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgRHJhd2VyIHdpZHRoLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0RHJhd2VyV2lkdGg7XG4gICAgcHJpdmF0ZSBlbnN1cmVFdmVudHM7XG4gICAgcHJpdmF0ZSB1cGRhdGVFZGdlWm9uZTtcbiAgICBwcml2YXRlIGNoZWNrUGluVGhyZXNob2xkO1xuICAgIHByaXZhdGUgc3dpcGU7XG4gICAgcHJpdmF0ZSBwYW5zdGFydDtcbiAgICBwcml2YXRlIHBhbjtcbiAgICBwcml2YXRlIHBhbkVuZDtcbiAgICBwcml2YXRlIHJlc2V0UGFuO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9yIHdpZHRoIGluIGNhc2UgdGhlIGRyYXdlciBkb2Vzbid0IGNoYW5nZSBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0geCB0aGUgbnVtYmVyIHBpeGVscyB0byB0cmFuc2xhdGUgb24gdGhlIFggYXhpcyBvciB0aGUgd2lkdGggdG8gc2V0LiAwIHdpZHRoIHdpbGwgY2xlYXIgdGhlIHN0eWxlIGluc3RlYWQuXG4gICAgICogQHBhcmFtIG9wYWNpdHkgb3B0aW9uYWwgdmFsdWUgdG8gYXBwbHkgdG8gdGhlIG92ZXJsYXlcbiAgICAgKi9cbiAgICBwcml2YXRlIHNldFhTaXplO1xuICAgIHByaXZhdGUgdG9nZ2xlT3BlbmVkRXZlbnQ7XG4gICAgcHJpdmF0ZSB0b2dnbGVDbG9zZWRFdmVudDtcbn1cbiJdfQ==