import { AfterViewInit, ElementRef, EventEmitter, OnInit, Renderer2, TemplateRef, OnDestroy, ChangeDetectorRef, OnChanges, NgZone, AfterContentInit } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { EditorProvider } from '../core/edit-provider';
import { Subject } from 'rxjs';
import { IRangeSliderValue, IgxSliderType, ISliderValueChangeEventArgs, TicksOrientation, TickLabelsOrientation } from './slider.common';
/**
 * **Ignite UI for Angular Slider** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/slider.html)
 *
 * The Ignite UI Slider allows selection in a given range by moving the thumb along the track. The track
 * can be defined as continuous or stepped, and you can choose between single and range slider types.
 *
 * Example:
 * ```html
 * <igx-slider id="slider"
 *            [minValue]="0" [maxValue]="100"
 *            [continuous]=true [(ngModel)]="volume">
 * </igx-slider>
 * ```
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './slider.common';
import * as ɵngcc2 from './thumb/thumb-slider.component';
import * as ɵngcc3 from './label/thumb-label.component';
import * as ɵngcc4 from './ticks/ticks.component';
import * as ɵngcc5 from './ticks/tick.pipe';
import * as ɵngcc6 from '@angular/common';
import * as ɵngcc7 from '@angular/forms';
export declare class IgxSliderComponent implements ControlValueAccessor, EditorProvider, OnInit, AfterViewInit, AfterContentInit, OnChanges, OnDestroy {
    private renderer;
    private _el;
    private _cdr;
    private _ngZone;
    private _pMin;
    private _pMax;
    private _hasViewInit;
    private _minValue;
    private _maxValue;
    private _lowerBound?;
    private _upperBound?;
    private _lowerValue?;
    private _upperValue?;
    private _continuous;
    private _disabled;
    private _step;
    private _value;
    private _primaryTicks;
    private _secondaryTicks;
    private _labels;
    private _type;
    private _destroyer$;
    private _indicatorsDestroyer$;
    private _indicatorsTimer;
    private _onChangeCallback;
    private _onTouchedCallback;
    /**
     * @hidden
     */
    private ticks;
    /**
     * @hidden
     */
    private thumbs;
    /**
     * @hidden
     */
    private labelRefs;
    private get thumbFrom();
    private get thumbTo();
    private get labelFrom();
    private get labelTo();
    /**
     * @hidden
     */
    trackRef: ElementRef;
    /**
     * @hidden
     */
    stepDistance: number;
    /**
     * @hidden
     */
    onPan: Subject<number>;
    /**
     * @hidden
     */
    thumbFromTemplateRef: TemplateRef<any>;
    /**
     * @hidden
     */
    thumbToTemplateRef: TemplateRef<any>;
    /**
     * @hidden
     */
    tickLabelTemplateRef: TemplateRef<any>;
    /**
     * @hidden
     */
    role: string;
    /**
     * @hidden
     */
    get valuemin(): number;
    /**
     * @hidden
     */
    get valuemax(): number;
    /**
     * @hidden
     */
    get readonly(): boolean;
    /**
     * @hidden
     */
    slierClass: boolean;
    /**
     * @hidden
     */
    get disabledClass(): boolean;
    /**
     * An @Input property that sets the value of the `id` attribute.
     * If not provided it will be automatically generated.
     * ```html
     * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     */
    id: string;
    /**
     * An @Input property that gets the type of the `IgxSliderComponent`.
     * The slider can be IgxSliderType.SLIDER(default) or IgxSliderType.RANGE.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let type = this.slider.type;
     * }
     */
    get type(): IgxSliderType;
    /**
     * An @Input property that sets the type of the `IgxSliderComponent`.
     * The slider can be IgxSliderType.SLIDER(default) or IgxSliderType.RANGE.
     * ```typescript
     * sliderType: IgxSliderType = IgxSliderType.RANGE;
     * ```
     * ```html
     * <igx-slider #slider2 [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="0" [maxValue]="100">
     * ```
     */
    set type(type: IgxSliderType);
    /**
     *An @Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
     *```html
     *<igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
     *```
     */
    thumbLabelVisibilityDuration: number;
    /**
     * Enables `labelView`, by accepting a collection of primitive values with more than one element.
     * Each element will be equally spread over the slider and it will serve as a thumb label.
     * Once the property is set, it will precendence over {@link maxValue}, {@link minValue}, {@link step}.
     * This means that the manipulation for those properties won't be allowed.
     */
    get labels(): Array<number | string | boolean | null | undefined>;
    set labels(labels: Array<number | string | boolean | null | undefined>);
    /**
     * Returns the template context corresponding
     * to {@link IgxThumbFromTemplateDirective} and {@link IgxThumbToTemplateDirective} templates.
     *
     * ```typescript
     * return {
     *  $implicit // returns the value of the label,
     *  labels // returns the labels collection the user has passed.
     * }
     * ```
     */
    get context(): any;
    /**
     * An @Input property that sets the incremental/decremental step of the value when dragging the thumb.
     * The default step is 1, and step should not be less or equal than 0.
     * ```html
     * <igx-slider #slider [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     */
    set step(step: number);
    /**
     * Returns the incremental/decremental dragging step of the {@link IgxSliderComponent}.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let step = this.slider.step;
     * }
     * ```
     */
    get step(): number;
    /**
     * Returns if the {@link IgxSliderComponent} is disabled.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let isDisabled = this.slider.disabled;
     * }
     * ```
     */
    get disabled(): boolean;
    /**
     *An @Input property that disables or enables UI interaction.
     *```html
     *<igx-slider #slider [disabled]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     *```
     */
    set disabled(disable: boolean);
    /**
     * Returns if the {@link IgxSliderComponent} is set as continuous.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let continuous = this.slider.continuous;
     * }
     * ```
     */
    get continuous(): boolean;
    /**
     * An @Input property that marks the {@link IgxSliderComponent} as continuous.
     * By default is considered that the {@link IgxSliderComponent} is discrete.
     * Discrete {@link IgxSliderComponent} does not have ticks and does not show bubble labels for values.
     * ```html
     * <igx-slider #slider [continuous]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     */
    set continuous(continuous: boolean);
    /**
     *Returns the minimal value of the `IgxSliderComponent`.
     *```typescript
     *@ViewChild("slider2")
     *public slider: IgxSliderComponent;
     *ngAfterViewInit(){
     *    let sliderMin = this.slider.minValue;
     *}
     *```
     */
    get minValue(): number;
    /**
     * Sets the minimal value for the `IgxSliderComponent`.
     * The default minimal value is 0.
     * ```html
     * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="100">
     * ```
     */
    set minValue(value: number);
    /**
 * Returns the maximum value for the {@link IgxSliderComponent}.
 * ```typescript
 *@ViewChild("slider")
 *public slider: IgxSliderComponent;
 *ngAfterViewInit(){
 *    let sliderMax = this.slider.maxValue;
 *}
 * ```
 */
    get maxValue(): number;
    /**
     * Sets the maximal value for the `IgxSliderComponent`.
     * The default maximum value is 100.
     * ```html
     * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="256">
     * ```
     */
    set maxValue(value: number);
    /**
     * Returns the lower boundary of the `IgxSliderComponent`.
     *```typescript
     *@ViewChild("slider")
     *public slider: IgxSliderComponent;
     *ngAfterViewInit(){
     *    let sliderLowBound = this.slider.lowerBound;
     *}
     *```
     */
    get lowerBound(): number;
    /**
     * Sets the lower boundary of the `IgxSliderComponent`.
     * If not set is the same as min value.
     * ```html
     * <igx-slider [step]="5" [lowerBound]="20">
     * ```
     */
    set lowerBound(value: number);
    /**
     * Returns the upper boundary of the `IgxSliderComponent`.
     * ```typescript
     *@ViewChild("slider")
     *public slider: IgxSliderComponent;
     *ngAfterViewInit(){
     *    let sliderUpBound = this.slider.upperBound;
     *}
     * ```
     */
    get upperBound(): number;
    /**
     * Sets the upper boundary of the `IgxSliderComponent`.
     * If not set is the same as max value.
     * ```html
     * <igx-slider [step]="5" [upperBound]="20">
     * ```
     */
    set upperBound(value: number);
    /**
     * Returns the slider value. If the slider is of type {@link IgxSliderType.SLIDER} the returned value is number.
     * If the slider type is {@link IgxSliderType.RANGE}.
     * The returned value represents an object of {@link lowerValue} and {@link upperValue}.
     *```typescript
     *@ViewChild("slider2")
     *public slider: IgxSliderComponent;
     *public sliderValue(event){
     *    let sliderVal = this.slider.value;
     *}
     *```
     */
    get value(): number | IRangeSliderValue;
    /**
     * Sets the slider value.
     * If the slider is of type {@link IgxSliderType.SLIDER}.
     * The argument is number. By default the {@link value} gets the {@link lowerBound}.
     * If the slider type is {@link IgxSliderType.RANGE} the argument
     * represents an object of {@link lowerValue} and {@link upperValue} properties.
     * By default the object is associated with the {@link lowerBound} and {@link upperBound} property values.
     * ```typescript
     *rangeValue = {
     *   lower: 30,
     *   upper: 60
     *};
     * ```
     * ```html
     * <igx-slider [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="56" [maxValue]="256">
     * ```
     */
    set value(value: number | IRangeSliderValue);
    /**
     * Returns the number of the presented primary ticks.
     * ```typescript
     * const primaryTicks = this.slider.primaryTicks;
     * ```
     */
    get primaryTicks(): number;
    /**
     * Sets the number of primary ticks. If {@link @labels} is enabled, this property won't function.
     * Insted enable ticks by {@link showTicks} property.
     * ```typescript
     * this.slider.primaryTicks = 5;
     * ```
     */
    set primaryTicks(val: number);
    /**
     * Returns the number of the presented secondary ticks.
     * ```typescript
     * const secondaryTicks = this.slider.secondaryTicks;
     * ```
     */
    get secondaryTicks(): number;
    /**
     * Sets the number of secondary ticks. The property functions even when {@link labels} is enabled,
     * but all secondary ticks won't present any tick labels.
     * ```typescript
     * this.slider.secondaryTicks = 5;
     * ```
     */
    set secondaryTicks(val: number);
    /**
     * Show/hide slider ticks
     * ```html
     * <igx-slier [showTicks]="true" [primaryTicks]="5"></igx-slier>
     * ```
     */
    showTicks: boolean;
    /**
     * show/hide primary tick labels
     * ```html
     * <igx-slider [primaryTicks]="5" [primaryTickLabels]="false"></igx-slider>
     * ```
     */
    primaryTickLabels: boolean;
    /**
     * show/hide secondary tick labels
     * ```html
     * <igx-slider [secondaryTicks]="5" [secondaryTickLabels]="false"></igx-slider>
     * ```
     */
    secondaryTickLabels: boolean;
    /**
     * Changes ticks orientation:
     * bottom - The default orienation, below the slider track.
     * top - Above the slider track
     * mirror - combines top and bottom orientation.
     * ```html
     * <igx-slider [primaryTicks]="5" [ticksOrientation]="ticksOrientation"></igx-slider>
     * ```
     */
    ticksOrientation: TicksOrientation;
    /**
     * Changes tick labels rotation:
     * horizontal - The default rotation
     * toptobottom - Rotates tick labels vertically to 90deg
     * bottomtotop - Rotate tick labels vertically to -90deg
     * ```html
     * <igx-slider [primaryTicks]="5" [secondaryTicks]="3" [tickLabelsOrientation]="tickLabelsOrientaiton"></igx-slider>
     * ```
     */
    tickLabelsOrientation: TickLabelsOrientation;
    /**
     * @hidden
     */
    get deactivateThumbLabel(): boolean;
    /**
     * This event is emitted every time the value is changed.
     * ```typescript
     * public change(event){
     *    alert("The value has been changed!");
     *}
     * ```
     * ```html
     * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     */
    onValueChange: EventEmitter<ISliderValueChangeEventArgs>;
    /**
     * This event is emitted at the end of every slide interaction.
     * ```typescript
     * public change(event){
     *    alert("The value has been changed!");
     *}
     * ```
     * ```html
     * <igx-slider (onValueChanged)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     */
    onValueChanged: EventEmitter<number | IRangeSliderValue>;
    constructor(renderer: Renderer2, _el: ElementRef, _cdr: ChangeDetectorRef, _ngZone: NgZone);
    /**
     * @hidden
     */
    onPointerDown($event: PointerEvent): void;
    /**
     * @hidden
     */
    onPointerUp($event: PointerEvent): void;
    /**
     * @hidden
     */
    onFocus(): void;
    /**
     * @hidden
     */
    onPanListener($event: any): void;
    /**
     *Returns whether the `IgxSliderComponent` type is RANGE.
     *```typescript
     *@ViewChild("slider")
     *public slider: IgxSliderComponent;
     *ngAfterViewInit(){
     *    let sliderRange = this.slider.isRange;
     *}
     * ```
     */
    get isRange(): boolean;
    /**
     * Returns the lower value of the `IgxSliderComponent`.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * public lowValue(event){
     *    let sliderLowValue = this.slider.lowerValue;
     *}
     *```
     */
    get lowerValue(): number;
    /**
     *Sets the lower value of the `IgxSliderComponent`.
     *```typescript
     *@ViewChild("slider2")
     *public slider: IgxSliderComponent;
     *public lowValue(event){
     *    this.slider.lowerValue = 120;
     *}
     *```
     */
    set lowerValue(value: number);
    /**
     *Returns the upper value of the `IgxSliderComponent`.
     *```typescript
     *@ViewChild("slider2")
     *public slider: IgxSliderComponent;
     *public upperValue(event){
     *    let upperValue = this.slider.upperValue;
     *}
     *```
     */
    get upperValue(): number;
    /**
     *Sets the upper value of the `IgxSliderComponent`.
     *```typescript
     *@ViewChild("slider2")
     *public slider: IgxSliderComponent;
     *public upperValue(event){
     *    this.slider.upperValue = 120;
     *}
     *```
     */
    set upperValue(value: number);
    /**
     * Returns the value corresponding the lower label.
     *```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let label = this.slider.lowerLabel;
     *```
     */
    get lowerLabel(): string | number | boolean;
    /**
     * Returns the value corresponding the upper label.
     *```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let label = this.slider.upperLabel;
     *```
     */
    get upperLabel(): string | number | boolean;
    /**
     * Returns if label view is enabled.
     * If the {@link labels} is set, the view is automatically activated.
     *```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let labelView = this.slider.labelsViewEnabled;
     *```
     */
    get labelsViewEnabled(): boolean;
    /**
     * @hidden
     */
    get showTopTicks(): boolean;
    /**
     * @hidden
     */
    get showBottomTicks(): boolean;
    /**
     * @hidden
     */
    ngOnInit(): void;
    ngOnChanges(changes: any): void;
    ngAfterContentInit(): void;
    /**
     * @hidden
     */
    ngAfterViewInit(): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    writeValue(value: IRangeSliderValue | number): void;
    /**
     * @hidden
     */
    registerOnChange(fn: any): void;
    /**
     * @hidden
     */
    registerOnTouched(fn: any): void;
    /** @hidden */
    getEditElement(): any;
    /**
     *
     * @hidden
     */
    update(mouseX: any): void;
    /**
     * @hidden
     */
    thumbChanged(value: number, thumbType: number): void;
    /**
     * @hidden
     */
    onThumbChange(): void;
    /**
     * @hidden
     */
    onHoverChange(state: boolean): void;
    private swapThumb;
    private findClosestThumb;
    private updateLowerBoundAndMinTravelZone;
    private updateUpperBoundAndMaxTravelZone;
    private sliderSetup;
    private calculateStepDistance;
    private toggleThumb;
    private valueInRange;
    private generateTickMarks;
    private positionHandler;
    private positionHandlersAndUpdateTrack;
    private closestHandle;
    private setTickInterval;
    private showSliderIndicators;
    private hideSliderIndicators;
    private toggleSliderIndicators;
    private changeThumbFocusableState;
    private closestTo;
    private valueToFraction;
    /**
     * @hidden
     * Normalizе the value when two-way data bind is used and {@link this.step} is set.
     * @param value
     */
    private normalizeByStep;
    private updateTrack;
    private validateInitialValue;
    private subscribeTo;
    private unsubscriber;
    private hasValueChanged;
    setValue(value: number | IRangeSliderValue): void;
    private emitValueChanged;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxSliderComponent>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<IgxSliderComponent, "igx-slider", never, {
    "id": "id";
    "thumbLabelVisibilityDuration": "thumbLabelVisibilityDuration";
    "showTicks": "showTicks";
    "primaryTickLabels": "primaryTickLabels";
    "secondaryTickLabels": "secondaryTickLabels";
    "ticksOrientation": "ticksOrientation";
    "tickLabelsOrientation": "tickLabelsOrientation";
    "type": "type";
    "labels": "labels";
    "step": "step";
    "disabled": "disabled";
    "continuous": "continuous";
    "minValue": "minValue";
    "lowerBound": "lowerBound";
    "maxValue": "maxValue";
    "upperBound": "upperBound";
    "value": "value";
    "primaryTicks": "primaryTicks";
    "secondaryTicks": "secondaryTicks";
}, {
    "onValueChange": "onValueChange";
    "onValueChanged": "onValueChanged";
}, ["thumbFromTemplateRef", "thumbToTemplateRef", "tickLabelTemplateRef"]>;
}
/**
 * @hidden
 */
export declare class IgxSliderModule {
    static ɵmod: ɵngcc0.ɵɵNgModuleDefWithMeta<IgxSliderModule, [typeof IgxSliderComponent, typeof ɵngcc1.IgxThumbFromTemplateDirective, typeof ɵngcc1.IgxThumbToTemplateDirective, typeof ɵngcc1.IgxTickLabelTemplateDirective, typeof ɵngcc2.IgxSliderThumbComponent, typeof ɵngcc3.IgxThumbLabelComponent, typeof ɵngcc4.IgxTicksComponent, typeof ɵngcc5.IgxTickLabelsPipe], [typeof ɵngcc6.CommonModule, typeof ɵngcc7.FormsModule], [typeof IgxSliderComponent, typeof ɵngcc1.IgxThumbFromTemplateDirective, typeof ɵngcc1.IgxThumbToTemplateDirective, typeof ɵngcc1.IgxTickLabelTemplateDirective, typeof ɵngcc2.IgxSliderThumbComponent, typeof ɵngcc3.IgxThumbLabelComponent, typeof ɵngcc4.IgxTicksComponent]>;
    static ɵinj: ɵngcc0.ɵɵInjectorDef<IgxSliderModule>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJzbGlkZXIuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9sQkE7Ozs7Ozs7QUFLQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFmdGVyVmlld0luaXQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgT25Jbml0LCBSZW5kZXJlcjIsIFRlbXBsYXRlUmVmLCBPbkRlc3Ryb3ksIENoYW5nZURldGVjdG9yUmVmLCBPbkNoYW5nZXMsIE5nWm9uZSwgQWZ0ZXJDb250ZW50SW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBFZGl0b3JQcm92aWRlciB9IGZyb20gJy4uL2NvcmUvZWRpdC1wcm92aWRlcic7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBJUmFuZ2VTbGlkZXJWYWx1ZSwgSWd4U2xpZGVyVHlwZSwgSVNsaWRlclZhbHVlQ2hhbmdlRXZlbnRBcmdzLCBUaWNrc09yaWVudGF0aW9uLCBUaWNrTGFiZWxzT3JpZW50YXRpb24gfSBmcm9tICcuL3NsaWRlci5jb21tb24nO1xuLyoqXG4gKiAqKklnbml0ZSBVSSBmb3IgQW5ndWxhciBTbGlkZXIqKiAtXG4gKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cuaW5mcmFnaXN0aWNzLmNvbS9wcm9kdWN0cy9pZ25pdGUtdWktYW5ndWxhci9hbmd1bGFyL2NvbXBvbmVudHMvc2xpZGVyLmh0bWwpXG4gKlxuICogVGhlIElnbml0ZSBVSSBTbGlkZXIgYWxsb3dzIHNlbGVjdGlvbiBpbiBhIGdpdmVuIHJhbmdlIGJ5IG1vdmluZyB0aGUgdGh1bWIgYWxvbmcgdGhlIHRyYWNrLiBUaGUgdHJhY2tcbiAqIGNhbiBiZSBkZWZpbmVkIGFzIGNvbnRpbnVvdXMgb3Igc3RlcHBlZCwgYW5kIHlvdSBjYW4gY2hvb3NlIGJldHdlZW4gc2luZ2xlIGFuZCByYW5nZSBzbGlkZXIgdHlwZXMuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxpZ3gtc2xpZGVyIGlkPVwic2xpZGVyXCJcbiAqICAgICAgICAgICAgW21pblZhbHVlXT1cIjBcIiBbbWF4VmFsdWVdPVwiMTAwXCJcbiAqICAgICAgICAgICAgW2NvbnRpbnVvdXNdPXRydWUgWyhuZ01vZGVsKV09XCJ2b2x1bWVcIj5cbiAqIDwvaWd4LXNsaWRlcj5cbiAqIGBgYFxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBJZ3hTbGlkZXJDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgRWRpdG9yUHJvdmlkZXIsIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgQWZ0ZXJDb250ZW50SW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgcmVuZGVyZXI7XG4gICAgcHJpdmF0ZSBfZWw7XG4gICAgcHJpdmF0ZSBfY2RyO1xuICAgIHByaXZhdGUgX25nWm9uZTtcbiAgICBwcml2YXRlIF9wTWluO1xuICAgIHByaXZhdGUgX3BNYXg7XG4gICAgcHJpdmF0ZSBfaGFzVmlld0luaXQ7XG4gICAgcHJpdmF0ZSBfbWluVmFsdWU7XG4gICAgcHJpdmF0ZSBfbWF4VmFsdWU7XG4gICAgcHJpdmF0ZSBfbG93ZXJCb3VuZD87XG4gICAgcHJpdmF0ZSBfdXBwZXJCb3VuZD87XG4gICAgcHJpdmF0ZSBfbG93ZXJWYWx1ZT87XG4gICAgcHJpdmF0ZSBfdXBwZXJWYWx1ZT87XG4gICAgcHJpdmF0ZSBfY29udGludW91cztcbiAgICBwcml2YXRlIF9kaXNhYmxlZDtcbiAgICBwcml2YXRlIF9zdGVwO1xuICAgIHByaXZhdGUgX3ZhbHVlO1xuICAgIHByaXZhdGUgX3ByaW1hcnlUaWNrcztcbiAgICBwcml2YXRlIF9zZWNvbmRhcnlUaWNrcztcbiAgICBwcml2YXRlIF9sYWJlbHM7XG4gICAgcHJpdmF0ZSBfdHlwZTtcbiAgICBwcml2YXRlIF9kZXN0cm95ZXIkO1xuICAgIHByaXZhdGUgX2luZGljYXRvcnNEZXN0cm95ZXIkO1xuICAgIHByaXZhdGUgX2luZGljYXRvcnNUaW1lcjtcbiAgICBwcml2YXRlIF9vbkNoYW5nZUNhbGxiYWNrO1xuICAgIHByaXZhdGUgX29uVG91Y2hlZENhbGxiYWNrO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcml2YXRlIHRpY2tzO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcml2YXRlIHRodW1icztcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBsYWJlbFJlZnM7XG4gICAgcHJpdmF0ZSBnZXQgdGh1bWJGcm9tKCk7XG4gICAgcHJpdmF0ZSBnZXQgdGh1bWJUbygpO1xuICAgIHByaXZhdGUgZ2V0IGxhYmVsRnJvbSgpO1xuICAgIHByaXZhdGUgZ2V0IGxhYmVsVG8oKTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdHJhY2tSZWY6IEVsZW1lbnRSZWY7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHN0ZXBEaXN0YW5jZTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvblBhbjogU3ViamVjdDxudW1iZXI+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB0aHVtYkZyb21UZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdGh1bWJUb1RlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICB0aWNrTGFiZWxUZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcm9sZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWVtaW4oKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWVtYXgoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgcmVhZG9ubHkoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2xpZXJDbGFzczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVkQ2xhc3MoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYGlkYCBhdHRyaWJ1dGUuXG4gICAgICogSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIFtpZF09XCInaWd4LXNsaWRlci0zMidcIiBbKG5nTW9kZWwpXT1cInRhc2sucGVyY2VudENvbXBsZXRlZFwiIFtzdGVwXT1cIjVcIiBbbG93ZXJCb3VuZF09XCIyMFwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGlkOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgZ2V0cyB0aGUgdHlwZSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICogVGhlIHNsaWRlciBjYW4gYmUgSWd4U2xpZGVyVHlwZS5TTElERVIoZGVmYXVsdCkgb3IgSWd4U2xpZGVyVHlwZS5SQU5HRS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKiBwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICogbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgIGxldCB0eXBlID0gdGhpcy5zbGlkZXIudHlwZTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgZ2V0IHR5cGUoKTogSWd4U2xpZGVyVHlwZTtcbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB0eXBlIG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKiBUaGUgc2xpZGVyIGNhbiBiZSBJZ3hTbGlkZXJUeXBlLlNMSURFUihkZWZhdWx0KSBvciBJZ3hTbGlkZXJUeXBlLlJBTkdFLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBzbGlkZXJUeXBlOiBJZ3hTbGlkZXJUeXBlID0gSWd4U2xpZGVyVHlwZS5SQU5HRTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgI3NsaWRlcjIgW3R5cGVdPVwic2xpZGVyVHlwZVwiIFsobmdNb2RlbCldPVwicmFuZ2VWYWx1ZVwiIFttaW5WYWx1ZV09XCIwXCIgW21heFZhbHVlXT1cIjEwMFwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldCB0eXBlKHR5cGU6IElneFNsaWRlclR5cGUpO1xuICAgIC8qKlxuICAgICAqQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgZHVyYXRpb24gdmlzaWJpbGl0eSBvZiB0aHVtYnMgbGFiZWxzLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA3NTAgbWlsbGlzZWNvbmRzLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1zbGlkZXIgI3NsaWRlciBbdGh1bWJMYWJlbFZpc2liaWxpdHlEdXJhdGlvbl09XCIzMDAwXCIgWyhuZ01vZGVsKV09XCJ0YXNrLnBlcmNlbnRDb21wbGV0ZWRcIiBbc3RlcF09XCI1XCI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICB0aHVtYkxhYmVsVmlzaWJpbGl0eUR1cmF0aW9uOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBgbGFiZWxWaWV3YCwgYnkgYWNjZXB0aW5nIGEgY29sbGVjdGlvbiBvZiBwcmltaXRpdmUgdmFsdWVzIHdpdGggbW9yZSB0aGFuIG9uZSBlbGVtZW50LlxuICAgICAqIEVhY2ggZWxlbWVudCB3aWxsIGJlIGVxdWFsbHkgc3ByZWFkIG92ZXIgdGhlIHNsaWRlciBhbmQgaXQgd2lsbCBzZXJ2ZSBhcyBhIHRodW1iIGxhYmVsLlxuICAgICAqIE9uY2UgdGhlIHByb3BlcnR5IGlzIHNldCwgaXQgd2lsbCBwcmVjZW5kZW5jZSBvdmVyIHtAbGluayBtYXhWYWx1ZX0sIHtAbGluayBtaW5WYWx1ZX0sIHtAbGluayBzdGVwfS5cbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgdGhlIG1hbmlwdWxhdGlvbiBmb3IgdGhvc2UgcHJvcGVydGllcyB3b24ndCBiZSBhbGxvd2VkLlxuICAgICAqL1xuICAgIGdldCBsYWJlbHMoKTogQXJyYXk8bnVtYmVyIHwgc3RyaW5nIHwgYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQ+O1xuICAgIHNldCBsYWJlbHMobGFiZWxzOiBBcnJheTxudW1iZXIgfCBzdHJpbmcgfCBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZD4pO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIGNvbnRleHQgY29ycmVzcG9uZGluZ1xuICAgICAqIHRvIHtAbGluayBJZ3hUaHVtYkZyb21UZW1wbGF0ZURpcmVjdGl2ZX0gYW5kIHtAbGluayBJZ3hUaHVtYlRvVGVtcGxhdGVEaXJlY3RpdmV9IHRlbXBsYXRlcy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiByZXR1cm4ge1xuICAgICAqICAkaW1wbGljaXQgLy8gcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGxhYmVsLFxuICAgICAqICBsYWJlbHMgLy8gcmV0dXJucyB0aGUgbGFiZWxzIGNvbGxlY3Rpb24gdGhlIHVzZXIgaGFzIHBhc3NlZC5cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGNvbnRleHQoKTogYW55O1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGluY3JlbWVudGFsL2RlY3JlbWVudGFsIHN0ZXAgb2YgdGhlIHZhbHVlIHdoZW4gZHJhZ2dpbmcgdGhlIHRodW1iLlxuICAgICAqIFRoZSBkZWZhdWx0IHN0ZXAgaXMgMSwgYW5kIHN0ZXAgc2hvdWxkIG5vdCBiZSBsZXNzIG9yIGVxdWFsIHRoYW4gMC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgI3NsaWRlciBbKG5nTW9kZWwpXT1cInRhc2sucGVyY2VudENvbXBsZXRlZFwiIFtzdGVwXT1cIjVcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXQgc3RlcChzdGVwOiBudW1iZXIpO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluY3JlbWVudGFsL2RlY3JlbWVudGFsIGRyYWdnaW5nIHN0ZXAgb2YgdGhlIHtAbGluayBJZ3hTbGlkZXJDb21wb25lbnR9LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwic2xpZGVyMlwiKVxuICAgICAqIHB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKiBuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICAgbGV0IHN0ZXAgPSB0aGlzLnNsaWRlci5zdGVwO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgc3RlcCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUge0BsaW5rIElneFNsaWRlckNvbXBvbmVudH0gaXMgZGlzYWJsZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJzbGlkZXIyXCIpXG4gICAgICogcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqIG5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgICBsZXQgaXNEaXNhYmxlZCA9IHRoaXMuc2xpZGVyLmRpc2FibGVkO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKkFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IGRpc2FibGVzIG9yIGVuYWJsZXMgVUkgaW50ZXJhY3Rpb24uXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LXNsaWRlciAjc2xpZGVyIFtkaXNhYmxlZF09XCIndHJ1ZSdcIiBbKG5nTW9kZWwpXT1cInRhc2sucGVyY2VudENvbXBsZXRlZFwiIFtzdGVwXT1cIjVcIiBbbG93ZXJCb3VuZF09XCIyMFwiPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgc2V0IGRpc2FibGVkKGRpc2FibGU6IGJvb2xlYW4pO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIHtAbGluayBJZ3hTbGlkZXJDb21wb25lbnR9IGlzIHNldCBhcyBjb250aW51b3VzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwic2xpZGVyMlwiKVxuICAgICAqIHB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKiBuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICAgbGV0IGNvbnRpbnVvdXMgPSB0aGlzLnNsaWRlci5jb250aW51b3VzO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgY29udGludW91cygpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IG1hcmtzIHRoZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fSBhcyBjb250aW51b3VzLlxuICAgICAqIEJ5IGRlZmF1bHQgaXMgY29uc2lkZXJlZCB0aGF0IHRoZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fSBpcyBkaXNjcmV0ZS5cbiAgICAgKiBEaXNjcmV0ZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fSBkb2VzIG5vdCBoYXZlIHRpY2tzIGFuZCBkb2VzIG5vdCBzaG93IGJ1YmJsZSBsYWJlbHMgZm9yIHZhbHVlcy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgI3NsaWRlciBbY29udGludW91c109XCIndHJ1ZSdcIiBbKG5nTW9kZWwpXT1cInRhc2sucGVyY2VudENvbXBsZXRlZFwiIFtzdGVwXT1cIjVcIiBbbG93ZXJCb3VuZF09XCIyMFwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldCBjb250aW51b3VzKGNvbnRpbnVvdXM6IGJvb2xlYW4pO1xuICAgIC8qKlxuICAgICAqUmV0dXJucyB0aGUgbWluaW1hbCB2YWx1ZSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwic2xpZGVyMlwiKVxuICAgICAqcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgbGV0IHNsaWRlck1pbiA9IHRoaXMuc2xpZGVyLm1pblZhbHVlO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IG1pblZhbHVlKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtaW5pbWFsIHZhbHVlIGZvciB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICogVGhlIGRlZmF1bHQgbWluaW1hbCB2YWx1ZSBpcyAwLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciBbdHlwZV09XCJzbGlkZXJUeXBlXCIgW21pblZhbHVlXT1cIjU2XCIgW21heFZhbHVlXT1cIjEwMFwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldCBtaW5WYWx1ZSh2YWx1ZTogbnVtYmVyKTtcbiAgICAvKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUgZm9yIHRoZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fS5cbiAqIGBgYHR5cGVzY3JpcHRcbiAqQFZpZXdDaGlsZChcInNsaWRlclwiKVxuICpwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gKm5nQWZ0ZXJWaWV3SW5pdCgpe1xuICogICAgbGV0IHNsaWRlck1heCA9IHRoaXMuc2xpZGVyLm1heFZhbHVlO1xuICp9XG4gKiBgYGBcbiAqL1xuICAgIGdldCBtYXhWYWx1ZSgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWF4aW1hbCB2YWx1ZSBmb3IgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqIFRoZSBkZWZhdWx0IG1heGltdW0gdmFsdWUgaXMgMTAwLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciBbdHlwZV09XCJzbGlkZXJUeXBlXCIgW21pblZhbHVlXT1cIjU2XCIgW21heFZhbHVlXT1cIjI1NlwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldCBtYXhWYWx1ZSh2YWx1ZTogbnVtYmVyKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwic2xpZGVyXCIpXG4gICAgICpwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICpuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICBsZXQgc2xpZGVyTG93Qm91bmQgPSB0aGlzLnNsaWRlci5sb3dlckJvdW5kO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IGxvd2VyQm91bmQoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxvd2VyIGJvdW5kYXJ5IG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKiBJZiBub3Qgc2V0IGlzIHRoZSBzYW1lIGFzIG1pbiB2YWx1ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgW3N0ZXBdPVwiNVwiIFtsb3dlckJvdW5kXT1cIjIwXCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2V0IGxvd2VyQm91bmQodmFsdWU6IG51bWJlcik7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKm5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgIGxldCBzbGlkZXJVcEJvdW5kID0gdGhpcy5zbGlkZXIudXBwZXJCb3VuZDtcbiAgICAgKn1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgdXBwZXJCb3VuZCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqIElmIG5vdCBzZXQgaXMgdGhlIHNhbWUgYXMgbWF4IHZhbHVlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciBbc3RlcF09XCI1XCIgW3VwcGVyQm91bmRdPVwiMjBcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXQgdXBwZXJCb3VuZCh2YWx1ZTogbnVtYmVyKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzbGlkZXIgdmFsdWUuIElmIHRoZSBzbGlkZXIgaXMgb2YgdHlwZSB7QGxpbmsgSWd4U2xpZGVyVHlwZS5TTElERVJ9IHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBudW1iZXIuXG4gICAgICogSWYgdGhlIHNsaWRlciB0eXBlIGlzIHtAbGluayBJZ3hTbGlkZXJUeXBlLlJBTkdFfS5cbiAgICAgKiBUaGUgcmV0dXJuZWQgdmFsdWUgcmVwcmVzZW50cyBhbiBvYmplY3Qgb2Yge0BsaW5rIGxvd2VyVmFsdWV9IGFuZCB7QGxpbmsgdXBwZXJWYWx1ZX0uXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwic2xpZGVyMlwiKVxuICAgICAqcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqcHVibGljIHNsaWRlclZhbHVlKGV2ZW50KXtcbiAgICAgKiAgICBsZXQgc2xpZGVyVmFsID0gdGhpcy5zbGlkZXIudmFsdWU7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKTogbnVtYmVyIHwgSVJhbmdlU2xpZGVyVmFsdWU7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2xpZGVyIHZhbHVlLlxuICAgICAqIElmIHRoZSBzbGlkZXIgaXMgb2YgdHlwZSB7QGxpbmsgSWd4U2xpZGVyVHlwZS5TTElERVJ9LlxuICAgICAqIFRoZSBhcmd1bWVudCBpcyBudW1iZXIuIEJ5IGRlZmF1bHQgdGhlIHtAbGluayB2YWx1ZX0gZ2V0cyB0aGUge0BsaW5rIGxvd2VyQm91bmR9LlxuICAgICAqIElmIHRoZSBzbGlkZXIgdHlwZSBpcyB7QGxpbmsgSWd4U2xpZGVyVHlwZS5SQU5HRX0gdGhlIGFyZ3VtZW50XG4gICAgICogcmVwcmVzZW50cyBhbiBvYmplY3Qgb2Yge0BsaW5rIGxvd2VyVmFsdWV9IGFuZCB7QGxpbmsgdXBwZXJWYWx1ZX0gcHJvcGVydGllcy5cbiAgICAgKiBCeSBkZWZhdWx0IHRoZSBvYmplY3QgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSB7QGxpbmsgbG93ZXJCb3VuZH0gYW5kIHtAbGluayB1cHBlckJvdW5kfSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqcmFuZ2VWYWx1ZSA9IHtcbiAgICAgKiAgIGxvd2VyOiAzMCxcbiAgICAgKiAgIHVwcGVyOiA2MFxuICAgICAqfTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgW3R5cGVdPVwic2xpZGVyVHlwZVwiIFsobmdNb2RlbCldPVwicmFuZ2VWYWx1ZVwiIFttaW5WYWx1ZV09XCI1NlwiIFttYXhWYWx1ZV09XCIyNTZcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodmFsdWU6IG51bWJlciB8IElSYW5nZVNsaWRlclZhbHVlKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGhlIHByZXNlbnRlZCBwcmltYXJ5IHRpY2tzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBwcmltYXJ5VGlja3MgPSB0aGlzLnNsaWRlci5wcmltYXJ5VGlja3M7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHByaW1hcnlUaWNrcygpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbnVtYmVyIG9mIHByaW1hcnkgdGlja3MuIElmIHtAbGluayBAbGFiZWxzfSBpcyBlbmFibGVkLCB0aGlzIHByb3BlcnR5IHdvbid0IGZ1bmN0aW9uLlxuICAgICAqIEluc3RlZCBlbmFibGUgdGlja3MgYnkge0BsaW5rIHNob3dUaWNrc30gcHJvcGVydHkuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuc2xpZGVyLnByaW1hcnlUaWNrcyA9IDU7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2V0IHByaW1hcnlUaWNrcyh2YWw6IG51bWJlcik7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRoZSBwcmVzZW50ZWQgc2Vjb25kYXJ5IHRpY2tzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBzZWNvbmRhcnlUaWNrcyA9IHRoaXMuc2xpZGVyLnNlY29uZGFyeVRpY2tzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBzZWNvbmRhcnlUaWNrcygpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbnVtYmVyIG9mIHNlY29uZGFyeSB0aWNrcy4gVGhlIHByb3BlcnR5IGZ1bmN0aW9ucyBldmVuIHdoZW4ge0BsaW5rIGxhYmVsc30gaXMgZW5hYmxlZCxcbiAgICAgKiBidXQgYWxsIHNlY29uZGFyeSB0aWNrcyB3b24ndCBwcmVzZW50IGFueSB0aWNrIGxhYmVscy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5zbGlkZXIuc2Vjb25kYXJ5VGlja3MgPSA1O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldCBzZWNvbmRhcnlUaWNrcyh2YWw6IG51bWJlcik7XG4gICAgLyoqXG4gICAgICogU2hvdy9oaWRlIHNsaWRlciB0aWNrc1xuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWVyIFtzaG93VGlja3NdPVwidHJ1ZVwiIFtwcmltYXJ5VGlja3NdPVwiNVwiPjwvaWd4LXNsaWVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNob3dUaWNrczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBzaG93L2hpZGUgcHJpbWFyeSB0aWNrIGxhYmVsc1xuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciBbcHJpbWFyeVRpY2tzXT1cIjVcIiBbcHJpbWFyeVRpY2tMYWJlbHNdPVwiZmFsc2VcIj48L2lneC1zbGlkZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHJpbWFyeVRpY2tMYWJlbHM6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogc2hvdy9oaWRlIHNlY29uZGFyeSB0aWNrIGxhYmVsc1xuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciBbc2Vjb25kYXJ5VGlja3NdPVwiNVwiIFtzZWNvbmRhcnlUaWNrTGFiZWxzXT1cImZhbHNlXCI+PC9pZ3gtc2xpZGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNlY29uZGFyeVRpY2tMYWJlbHM6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aWNrcyBvcmllbnRhdGlvbjpcbiAgICAgKiBib3R0b20gLSBUaGUgZGVmYXVsdCBvcmllbmF0aW9uLCBiZWxvdyB0aGUgc2xpZGVyIHRyYWNrLlxuICAgICAqIHRvcCAtIEFib3ZlIHRoZSBzbGlkZXIgdHJhY2tcbiAgICAgKiBtaXJyb3IgLSBjb21iaW5lcyB0b3AgYW5kIGJvdHRvbSBvcmllbnRhdGlvbi5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgW3ByaW1hcnlUaWNrc109XCI1XCIgW3RpY2tzT3JpZW50YXRpb25dPVwidGlja3NPcmllbnRhdGlvblwiPjwvaWd4LXNsaWRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB0aWNrc09yaWVudGF0aW9uOiBUaWNrc09yaWVudGF0aW9uO1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGljayBsYWJlbHMgcm90YXRpb246XG4gICAgICogaG9yaXpvbnRhbCAtIFRoZSBkZWZhdWx0IHJvdGF0aW9uXG4gICAgICogdG9wdG9ib3R0b20gLSBSb3RhdGVzIHRpY2sgbGFiZWxzIHZlcnRpY2FsbHkgdG8gOTBkZWdcbiAgICAgKiBib3R0b210b3RvcCAtIFJvdGF0ZSB0aWNrIGxhYmVscyB2ZXJ0aWNhbGx5IHRvIC05MGRlZ1xuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciBbcHJpbWFyeVRpY2tzXT1cIjVcIiBbc2Vjb25kYXJ5VGlja3NdPVwiM1wiIFt0aWNrTGFiZWxzT3JpZW50YXRpb25dPVwidGlja0xhYmVsc09yaWVudGFpdG9uXCI+PC9pZ3gtc2xpZGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHRpY2tMYWJlbHNPcmllbnRhdGlvbjogVGlja0xhYmVsc09yaWVudGF0aW9uO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZGVhY3RpdmF0ZVRodW1iTGFiZWwoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgZXZlcnkgdGltZSB0aGUgdmFsdWUgaXMgY2hhbmdlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGNoYW5nZShldmVudCl7XG4gICAgICogICAgYWxlcnQoXCJUaGUgdmFsdWUgaGFzIGJlZW4gY2hhbmdlZCFcIik7XG4gICAgICp9XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIChvblZhbHVlQ2hhbmdlKT1cImNoYW5nZSgkZXZlbnQpXCIgI3NsaWRlciBbKG5nTW9kZWwpXT1cInRhc2sucGVyY2VudENvbXBsZXRlZFwiIFtzdGVwXT1cIjVcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBvblZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8SVNsaWRlclZhbHVlQ2hhbmdlRXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgYXQgdGhlIGVuZCBvZiBldmVyeSBzbGlkZSBpbnRlcmFjdGlvbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGNoYW5nZShldmVudCl7XG4gICAgICogICAgYWxlcnQoXCJUaGUgdmFsdWUgaGFzIGJlZW4gY2hhbmdlZCFcIik7XG4gICAgICp9XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIChvblZhbHVlQ2hhbmdlZCk9XCJjaGFuZ2UoJGV2ZW50KVwiICNzbGlkZXIgWyhuZ01vZGVsKV09XCJ0YXNrLnBlcmNlbnRDb21wbGV0ZWRcIiBbc3RlcF09XCI1XCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25WYWx1ZUNoYW5nZWQ6IEV2ZW50RW1pdHRlcjxudW1iZXIgfCBJUmFuZ2VTbGlkZXJWYWx1ZT47XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXI6IFJlbmRlcmVyMiwgX2VsOiBFbGVtZW50UmVmLCBfY2RyOiBDaGFuZ2VEZXRlY3RvclJlZiwgX25nWm9uZTogTmdab25lKTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25Qb2ludGVyRG93bigkZXZlbnQ6IFBvaW50ZXJFdmVudCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uUG9pbnRlclVwKCRldmVudDogUG9pbnRlckV2ZW50KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25Gb2N1cygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvblBhbkxpc3RlbmVyKCRldmVudDogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKlJldHVybnMgd2hldGhlciB0aGUgYElneFNsaWRlckNvbXBvbmVudGAgdHlwZSBpcyBSQU5HRS5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKm5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgIGxldCBzbGlkZXJSYW5nZSA9IHRoaXMuc2xpZGVyLmlzUmFuZ2U7XG4gICAgICp9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGlzUmFuZ2UoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsb3dlciB2YWx1ZSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAgICAgKiBwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICogcHVibGljIGxvd1ZhbHVlKGV2ZW50KXtcbiAgICAgKiAgICBsZXQgc2xpZGVyTG93VmFsdWUgPSB0aGlzLnNsaWRlci5sb3dlclZhbHVlO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgZ2V0IGxvd2VyVmFsdWUoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqU2V0cyB0aGUgbG93ZXIgdmFsdWUgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyBsb3dWYWx1ZShldmVudCl7XG4gICAgICogICAgdGhpcy5zbGlkZXIubG93ZXJWYWx1ZSA9IDEyMDtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHNldCBsb3dlclZhbHVlKHZhbHVlOiBudW1iZXIpO1xuICAgIC8qKlxuICAgICAqUmV0dXJucyB0aGUgdXBwZXIgdmFsdWUgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyB1cHBlclZhbHVlKGV2ZW50KXtcbiAgICAgKiAgICBsZXQgdXBwZXJWYWx1ZSA9IHRoaXMuc2xpZGVyLnVwcGVyVmFsdWU7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXQgdXBwZXJWYWx1ZSgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICpTZXRzIHRoZSB1cHBlciB2YWx1ZSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwic2xpZGVyMlwiKVxuICAgICAqcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqcHVibGljIHVwcGVyVmFsdWUoZXZlbnQpe1xuICAgICAqICAgIHRoaXMuc2xpZGVyLnVwcGVyVmFsdWUgPSAxMjA7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzZXQgdXBwZXJWYWx1ZSh2YWx1ZTogbnVtYmVyKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBjb3JyZXNwb25kaW5nIHRoZSBsb3dlciBsYWJlbC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwic2xpZGVyXCIpXG4gICAgICogcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqIGxldCBsYWJlbCA9IHRoaXMuc2xpZGVyLmxvd2VyTGFiZWw7XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXQgbG93ZXJMYWJlbCgpOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGNvcnJlc3BvbmRpbmcgdGhlIHVwcGVyIGxhYmVsLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAgICAgKiBwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICogbGV0IGxhYmVsID0gdGhpcy5zbGlkZXIudXBwZXJMYWJlbDtcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldCB1cHBlckxhYmVsKCk6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiBsYWJlbCB2aWV3IGlzIGVuYWJsZWQuXG4gICAgICogSWYgdGhlIHtAbGluayBsYWJlbHN9IGlzIHNldCwgdGhlIHZpZXcgaXMgYXV0b21hdGljYWxseSBhY3RpdmF0ZWQuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcInNsaWRlclwiKVxuICAgICAqIHB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKiBsZXQgbGFiZWxWaWV3ID0gdGhpcy5zbGlkZXIubGFiZWxzVmlld0VuYWJsZWQ7XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXQgbGFiZWxzVmlld0VuYWJsZWQoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHNob3dUb3BUaWNrcygpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgc2hvd0JvdHRvbVRpY2tzKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogYW55KTogdm9pZDtcbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IElSYW5nZVNsaWRlclZhbHVlIHwgbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQ7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBnZXRFZGl0RWxlbWVudCgpOiBhbnk7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdXBkYXRlKG1vdXNlWDogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdGh1bWJDaGFuZ2VkKHZhbHVlOiBudW1iZXIsIHRodW1iVHlwZTogbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25UaHVtYkNoYW5nZSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkhvdmVyQ2hhbmdlKHN0YXRlOiBib29sZWFuKTogdm9pZDtcbiAgICBwcml2YXRlIHN3YXBUaHVtYjtcbiAgICBwcml2YXRlIGZpbmRDbG9zZXN0VGh1bWI7XG4gICAgcHJpdmF0ZSB1cGRhdGVMb3dlckJvdW5kQW5kTWluVHJhdmVsWm9uZTtcbiAgICBwcml2YXRlIHVwZGF0ZVVwcGVyQm91bmRBbmRNYXhUcmF2ZWxab25lO1xuICAgIHByaXZhdGUgc2xpZGVyU2V0dXA7XG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVTdGVwRGlzdGFuY2U7XG4gICAgcHJpdmF0ZSB0b2dnbGVUaHVtYjtcbiAgICBwcml2YXRlIHZhbHVlSW5SYW5nZTtcbiAgICBwcml2YXRlIGdlbmVyYXRlVGlja01hcmtzO1xuICAgIHByaXZhdGUgcG9zaXRpb25IYW5kbGVyO1xuICAgIHByaXZhdGUgcG9zaXRpb25IYW5kbGVyc0FuZFVwZGF0ZVRyYWNrO1xuICAgIHByaXZhdGUgY2xvc2VzdEhhbmRsZTtcbiAgICBwcml2YXRlIHNldFRpY2tJbnRlcnZhbDtcbiAgICBwcml2YXRlIHNob3dTbGlkZXJJbmRpY2F0b3JzO1xuICAgIHByaXZhdGUgaGlkZVNsaWRlckluZGljYXRvcnM7XG4gICAgcHJpdmF0ZSB0b2dnbGVTbGlkZXJJbmRpY2F0b3JzO1xuICAgIHByaXZhdGUgY2hhbmdlVGh1bWJGb2N1c2FibGVTdGF0ZTtcbiAgICBwcml2YXRlIGNsb3Nlc3RUbztcbiAgICBwcml2YXRlIHZhbHVlVG9GcmFjdGlvbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogTm9ybWFsaXrQtSB0aGUgdmFsdWUgd2hlbiB0d28td2F5IGRhdGEgYmluZCBpcyB1c2VkIGFuZCB7QGxpbmsgdGhpcy5zdGVwfSBpcyBzZXQuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgcHJpdmF0ZSBub3JtYWxpemVCeVN0ZXA7XG4gICAgcHJpdmF0ZSB1cGRhdGVUcmFjaztcbiAgICBwcml2YXRlIHZhbGlkYXRlSW5pdGlhbFZhbHVlO1xuICAgIHByaXZhdGUgc3Vic2NyaWJlVG87XG4gICAgcHJpdmF0ZSB1bnN1YnNjcmliZXI7XG4gICAgcHJpdmF0ZSBoYXNWYWx1ZUNoYW5nZWQ7XG4gICAgc2V0VmFsdWUodmFsdWU6IG51bWJlciB8IElSYW5nZVNsaWRlclZhbHVlKTogdm9pZDtcbiAgICBwcml2YXRlIGVtaXRWYWx1ZUNoYW5nZWQ7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4U2xpZGVyTW9kdWxlIHtcbn1cbiJdfQ==