import { EventEmitter } from '@angular/core';
import { WEEKDAYS, Calendar, IFormattingOptions, IFormattingViews } from './calendar';
import { ControlValueAccessor } from '@angular/forms';
import { DateRangeDescriptor } from '../core/dates';
import { Subject } from 'rxjs';
/**
 * Sets the selction type - single, multi or range.
 */
import * as ɵngcc0 from '@angular/core';
export declare enum CalendarSelection {
    SINGLE = "single",
    MULTI = "multi",
    RANGE = "range"
}
export declare enum ScrollMonth {
    PREV = "prev",
    NEXT = "next",
    NONE = "none"
}
/** @hidden @internal */
export declare class IgxCalendarBaseDirective implements ControlValueAccessor {
    /**
     * Gets the start day of the week.
     * Can return a numeric or an enum representation of the week day.
     * Defaults to `Sunday` / `0`.
     */
    get weekStart(): WEEKDAYS | number;
    /**
     * Sets the start day of the week.
     * Can be assigned to a numeric value or to `WEEKDAYS` enum value.
     */
    set weekStart(value: WEEKDAYS | number);
    /**
     * Gets the `locale` of the calendar.
     * Default value is `"en"`.
     */
    get locale(): string;
    /**
     * Sets the `locale` of the calendar.
     * Expects a valid BCP 47 language tag.
     * Default value is `"en"`.
     */
    set locale(value: string);
    /**
     * Gets the date format options of the days view.
     */
    get formatOptions(): IFormattingOptions;
    /**
     * Sets the date format options of the days view.
     * Default is { day: 'numeric', month: 'short', weekday: 'short', year: 'numeric' }
     */
    set formatOptions(formatOptions: IFormattingOptions);
    /**
     * Gets whether the `day`, `month` and `year` should be rendered
     * according to the locale and formatOptions, if any.
     */
    get formatViews(): IFormattingViews;
    /**
     * Gets whether the `day`, `month` and `year` should be rendered
     * according to the locale and formatOptions, if any.
     */
    set formatViews(formatViews: IFormattingViews);
    /**
     *
     * Gets the selection type.
     * Default value is `"single"`.
     * Changing the type of selection resets the currently
     * selected values if any.
     */
    get selection(): string;
    /**
     * Sets the selection.
     */
    set selection(value: string);
    /**
     * Gets the selected date(s).
     *
     * When selection is set to `single`, it returns
     * a single `Date` object.
     * Otherwise it is an array of `Date` objects.
     */
    get value(): Date | Date[];
    /**
     * Sets the selected date(s).
     *
     * When selection is set to `single`, it accepts
     * a single `Date` object.
     * Otherwise it is an array of `Date` objects.
     */
    set value(value: Date | Date[]);
    /**
     * Gets the date that is presented.
     * By default it is the current date.
     */
    get viewDate(): Date;
    /**
     * Sets the date that will be presented in the default view when the component renders.
     */
    set viewDate(value: Date);
    /**
     * Gets the disabled dates descriptors.
     */
    get disabledDates(): DateRangeDescriptor[];
    /**
     * Sets the disabled dates' descriptors.
     * ```typescript
     *@ViewChild("MyCalendar")
     *public calendar: IgxCalendarComponent;
     *ngOnInit(){
     *    this.calendar.disabledDates = [
     *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
     *     {type: DateRangeType.Weekends}];
     *}
     *```
     */
    set disabledDates(value: DateRangeDescriptor[]);
    /**
     * Gets the special dates descriptors.
     */
    get specialDates(): DateRangeDescriptor[];
    /**
     * Sets the special dates' descriptors.
     * ```typescript
     *@ViewChild("MyCalendar")
     *public calendar: IgxCalendarComponent;
     *ngOnInit(){
     *    this.calendar.specialDates = [
     *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
     *     {type: DateRangeType.Weekends}];
     *}
     *```
     */
    set specialDates(value: DateRangeDescriptor[]);
    /**
     * Sets/gets whether the outside dates (dates that are out of the current month) will be hidden.
     * Default value is `false`.
     * ```html
     * <igx-calendar [hideOutsideDays] = "true"></igx-calendar>
     * ```
     * ```typescript
     * let hideOutsideDays = this.calendar.hideOutsideDays;
     * ```
     */
    hideOutsideDays: boolean;
    /**
     * Emits an event when a date is selected.
     * Provides reference the `selectedDates` property.
     */
    onSelection: EventEmitter<Date | Date[]>;
    /**
     *@hidden
     */
    private _selection;
    /**
     *@hidden
     */
    rangeStarted: boolean;
    /**
    *@hidden
    */
    private _locale;
    /**
     *@hidden
     */
    private _viewDate;
    /**
     *@hidden
     */
    private _disabledDates;
    /**
     *@hidden
     */
    private _specialDates;
    /**
     *@hidden
     */
    private _formatOptions;
    /**
     *@hidden
     */
    private _formatViews;
    /**
     *@hidden
     */
    protected formatterWeekday: any;
    /**
     *@hidden
     */
    protected formatterDay: any;
    /**
     *@hidden
     */
    protected formatterMonth: any;
    /**
     *@hidden
     */
    protected formatterYear: any;
    /**
     *@hidden
     */
    protected formatterMonthday: any;
    /**
     *@hidden
     */
    protected calendarModel: Calendar;
    /**
     * @hidden
     */
    monthScrollDirection: ScrollMonth;
    /**
     *@hidden
     */
    scrollMonth$: Subject<unknown>;
    /**
     *@hidden
     */
    stopMonthScroll$: Subject<boolean>;
    /**
     *@hidden
     */
    startMonthScroll$: Subject<unknown>;
    /**
     *@hidden
     */
    selectedDates: any;
    /**
     *@hidden
     */
    protected _onTouchedCallback: () => void;
    /**
     *@hidden
     */
    protected _onChangeCallback: (_: Date) => void;
    /**
     * @hidden
     */
    constructor();
    /**
     *@hidden
     */
    private getDateOnlyInMs;
    /**
     *@hidden
     */
    private generateDateRange;
    /**
     * Performs a single selection.
     * @hidden
     */
    private selectSingle;
    /**
     * Performs a multiple selection
     * @hidden
     */
    private selectMultiple;
    /**
     *@hidden
     */
    private selectRange;
    /**
     * Performs a single deselection.
     * @hidden
     */
    private deselectSingle;
    /**
     * Performs a multiple deselection.
     * @hidden
     */
    private deselectMultiple;
    /**
     * Performs deselection of a single value, when selection is multi
     * Usually performed by the selectMultiple method, but leads to bug when multiple months are in view
     * @hidden
     */
    deselectMultipleInMonth(value: Date): void;
    /**
     * Performs a range deselection.
     * @hidden
     */
    private deselectRange;
    /**
     * @hidden
     */
    protected initFormatters(): void;
    /**
     *@hidden
     */
    protected getDateOnly(date: Date): Date;
    /**
     * @hidden
     */
    registerOnChange(fn: (v: Date) => void): void;
    /**
     * @hidden
     */
    registerOnTouched(fn: () => void): void;
    /**
     * @hidden
     */
    writeValue(value: Date | Date[]): void;
    /**
     * Checks whether a date is disabled.
     * @hidden
     */
    isDateDisabled(date: Date): boolean;
    /**
     * Selects date(s) (based on the selection type).
     */
    selectDate(value: Date | Date[]): void;
    /**
     * Deselects date(s) (based on the selection type).
     */
    deselectDate(value?: Date | Date[]): void;
    /**
     * @hidden
     */
    selectDateFromClient(value: Date): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxCalendarBaseDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxCalendarBaseDirective, "[igxCalendarBase]", never, {
    "hideOutsideDays": "hideOutsideDays";
    "viewDate": "viewDate";
    "weekStart": "weekStart";
    "locale": "locale";
    "formatOptions": "formatOptions";
    "formatViews": "formatViews";
    "selection": "selection";
    "value": "value";
    "disabledDates": "disabledDates";
    "specialDates": "specialDates";
}, {
    "onSelection": "onSelection";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXItYmFzZS5kLnRzIiwic291cmNlcyI6WyJjYWxlbmRhci1iYXNlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztBQVFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9UQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgV0VFS0RBWVMsIENhbGVuZGFyLCBJRm9ybWF0dGluZ09wdGlvbnMsIElGb3JtYXR0aW5nVmlld3MgfSBmcm9tICcuL2NhbGVuZGFyJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgRGF0ZVJhbmdlRGVzY3JpcHRvciB9IGZyb20gJy4uL2NvcmUvZGF0ZXMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuLyoqXG4gKiBTZXRzIHRoZSBzZWxjdGlvbiB0eXBlIC0gc2luZ2xlLCBtdWx0aSBvciByYW5nZS5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgZW51bSBDYWxlbmRhclNlbGVjdGlvbiB7XG4gICAgU0lOR0xFID0gXCJzaW5nbGVcIixcbiAgICBNVUxUSSA9IFwibXVsdGlcIixcbiAgICBSQU5HRSA9IFwicmFuZ2VcIlxufVxuZXhwb3J0IGRlY2xhcmUgZW51bSBTY3JvbGxNb250aCB7XG4gICAgUFJFViA9IFwicHJldlwiLFxuICAgIE5FWFQgPSBcIm5leHRcIixcbiAgICBOT05FID0gXCJub25lXCJcbn1cbi8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4Q2FsZW5kYXJCYXNlRGlyZWN0aXZlIGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YXJ0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgKiBDYW4gcmV0dXJuIGEgbnVtZXJpYyBvciBhbiBlbnVtIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB3ZWVrIGRheS5cbiAgICAgKiBEZWZhdWx0cyB0byBgU3VuZGF5YCAvIGAwYC5cbiAgICAgKi9cbiAgICBnZXQgd2Vla1N0YXJ0KCk6IFdFRUtEQVlTIHwgbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0YXJ0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgKiBDYW4gYmUgYXNzaWduZWQgdG8gYSBudW1lcmljIHZhbHVlIG9yIHRvIGBXRUVLREFZU2AgZW51bSB2YWx1ZS5cbiAgICAgKi9cbiAgICBzZXQgd2Vla1N0YXJ0KHZhbHVlOiBXRUVLREFZUyB8IG51bWJlcik7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYGxvY2FsZWAgb2YgdGhlIGNhbGVuZGFyLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYFwiZW5cImAuXG4gICAgICovXG4gICAgZ2V0IGxvY2FsZSgpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYGxvY2FsZWAgb2YgdGhlIGNhbGVuZGFyLlxuICAgICAqIEV4cGVjdHMgYSB2YWxpZCBCQ1AgNDcgbGFuZ3VhZ2UgdGFnLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYFwiZW5cImAuXG4gICAgICovXG4gICAgc2V0IGxvY2FsZSh2YWx1ZTogc3RyaW5nKTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkYXRlIGZvcm1hdCBvcHRpb25zIG9mIHRoZSBkYXlzIHZpZXcuXG4gICAgICovXG4gICAgZ2V0IGZvcm1hdE9wdGlvbnMoKTogSUZvcm1hdHRpbmdPcHRpb25zO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRhdGUgZm9ybWF0IG9wdGlvbnMgb2YgdGhlIGRheXMgdmlldy5cbiAgICAgKiBEZWZhdWx0IGlzIHsgZGF5OiAnbnVtZXJpYycsIG1vbnRoOiAnc2hvcnQnLCB3ZWVrZGF5OiAnc2hvcnQnLCB5ZWFyOiAnbnVtZXJpYycgfVxuICAgICAqL1xuICAgIHNldCBmb3JtYXRPcHRpb25zKGZvcm1hdE9wdGlvbnM6IElGb3JtYXR0aW5nT3B0aW9ucyk7XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBgZGF5YCwgYG1vbnRoYCBhbmQgYHllYXJgIHNob3VsZCBiZSByZW5kZXJlZFxuICAgICAqIGFjY29yZGluZyB0byB0aGUgbG9jYWxlIGFuZCBmb3JtYXRPcHRpb25zLCBpZiBhbnkuXG4gICAgICovXG4gICAgZ2V0IGZvcm1hdFZpZXdzKCk6IElGb3JtYXR0aW5nVmlld3M7XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBgZGF5YCwgYG1vbnRoYCBhbmQgYHllYXJgIHNob3VsZCBiZSByZW5kZXJlZFxuICAgICAqIGFjY29yZGluZyB0byB0aGUgbG9jYWxlIGFuZCBmb3JtYXRPcHRpb25zLCBpZiBhbnkuXG4gICAgICovXG4gICAgc2V0IGZvcm1hdFZpZXdzKGZvcm1hdFZpZXdzOiBJRm9ybWF0dGluZ1ZpZXdzKTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEdldHMgdGhlIHNlbGVjdGlvbiB0eXBlLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYFwic2luZ2xlXCJgLlxuICAgICAqIENoYW5naW5nIHRoZSB0eXBlIG9mIHNlbGVjdGlvbiByZXNldHMgdGhlIGN1cnJlbnRseVxuICAgICAqIHNlbGVjdGVkIHZhbHVlcyBpZiBhbnkuXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGlvbigpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIHNldCBzZWxlY3Rpb24odmFsdWU6IHN0cmluZyk7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2VsZWN0ZWQgZGF0ZShzKS5cbiAgICAgKlxuICAgICAqIFdoZW4gc2VsZWN0aW9uIGlzIHNldCB0byBgc2luZ2xlYCwgaXQgcmV0dXJuc1xuICAgICAqIGEgc2luZ2xlIGBEYXRlYCBvYmplY3QuXG4gICAgICogT3RoZXJ3aXNlIGl0IGlzIGFuIGFycmF5IG9mIGBEYXRlYCBvYmplY3RzLlxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpOiBEYXRlIHwgRGF0ZVtdO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNlbGVjdGVkIGRhdGUocykuXG4gICAgICpcbiAgICAgKiBXaGVuIHNlbGVjdGlvbiBpcyBzZXQgdG8gYHNpbmdsZWAsIGl0IGFjY2VwdHNcbiAgICAgKiBhIHNpbmdsZSBgRGF0ZWAgb2JqZWN0LlxuICAgICAqIE90aGVyd2lzZSBpdCBpcyBhbiBhcnJheSBvZiBgRGF0ZWAgb2JqZWN0cy5cbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodmFsdWU6IERhdGUgfCBEYXRlW10pO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRhdGUgdGhhdCBpcyBwcmVzZW50ZWQuXG4gICAgICogQnkgZGVmYXVsdCBpdCBpcyB0aGUgY3VycmVudCBkYXRlLlxuICAgICAqL1xuICAgIGdldCB2aWV3RGF0ZSgpOiBEYXRlO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRhdGUgdGhhdCB3aWxsIGJlIHByZXNlbnRlZCBpbiB0aGUgZGVmYXVsdCB2aWV3IHdoZW4gdGhlIGNvbXBvbmVudCByZW5kZXJzLlxuICAgICAqL1xuICAgIHNldCB2aWV3RGF0ZSh2YWx1ZTogRGF0ZSk7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGlzYWJsZWQgZGF0ZXMgZGVzY3JpcHRvcnMuXG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVkRGF0ZXMoKTogRGF0ZVJhbmdlRGVzY3JpcHRvcltdO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRpc2FibGVkIGRhdGVzJyBkZXNjcmlwdG9ycy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlDYWxlbmRhclwiKVxuICAgICAqcHVibGljIGNhbGVuZGFyOiBJZ3hDYWxlbmRhckNvbXBvbmVudDtcbiAgICAgKm5nT25Jbml0KCl7XG4gICAgICogICAgdGhpcy5jYWxlbmRhci5kaXNhYmxlZERhdGVzID0gW1xuICAgICAqICAgICB7dHlwZTogRGF0ZVJhbmdlVHlwZS5CZXR3ZWVuLCBkYXRlUmFuZ2U6IFtuZXcgRGF0ZShcIjIwMjAtMS0xXCIpLCBuZXcgRGF0ZShcIjIwMjAtMS0xNVwiKV19LFxuICAgICAqICAgICB7dHlwZTogRGF0ZVJhbmdlVHlwZS5XZWVrZW5kc31dO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgc2V0IGRpc2FibGVkRGF0ZXModmFsdWU6IERhdGVSYW5nZURlc2NyaXB0b3JbXSk7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3BlY2lhbCBkYXRlcyBkZXNjcmlwdG9ycy5cbiAgICAgKi9cbiAgICBnZXQgc3BlY2lhbERhdGVzKCk6IERhdGVSYW5nZURlc2NyaXB0b3JbXTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzcGVjaWFsIGRhdGVzJyBkZXNjcmlwdG9ycy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlDYWxlbmRhclwiKVxuICAgICAqcHVibGljIGNhbGVuZGFyOiBJZ3hDYWxlbmRhckNvbXBvbmVudDtcbiAgICAgKm5nT25Jbml0KCl7XG4gICAgICogICAgdGhpcy5jYWxlbmRhci5zcGVjaWFsRGF0ZXMgPSBbXG4gICAgICogICAgIHt0eXBlOiBEYXRlUmFuZ2VUeXBlLkJldHdlZW4sIGRhdGVSYW5nZTogW25ldyBEYXRlKFwiMjAyMC0xLTFcIiksIG5ldyBEYXRlKFwiMjAyMC0xLTE1XCIpXX0sXG4gICAgICogICAgIHt0eXBlOiBEYXRlUmFuZ2VUeXBlLldlZWtlbmRzfV07XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzZXQgc3BlY2lhbERhdGVzKHZhbHVlOiBEYXRlUmFuZ2VEZXNjcmlwdG9yW10pO1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBvdXRzaWRlIGRhdGVzIChkYXRlcyB0aGF0IGFyZSBvdXQgb2YgdGhlIGN1cnJlbnQgbW9udGgpIHdpbGwgYmUgaGlkZGVuLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jYWxlbmRhciBbaGlkZU91dHNpZGVEYXlzXSA9IFwidHJ1ZVwiPjwvaWd4LWNhbGVuZGFyPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaGlkZU91dHNpZGVEYXlzID0gdGhpcy5jYWxlbmRhci5oaWRlT3V0c2lkZURheXM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgaGlkZU91dHNpZGVEYXlzOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gYSBkYXRlIGlzIHNlbGVjdGVkLlxuICAgICAqIFByb3ZpZGVzIHJlZmVyZW5jZSB0aGUgYHNlbGVjdGVkRGF0ZXNgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIG9uU2VsZWN0aW9uOiBFdmVudEVtaXR0ZXI8RGF0ZSB8IERhdGVbXT47XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfc2VsZWN0aW9uO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHJhbmdlU3RhcnRlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAqQGhpZGRlblxuICAgICovXG4gICAgcHJpdmF0ZSBfbG9jYWxlO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgX3ZpZXdEYXRlO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgX2Rpc2FibGVkRGF0ZXM7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfc3BlY2lhbERhdGVzO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgX2Zvcm1hdE9wdGlvbnM7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZm9ybWF0Vmlld3M7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGZvcm1hdHRlcldlZWtkYXk6IGFueTtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZm9ybWF0dGVyRGF5OiBhbnk7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGZvcm1hdHRlck1vbnRoOiBhbnk7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGZvcm1hdHRlclllYXI6IGFueTtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZm9ybWF0dGVyTW9udGhkYXk6IGFueTtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY2FsZW5kYXJNb2RlbDogQ2FsZW5kYXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG1vbnRoU2Nyb2xsRGlyZWN0aW9uOiBTY3JvbGxNb250aDtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBzY3JvbGxNb250aCQ6IFN1YmplY3Q8dW5rbm93bj47XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgc3RvcE1vbnRoU2Nyb2xsJDogU3ViamVjdDxib29sZWFuPjtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBzdGFydE1vbnRoU2Nyb2xsJDogU3ViamVjdDx1bmtub3duPjtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBzZWxlY3RlZERhdGVzOiBhbnk7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9vblRvdWNoZWRDYWxsYmFjazogKCkgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX29uQ2hhbmdlQ2FsbGJhY2s6IChfOiBEYXRlKSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0RGF0ZU9ubHlJbk1zO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgZ2VuZXJhdGVEYXRlUmFuZ2U7XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBzaW5nbGUgc2VsZWN0aW9uLlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcml2YXRlIHNlbGVjdFNpbmdsZTtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIG11bHRpcGxlIHNlbGVjdGlvblxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcml2YXRlIHNlbGVjdE11bHRpcGxlO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgc2VsZWN0UmFuZ2U7XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBzaW5nbGUgZGVzZWxlY3Rpb24uXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgZGVzZWxlY3RTaW5nbGU7XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBtdWx0aXBsZSBkZXNlbGVjdGlvbi5cbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBkZXNlbGVjdE11bHRpcGxlO1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGRlc2VsZWN0aW9uIG9mIGEgc2luZ2xlIHZhbHVlLCB3aGVuIHNlbGVjdGlvbiBpcyBtdWx0aVxuICAgICAqIFVzdWFsbHkgcGVyZm9ybWVkIGJ5IHRoZSBzZWxlY3RNdWx0aXBsZSBtZXRob2QsIGJ1dCBsZWFkcyB0byBidWcgd2hlbiBtdWx0aXBsZSBtb250aHMgYXJlIGluIHZpZXdcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZGVzZWxlY3RNdWx0aXBsZUluTW9udGgodmFsdWU6IERhdGUpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcmFuZ2UgZGVzZWxlY3Rpb24uXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgZGVzZWxlY3RSYW5nZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGluaXRGb3JtYXR0ZXJzKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldERhdGVPbmx5KGRhdGU6IERhdGUpOiBEYXRlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiAodjogRGF0ZSkgPT4gdm9pZCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogRGF0ZSB8IERhdGVbXSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSBkYXRlIGlzIGRpc2FibGVkLlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpc0RhdGVEaXNhYmxlZChkYXRlOiBEYXRlKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGRhdGUocykgKGJhc2VkIG9uIHRoZSBzZWxlY3Rpb24gdHlwZSkuXG4gICAgICovXG4gICAgc2VsZWN0RGF0ZSh2YWx1ZTogRGF0ZSB8IERhdGVbXSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRGVzZWxlY3RzIGRhdGUocykgKGJhc2VkIG9uIHRoZSBzZWxlY3Rpb24gdHlwZSkuXG4gICAgICovXG4gICAgZGVzZWxlY3REYXRlKHZhbHVlPzogRGF0ZSB8IERhdGVbXSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHNlbGVjdERhdGVGcm9tQ2xpZW50KHZhbHVlOiBEYXRlKTogdm9pZDtcbn1cbiJdfQ==