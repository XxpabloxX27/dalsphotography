import { EventEmitter, Renderer2, AfterViewInit } from '@angular/core';
import { IgxProcessBarTextTemplateDirective, IgxProgressBarGradientDirective } from './progressbar.common';
import { IBaseEventArgs } from '../core/utils';
import { IgxDirectionality } from '../services/direction/directionality';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './progressbar.common';
import * as ɵngcc2 from '@angular/common';
export declare enum IgxTextAlign {
    START = "start",
    CENTER = "center",
    END = "end"
}
export declare enum IgxProgressType {
    ERROR = "error",
    INFO = "info",
    WARNING = "warning",
    SUCCESS = "success"
}
export interface IChangeProgressEventArgs extends IBaseEventArgs {
    previousValue: number;
    currentValue: number;
}
export declare abstract class BaseProgress {
    /**
     * @hidden
     */
    private requestAnimationId;
    /**
     * @hidden
     */
    protected _valueInPercent: number;
    /**
     * @hidden
     */
    protected _max: number;
    /**
     * @hidden
     */
    protected _value: number;
    /**
     * @hidden
     */
    protected _animate: boolean;
    /**
     * @hidden
     */
    protected _step: any;
    /**
     *Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     *public valuePercent(event){
     *    let percentValue = this.progressBar.valueInPercent;
     *    alert(percentValue);
     *}
     *```
     */
    get valueInPercent(): number;
    /**
     *Sets the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     *    public setValue(event){
     *    this.progressBar.valueInPercent = 56;
     *}
     * //...
     *```
     *```html
     *<button igxButton="fab" igxRipple="" (click)="setValue()">setValue</button>
     *```
     */
    set valueInPercent(value: number);
    /**
     * @hidden
     */
    protected runAnimation(val: number, step: number): void;
    /**
     * @hidden
     */
    protected updateProgressSmoothly(val: number, step: number): void;
    /**
     * @hidden
     */
    protected updateProgressDirectly(val: number): void;
    /**
     * @hidden
     */
    protected directionFlow(currentValue: number, prevValue: number, step: number): number;
    /**
     * @hidden
     */
    private isInLimitRange;
    /**
     * @hidden
     *
     *
     * @param val
     * @param comparator
     * @param step
     */
    private isExceedingUpperLimit;
    /**
     * @hidden
     *
     * @param val
     * @param comparator
     * @param step
     */
    private isExceedingLowerLimit;
    /**
     * @hidden
     * @param step
     */
    private updateProgress;
}
export declare class IgxLinearProgressBarComponent extends BaseProgress {
    /**
     *Animation on progress `IgxLinearProgressBarComponent`. By default it is set to true.
     *```html
     *<igx-linear-bar [animate]="false" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
     *```
     */
    set animate(animate: boolean);
    /**
     *Returns whether the `IgxLinearProgressBarComponent` has animation true/false.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxLinearProgressBarComponent;
     *public animationStatus(event) {
     *    let animationStatus = this.progressBar.animate;
     *    alert(animationStatus);
     *}
     *```
     */
    get animate(): boolean;
    /**
     *Set maximum value that can be passed. By default it is set to 100.
     *```html
     *<igx-linear-bar [striped]="false" [max]="200" [value]="0"></igx-linear-bar>
     *```
     */
    set max(maxNum: number);
    /**
     *Returns the the maximum progress value of the `IgxLinearProgressBarComponent`.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxLinearProgressBarComponent;
     *public maxValue(event) {
     *    let max = this.progressBar.max;
     *    alert(max);
     *}
     *```
     */
    get max(): number;
    /**
     *Returns the value which update the progress indicator of the `IgxLinearProgressBarComponent`.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxLinearProgressBarComponent;
     *public stepValue(event) {
     *    let step = this.progressBar.step;
     *    alert(step);
     *}
     *```
     */
    get step(): number;
    /**
     *Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
     *```html
     *<igx-linear-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-linear-bar>
     *```
     */
    set step(val: number);
    constructor();
    valueMin: number;
    cssClass: string;
    /**
     *Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
     *```html
     *<igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
     *```
     */
    striped: boolean;
    /**
     *Set `IgxLinearProgressBarComponent` to have indeterminate. By default it is set to false.
     *```html
     *<igx-linear-bar [indeterminate]="true"></igx-linear-bar>
     *```
     */
    indeterminate: boolean;
    /**An @Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
     * ```html
     *<igx-linear-bar role="progressbar"></igx-linear-bar>
     * ```
     */
    role: string;
    /**An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
     * ```html
     *<igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     */
    id: string;
    /**
     *Set the position that defines where the text is aligned.
     Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
     *```typescript
     *public positionCenter: IgxTextAlign;
     *public ngOnInit() {
     *    this.positionCenter = IgxTextAlign.CENTER;
     *}
     * //...
     *```
     * ```html
     *<igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
     *```
     */
    textAlign: IgxTextAlign;
    /**
     *Set the text to be visible. By default it is set to true.
     * ```html
     *<igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
     *```
     */
    textVisibility: boolean;
    /**
     *Set the position that defines if the text should be aligned above the progress line. By default is set to false.
     *```html
     *<igx-linear-bar type="error" [textTop]="true"></igx-linear-bar>
     *```
     */
    textTop: boolean;
    /**
     *Set a custom text that is displayed according to the defined position.
     * ```html
     *<igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
     *```
     */
    text: string;
    /**
     *Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `error`.
     *```html
     *<igx-linear-bar [striped]="false" [max]="100" [value]="0" type="error"></igx-linear-bar>
     *```
     */
    type: string;
    /**
    *Returns value that indicates the current `IgxLinearProgressBarComponent` position.
    *```typescript
    *@ViewChild("MyProgressBar")
    *public progressBar: IgxLinearProgressBarComponent;
    *public getValue(event) {
    *    let value = this.progressBar.value;
    *    alert(value);
    *}
    *```
    */
    get value(): number;
    /**
     *Set value that indicates the current `IgxLinearProgressBarComponent` position.
     *```html
     *<igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
     *```
     */
    set value(val: number);
    /**
     *An event, which is triggered after a progress is changed.
     *```typescript
     *public progressChange(event) {
     *    alert("Progress made!");
     *}
     * //...
     *```
     *```html
     *<igx-linear-bar (onProgressChanged)="progressChange($event)" type="success">
     *```
     */
    onProgressChanged: EventEmitter<IChangeProgressEventArgs>;
    /**
     * @hidden
     */
    get error(): boolean;
    /**
     * @hidden
     */
    get info(): boolean;
    /**
     * @hidden
     */
    get warning(): boolean;
    /**
     * @hidden
     */
    get success(): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxLinearProgressBarComponent>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<IgxLinearProgressBarComponent, "igx-linear-bar", never, {
    "striped": "striped";
    "indeterminate": "indeterminate";
    "role": "role";
    "id": "id";
    "textAlign": "textAlign";
    "textVisibility": "textVisibility";
    "textTop": "textTop";
    "type": "type";
    "animate": "animate";
    "max": "max";
    "step": "step";
    "value": "value";
    "text": "text";
}, {
    "onProgressChanged": "onProgressChanged";
}, never>;
}
export declare class IgxCircularProgressBarComponent extends BaseProgress implements AfterViewInit {
    private renderer;
    private _directionality;
    private readonly STROKE_OPACITY_DVIDER;
    private readonly STROKE_OPACITY_ADDITION;
    /** @hidden */
    cssClass: string;
    /**
     *An event, which is triggered after a progress is changed.
     *```typescript
     *public progressChange(event) {
     *    alert("Progress made!");
     *}
     * //...
     *```
     *```html
     *<igx-circular-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-circular-bar>
     *```
     */
    onProgressChanged: EventEmitter<IChangeProgressEventArgs>;
    /**
     *An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
     *```html
     *<igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
     *```
     */
    id: string;
    /**
     * @hidden
     */
    gradientId: string;
    /**
     *An @Input property that sets the value of the `indeterminate` attribute. If not provided it will be automatically set to false.
     *```html
     *<igx-circular-bar [indeterminate]="true"></igx-circular-bar>
     *```
     */
    indeterminate: boolean;
    /**
     *Sets the text visibility. By default it is set to true.
     *```html
     *<igx-circular-bar [textVisibility]="false"></igx-circular-bar>
     *```
     */
    textVisibility: boolean;
    /**
     * Sets/gets the text to be displayed inside the `igxCircularBar`.
     *```html
     *<igx-circular-bar text="Progress"></igx-circular-bar>
     *```
     *```typescript
     *let text = this.circularBar.text;
     *```
     */
    text: string;
    textTemplate: IgxProcessBarTextTemplateDirective;
    gradientTemplate: IgxProgressBarGradientDirective;
    /**
     * @hidden
    */
    get context(): any;
    /**
    *Animation on progress `IgxCircularProgressBarComponent`. By default it is set to true.
     *```html
     *<igx-circular-bar [animate]="false" [value]="50"></igx-circular-bar>
     *```
     */
    set animate(animate: boolean);
    /**
     *Returns whether the `IgxCircularProgressBarComponent` has animation true/false.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxCircularProgressBarComponent;
     *public animationStatus(event) {
     *    let animationStatus = this.progressBar.animate;
     *    alert(animationStatus);
     *}
     *```
     */
    get animate(): boolean;
    /**
     *Set maximum value that can be passed. By default it is set to 100.
     *```html
     *<igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
     *```
     */
    set max(maxNum: number);
    /**
     *Returns the the maximum progress value of the `IgxCircularProgressBarComponent`.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxCircularProgressBarComponent;
     *public maxValue(event) {
     *    let max = this.progressBar.max;
     *    alert(max);
     *}
     *```
     *```html
     *<igx-circular-bar [max]="245" [animate]="false" [value]="currentValue"></igx-circular-bar>
     *```
     */
    get max(): number;
    /**
     *Returns the value which update the progress indicator of the `IgxCircularProgressBarComponent`.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxCircularProgressBarComponent;
     *public stepValue(event) {
     *    let step = this.progressBar.step;
     *    alert(step);
     *}
     *```
     */
    get step(): number;
    /**
     *Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
     *```html
     *<igx-circular-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-circular-bar>
     *```
    */
    set step(val: number);
    /**
     *Returns value that indicates the current `IgxCircularProgressBarComponent` position.
     *```typescript
     *@ViewChild("MyProgressBar")
     *public progressBar: IgxCircularProgressBarComponent;
     *public getValue(event) {
     *    let value = this.progressBar.value;
     *    alert(value);
     *}
     *```
     *```html
     *<button igxButton="fab" igxRipple="" (click)="getValue()">Click</button>
     *```
     */
    get value(): number;
    /**
     *Set value that indicates the current `IgxCircularProgressBarComponent` position.
     *```html
     *<igx-circular-bar [value]="50"></igx-circular-bar>
     *```
     */
    set value(val: number);
    private _circleRadius;
    private _circumference;
    private _svgCircle;
    constructor(renderer: Renderer2, _directionality: IgxDirectionality);
    ngAfterViewInit(): void;
    /**
     * @hidden
     */
    updateProgressSmoothly(val: number, step: number): void;
    /**
     * @hidden
    */
    get textContent(): string;
    /**
     * @hidden
    */
    updateProgressDirectly(val: number): void;
    private getProgress;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxCircularProgressBarComponent>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<IgxCircularProgressBarComponent, "igx-circular-bar", never, {
    "id": "id";
    "indeterminate": "indeterminate";
    "textVisibility": "textVisibility";
    "animate": "animate";
    "max": "max";
    "step": "step";
    "value": "value";
    "text": "text";
}, {
    "onProgressChanged": "onProgressChanged";
}, ["textTemplate", "gradientTemplate"]>;
}
export declare function getValueInProperRange(value: number, max: number, min?: number): number;
export declare function convertInPercentage(value: number, max: number): number;
/**
 * @hidden
 */
export declare class IgxProgressBarModule {
    static ɵmod: ɵngcc0.ɵɵNgModuleDefWithMeta<IgxProgressBarModule, [typeof IgxLinearProgressBarComponent, typeof IgxCircularProgressBarComponent, typeof ɵngcc1.IgxProcessBarTextTemplateDirective, typeof ɵngcc1.IgxProgressBarGradientDirective], [typeof ɵngcc2.CommonModule], [typeof IgxLinearProgressBarComponent, typeof IgxCircularProgressBarComponent, typeof ɵngcc1.IgxProcessBarTextTemplateDirective, typeof ɵngcc1.IgxProgressBarGradientDirective]>;
    static ɵinj: ɵngcc0.ɵɵInjectorDef<IgxProgressBarModule>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3NiYXIuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbInByb2dyZXNzYmFyLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdTQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtLQTs7Ozs7Ozs7O0FBT0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIsIFJlbmRlcmVyMiwgQWZ0ZXJWaWV3SW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4UHJvY2Vzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZSwgSWd4UHJvZ3Jlc3NCYXJHcmFkaWVudERpcmVjdGl2ZSB9IGZyb20gJy4vcHJvZ3Jlc3NiYXIuY29tbW9uJztcbmltcG9ydCB7IElCYXNlRXZlbnRBcmdzIH0gZnJvbSAnLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBJZ3hEaXJlY3Rpb25hbGl0eSB9IGZyb20gJy4uL3NlcnZpY2VzL2RpcmVjdGlvbi9kaXJlY3Rpb25hbGl0eSc7XG5leHBvcnQgZGVjbGFyZSBlbnVtIElneFRleHRBbGlnbiB7XG4gICAgU1RBUlQgPSBcInN0YXJ0XCIsXG4gICAgQ0VOVEVSID0gXCJjZW50ZXJcIixcbiAgICBFTkQgPSBcImVuZFwiXG59XG5leHBvcnQgZGVjbGFyZSBlbnVtIElneFByb2dyZXNzVHlwZSB7XG4gICAgRVJST1IgPSBcImVycm9yXCIsXG4gICAgSU5GTyA9IFwiaW5mb1wiLFxuICAgIFdBUk5JTkcgPSBcIndhcm5pbmdcIixcbiAgICBTVUNDRVNTID0gXCJzdWNjZXNzXCJcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSUNoYW5nZVByb2dyZXNzRXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIHByZXZpb3VzVmFsdWU6IG51bWJlcjtcbiAgICBjdXJyZW50VmFsdWU6IG51bWJlcjtcbn1cbmV4cG9ydCBkZWNsYXJlIGFic3RyYWN0IGNsYXNzIEJhc2VQcm9ncmVzcyB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgcmVxdWVzdEFuaW1hdGlvbklkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3ZhbHVlSW5QZXJjZW50OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfbWF4OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfdmFsdWU6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9hbmltYXRlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3N0ZXA6IGFueTtcbiAgICAvKipcbiAgICAgKlJldHVybnMgdGhlIGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAvYElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHZhbHVlIGluIHBlcmNlbnRhZ2UuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDsgLy8gSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudFxuICAgICAqcHVibGljIHZhbHVlUGVyY2VudChldmVudCl7XG4gICAgICogICAgbGV0IHBlcmNlbnRWYWx1ZSA9IHRoaXMucHJvZ3Jlc3NCYXIudmFsdWVJblBlcmNlbnQ7XG4gICAgICogICAgYWxlcnQocGVyY2VudFZhbHVlKTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldCB2YWx1ZUluUGVyY2VudCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICpTZXRzIHRoZSBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgL2BJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50YCB2YWx1ZSBpbiBwZXJjZW50YWdlLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7IC8vIElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRcbiAgICAgKiAgICBwdWJsaWMgc2V0VmFsdWUoZXZlbnQpe1xuICAgICAqICAgIHRoaXMucHJvZ3Jlc3NCYXIudmFsdWVJblBlcmNlbnQgPSA1NjtcbiAgICAgKn1cbiAgICAgKiAvLy4uLlxuICAgICAqYGBgXG4gICAgICpgYGBodG1sXG4gICAgICo8YnV0dG9uIGlneEJ1dHRvbj1cImZhYlwiIGlneFJpcHBsZT1cIlwiIChjbGljayk9XCJzZXRWYWx1ZSgpXCI+c2V0VmFsdWU8L2J1dHRvbj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHNldCB2YWx1ZUluUGVyY2VudCh2YWx1ZTogbnVtYmVyKTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHJ1bkFuaW1hdGlvbih2YWw6IG51bWJlciwgc3RlcDogbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHVwZGF0ZVByb2dyZXNzU21vb3RobHkodmFsOiBudW1iZXIsIHN0ZXA6IG51bWJlcik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCB1cGRhdGVQcm9ncmVzc0RpcmVjdGx5KHZhbDogbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRpcmVjdGlvbkZsb3coY3VycmVudFZhbHVlOiBudW1iZXIsIHByZXZWYWx1ZTogbnVtYmVyLCBzdGVwOiBudW1iZXIpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByaXZhdGUgaXNJbkxpbWl0UmFuZ2U7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICogQHBhcmFtIGNvbXBhcmF0b3JcbiAgICAgKiBAcGFyYW0gc3RlcFxuICAgICAqL1xuICAgIHByaXZhdGUgaXNFeGNlZWRpbmdVcHBlckxpbWl0O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvclxuICAgICAqIEBwYXJhbSBzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0V4Y2VlZGluZ0xvd2VyTGltaXQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBwYXJhbSBzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSB1cGRhdGVQcm9ncmVzcztcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50IGV4dGVuZHMgQmFzZVByb2dyZXNzIHtcbiAgICAvKipcbiAgICAgKkFuaW1hdGlvbiBvbiBwcm9ncmVzcyBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgLiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byB0cnVlLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFthbmltYXRlXT1cImZhbHNlXCIgW3N0cmlwZWRdPVwidHJ1ZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHNldCBhbmltYXRlKGFuaW1hdGU6IGJvb2xlYW4pO1xuICAgIC8qKlxuICAgICAqUmV0dXJucyB3aGV0aGVyIHRoZSBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIGhhcyBhbmltYXRpb24gdHJ1ZS9mYWxzZS5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50O1xuICAgICAqcHVibGljIGFuaW1hdGlvblN0YXR1cyhldmVudCkge1xuICAgICAqICAgIGxldCBhbmltYXRpb25TdGF0dXMgPSB0aGlzLnByb2dyZXNzQmFyLmFuaW1hdGU7XG4gICAgICogICAgYWxlcnQoYW5pbWF0aW9uU3RhdHVzKTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldCBhbmltYXRlKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICpTZXQgbWF4aW11bSB2YWx1ZSB0aGF0IGNhbiBiZSBwYXNzZWQuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIDEwMC5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciBbc3RyaXBlZF09XCJmYWxzZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgc2V0IG1heChtYXhOdW06IG51bWJlcik7XG4gICAgLyoqXG4gICAgICpSZXR1cm5zIHRoZSB0aGUgbWF4aW11bSBwcm9ncmVzcyB2YWx1ZSBvZiB0aGUgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50O1xuICAgICAqcHVibGljIG1heFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgbGV0IG1heCA9IHRoaXMucHJvZ3Jlc3NCYXIubWF4O1xuICAgICAqICAgIGFsZXJ0KG1heCk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXQgbWF4KCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKlJldHVybnMgdGhlIHZhbHVlIHdoaWNoIHVwZGF0ZSB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yIG9mIHRoZSBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgc3RlcFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgbGV0IHN0ZXAgPSB0aGlzLnByb2dyZXNzQmFyLnN0ZXA7XG4gICAgICogICAgYWxlcnQoc3RlcCk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXQgc3RlcCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICpTZXRzIHRoZSB2YWx1ZSBieSB3aGljaCBwcm9ncmVzcyBpbmRpY2F0b3IgaXMgdXBkYXRlZC4gQnkgZGVmYXVsdCBpdCBpcyAxJSBvZiB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciBbc3RyaXBlZF09XCJmYWxzZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjBcIiBbc3RlcF09XCIxXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHNldCBzdGVwKHZhbDogbnVtYmVyKTtcbiAgICBjb25zdHJ1Y3RvcigpO1xuICAgIHZhbHVlTWluOiBudW1iZXI7XG4gICAgY3NzQ2xhc3M6IHN0cmluZztcbiAgICAvKipcbiAgICAgKlNldCBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHRvIGhhdmUgc3RyaXBlZCBzdHlsZS4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gZmFsc2UuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgW3N0cmlwZWRdPVwidHJ1ZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHN0cmlwZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICpTZXQgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YCB0byBoYXZlIGluZGV0ZXJtaW5hdGUuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIGZhbHNlLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFtpbmRldGVybWluYXRlXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgaW5kZXRlcm1pbmF0ZTogYm9vbGVhbjtcbiAgICAvKipBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYHJvbGVgIGF0dHJpYnV0ZS4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgdG8gYHByb2dyZXNzYmFyYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgcm9sZT1cInByb2dyZXNzYmFyXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICByb2xlOiBzdHJpbmc7XG4gICAgLyoqQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgYGlkYCBhdHRyaWJ1dGUuIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciBbaWRdPVwiJ2lneC1saW5lYXItYmFyLTU1J1wiIFtzdHJpcGVkXT1cInRydWVcIiBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgaWQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKlNldCB0aGUgcG9zaXRpb24gdGhhdCBkZWZpbmVzIHdoZXJlIHRoZSB0ZXh0IGlzIGFsaWduZWQuXG4gICAgIFBvc3NpYmxlIG9wdGlvbnMgLSBgSWd4VGV4dEFsaWduLlNUQVJUYCAoZGVmYXVsdCksIGBJZ3hUZXh0QWxpZ24uQ0VOVEVSYCwgYElneFRleHRBbGlnbi5FTkRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqcHVibGljIHBvc2l0aW9uQ2VudGVyOiBJZ3hUZXh0QWxpZ247XG4gICAgICpwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgICogICAgdGhpcy5wb3NpdGlvbkNlbnRlciA9IElneFRleHRBbGlnbi5DRU5URVI7XG4gICAgICp9XG4gICAgICogLy8uLi5cbiAgICAgKmBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciB0eXBlPVwid2FybmluZ1wiIFt0ZXh0XT1cIidDdXN0b20gdGV4dCdcIiBbdGV4dEFsaWduXT1cInBvc2l0aW9uQ2VudGVyXCIgW3N0cmlwZWRdPVwidHJ1ZVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICB0ZXh0QWxpZ246IElneFRleHRBbGlnbjtcbiAgICAvKipcbiAgICAgKlNldCB0aGUgdGV4dCB0byBiZSB2aXNpYmxlLiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byB0cnVlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciB0eXBlPVwiZGVmYXVsdFwiIFt0ZXh0VmlzaWJpbGl0eV09XCJmYWxzZVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICB0ZXh0VmlzaWJpbGl0eTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKlNldCB0aGUgcG9zaXRpb24gdGhhdCBkZWZpbmVzIGlmIHRoZSB0ZXh0IHNob3VsZCBiZSBhbGlnbmVkIGFib3ZlIHRoZSBwcm9ncmVzcyBsaW5lLiBCeSBkZWZhdWx0IGlzIHNldCB0byBmYWxzZS5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciB0eXBlPVwiZXJyb3JcIiBbdGV4dFRvcF09XCJ0cnVlXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHRleHRUb3A6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICpTZXQgYSBjdXN0b20gdGV4dCB0aGF0IGlzIGRpc3BsYXllZCBhY2NvcmRpbmcgdG8gdGhlIGRlZmluZWQgcG9zaXRpb24uXG4gICAgICogYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIHR5cGU9XCJ3YXJuaW5nXCIgW3RleHRdPVwiJ0N1c3RvbSB0ZXh0J1wiIFt0ZXh0QWxpZ25dPVwicG9zaXRpb25DZW50ZXJcIiBbc3RyaXBlZF09XCJ0cnVlXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHRleHQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKlNldCB0eXBlIG9mIHRoZSBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgLiBQb3NzaWJsZSBvcHRpb25zIC0gYGRlZmF1bHRgLCBgc3VjY2Vzc2AsIGBpbmZvYCwgYHdhcm5pbmdgLCBhbmQgYGVycm9yYC5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciBbc3RyaXBlZF09XCJmYWxzZVwiIFttYXhdPVwiMTAwXCIgW3ZhbHVlXT1cIjBcIiB0eXBlPVwiZXJyb3JcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgdHlwZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICpSZXR1cm5zIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgcG9zaXRpb24uXG4gICAgKmBgYHR5cGVzY3JpcHRcbiAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDtcbiAgICAqcHVibGljIGdldFZhbHVlKGV2ZW50KSB7XG4gICAgKiAgICBsZXQgdmFsdWUgPSB0aGlzLnByb2dyZXNzQmFyLnZhbHVlO1xuICAgICogICAgYWxlcnQodmFsdWUpO1xuICAgICp9XG4gICAgKmBgYFxuICAgICovXG4gICAgZ2V0IHZhbHVlKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKlNldCB2YWx1ZSB0aGF0IGluZGljYXRlcyB0aGUgY3VycmVudCBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHBvc2l0aW9uLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgc2V0IHZhbHVlKHZhbDogbnVtYmVyKTtcbiAgICAvKipcbiAgICAgKkFuIGV2ZW50LCB3aGljaCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgYSBwcm9ncmVzcyBpcyBjaGFuZ2VkLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqcHVibGljIHByb2dyZXNzQ2hhbmdlKGV2ZW50KSB7XG4gICAgICogICAgYWxlcnQoXCJQcm9ncmVzcyBtYWRlIVwiKTtcbiAgICAgKn1cbiAgICAgKiAvLy4uLlxuICAgICAqYGBgXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgKG9uUHJvZ3Jlc3NDaGFuZ2VkKT1cInByb2dyZXNzQ2hhbmdlKCRldmVudClcIiB0eXBlPVwic3VjY2Vzc1wiPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgb25Qcm9ncmVzc0NoYW5nZWQ6IEV2ZW50RW1pdHRlcjxJQ2hhbmdlUHJvZ3Jlc3NFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZXJyb3IoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGluZm8oKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHdhcm5pbmcoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHN1Y2Nlc3MoKTogYm9vbGVhbjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlUHJvZ3Jlc3MgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgICBwcml2YXRlIHJlbmRlcmVyO1xuICAgIHByaXZhdGUgX2RpcmVjdGlvbmFsaXR5O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgU1RST0tFX09QQUNJVFlfRFZJREVSO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgU1RST0tFX09QQUNJVFlfQURESVRJT047XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBjc3NDbGFzczogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqQW4gZXZlbnQsIHdoaWNoIGlzIHRyaWdnZXJlZCBhZnRlciBhIHByb2dyZXNzIGlzIGNoYW5nZWQuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NDaGFuZ2UoZXZlbnQpIHtcbiAgICAgKiAgICBhbGVydChcIlByb2dyZXNzIG1hZGUhXCIpO1xuICAgICAqfVxuICAgICAqIC8vLi4uXG4gICAgICpgYGBcbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFt2YWx1ZV09XCJjdXJyZW50VmFsdWVcIiAob25Qcm9ncmVzc0NoYW5nZWQpPVwicHJvZ3Jlc3NDaGFuZ2UoJGV2ZW50KVwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIG9uUHJvZ3Jlc3NDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8SUNoYW5nZVByb2dyZXNzRXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKkFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIGBpZGAgYXR0cmlidXRlLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFtpZF09XCInaWd4LWNpcmN1bGFyLWJhci01NSdcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBpZDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBncmFkaWVudElkOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICpBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYGluZGV0ZXJtaW5hdGVgIGF0dHJpYnV0ZS4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgdG8gZmFsc2UuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWNpcmN1bGFyLWJhciBbaW5kZXRlcm1pbmF0ZV09XCJ0cnVlXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgaW5kZXRlcm1pbmF0ZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKlNldHMgdGhlIHRleHQgdmlzaWJpbGl0eS4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFt0ZXh0VmlzaWJpbGl0eV09XCJmYWxzZVwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHRleHRWaXNpYmlsaXR5OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgdGV4dCB0byBiZSBkaXNwbGF5ZWQgaW5zaWRlIHRoZSBgaWd4Q2lyY3VsYXJCYXJgLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1jaXJjdWxhci1iYXIgdGV4dD1cIlByb2dyZXNzXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpsZXQgdGV4dCA9IHRoaXMuY2lyY3VsYXJCYXIudGV4dDtcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHRleHQ6IHN0cmluZztcbiAgICB0ZXh0VGVtcGxhdGU6IElneFByb2Nlc3NCYXJUZXh0VGVtcGxhdGVEaXJlY3RpdmU7XG4gICAgZ3JhZGllbnRUZW1wbGF0ZTogSWd4UHJvZ3Jlc3NCYXJHcmFkaWVudERpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgICBnZXQgY29udGV4dCgpOiBhbnk7XG4gICAgLyoqXG4gICAgKkFuaW1hdGlvbiBvbiBwcm9ncmVzcyBgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIHRydWUuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWNpcmN1bGFyLWJhciBbYW5pbWF0ZV09XCJmYWxzZVwiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHNldCBhbmltYXRlKGFuaW1hdGU6IGJvb2xlYW4pO1xuICAgIC8qKlxuICAgICAqUmV0dXJucyB3aGV0aGVyIHRoZSBgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgaGFzIGFuaW1hdGlvbiB0cnVlL2ZhbHNlLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0JhcjogSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyBhbmltYXRpb25TdGF0dXMoZXZlbnQpIHtcbiAgICAgKiAgICBsZXQgYW5pbWF0aW9uU3RhdHVzID0gdGhpcy5wcm9ncmVzc0Jhci5hbmltYXRlO1xuICAgICAqICAgIGFsZXJ0KGFuaW1hdGlvblN0YXR1cyk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXQgYW5pbWF0ZSgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqU2V0IG1heGltdW0gdmFsdWUgdGhhdCBjYW4gYmUgcGFzc2VkLiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byAxMDAuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWNpcmN1bGFyLWJhciBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCIwXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgc2V0IG1heChtYXhOdW06IG51bWJlcik7XG4gICAgLyoqXG4gICAgICpSZXR1cm5zIHRoZSB0aGUgbWF4aW11bSBwcm9ncmVzcyB2YWx1ZSBvZiB0aGUgYElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0JhcjogSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyBtYXhWYWx1ZShldmVudCkge1xuICAgICAqICAgIGxldCBtYXggPSB0aGlzLnByb2dyZXNzQmFyLm1heDtcbiAgICAgKiAgICBhbGVydChtYXgpO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWNpcmN1bGFyLWJhciBbbWF4XT1cIjI0NVwiIFthbmltYXRlXT1cImZhbHNlXCIgW3ZhbHVlXT1cImN1cnJlbnRWYWx1ZVwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldCBtYXgoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqUmV0dXJucyB0aGUgdmFsdWUgd2hpY2ggdXBkYXRlIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3Igb2YgdGhlIGBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50YC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgc3RlcFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgbGV0IHN0ZXAgPSB0aGlzLnByb2dyZXNzQmFyLnN0ZXA7XG4gICAgICogICAgYWxlcnQoc3RlcCk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXQgc3RlcCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICpTZXRzIHRoZSB2YWx1ZSBieSB3aGljaCBwcm9ncmVzcyBpbmRpY2F0b3IgaXMgdXBkYXRlZC4gQnkgZGVmYXVsdCBpdCBpcyAxJSBvZiB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiMFwiIFtzdGVwXT1cIjFcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICpgYGBcbiAgICAqL1xuICAgIHNldCBzdGVwKHZhbDogbnVtYmVyKTtcbiAgICAvKipcbiAgICAgKlJldHVybnMgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgYElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHBvc2l0aW9uLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0JhcjogSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyBnZXRWYWx1ZShldmVudCkge1xuICAgICAqICAgIGxldCB2YWx1ZSA9IHRoaXMucHJvZ3Jlc3NCYXIudmFsdWU7XG4gICAgICogICAgYWxlcnQodmFsdWUpO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICpgYGBodG1sXG4gICAgICo8YnV0dG9uIGlneEJ1dHRvbj1cImZhYlwiIGlneFJpcHBsZT1cIlwiIChjbGljayk9XCJnZXRWYWx1ZSgpXCI+Q2xpY2s8L2J1dHRvbj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICpTZXQgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgYElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHBvc2l0aW9uLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1jaXJjdWxhci1iYXIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgc2V0IHZhbHVlKHZhbDogbnVtYmVyKTtcbiAgICBwcml2YXRlIF9jaXJjbGVSYWRpdXM7XG4gICAgcHJpdmF0ZSBfY2lyY3VtZmVyZW5jZTtcbiAgICBwcml2YXRlIF9zdmdDaXJjbGU7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXI6IFJlbmRlcmVyMiwgX2RpcmVjdGlvbmFsaXR5OiBJZ3hEaXJlY3Rpb25hbGl0eSk7XG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHVwZGF0ZVByb2dyZXNzU21vb3RobHkodmFsOiBudW1iZXIsIHN0ZXA6IG51bWJlcik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICovXG4gICAgZ2V0IHRleHRDb250ZW50KCk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgICB1cGRhdGVQcm9ncmVzc0RpcmVjdGx5KHZhbDogbnVtYmVyKTogdm9pZDtcbiAgICBwcml2YXRlIGdldFByb2dyZXNzO1xufVxuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gZ2V0VmFsdWVJblByb3BlclJhbmdlKHZhbHVlOiBudW1iZXIsIG1heDogbnVtYmVyLCBtaW4/OiBudW1iZXIpOiBudW1iZXI7XG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBjb252ZXJ0SW5QZXJjZW50YWdlKHZhbHVlOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneFByb2dyZXNzQmFyTW9kdWxlIHtcbn1cbiJdfQ==