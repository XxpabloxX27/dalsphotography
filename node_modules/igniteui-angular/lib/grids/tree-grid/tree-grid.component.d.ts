import { OnInit, TemplateRef, QueryList, AfterContentInit, DoCheck } from '@angular/core';
import { IgxGridBaseDirective } from '../grid-base.directive';
import { ITreeGridRecord } from './tree-grid.interfaces';
import { HierarchicalTransaction, HierarchicalState } from '../../services/transaction/transaction';
import { IgxHierarchicalTransactionService } from '../../services/index';
import { IgxRowLoadingIndicatorTemplateDirective } from './tree-grid.directives';
import { GridType } from '../common/grid.interface';
import { IgxColumnComponent } from '../columns/column.component';
/**
 * **Ignite UI for Angular Tree Grid** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html)
 *
 * The Ignite UI Tree Grid displays and manipulates hierarchical data with consistent schema formatted as a table and
 * provides features such as sorting, filtering, editing, column pinning, paging, column moving and hiding.
 *
 * Example:
 * ```html
 * <igx-tree-grid [data]="employeeData" primaryKey="employeeID" foreignKey="PID" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-tree-grid>
 * ```
 */
import * as Éµngcc0 from '@angular/core';
export declare class IgxTreeGridComponent extends IgxGridBaseDirective implements GridType, OnInit, DoCheck, AfterContentInit {
    private _id;
    private _data;
    private _rowLoadingIndicatorTemplate;
    protected _transactions: IgxHierarchicalTransactionService<HierarchicalTransaction, HierarchicalState>;
    /**
     * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
     * ```html
     * <igx-tree-grid [id]="'igx-tree-grid-1'"></igx-tree-grid>
     * ```
     * @memberof IgxTreeGridComponent
     */
    get id(): string;
    set id(value: string);
    /**
     * An @Input property that lets you fill the `IgxTreeGridComponent` with an array of data.
     * ```html
     * <igx-tree-grid [data]="Data" [autoGenerate]="true"></igx-tree-grid>
     * ```
     * @memberof IgxTreeGridComponent
     */
    get data(): any[];
    set data(value: any[]);
    /**
     * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * ```
     * @memberof IgxTreeGridComponent
     */
    get filteredData(): any;
    /**
     * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * this.grid.filteredData = [{
     *       ID: 1,
     *       Name: "A"
     * }];
     * ```
     * @memberof IgxTreeGridComponent
     */
    set filteredData(value: any);
    /**
     * Get transactions service for the grid.
     * @experimental @hidden
     */
    get transactions(): IgxHierarchicalTransactionService<HierarchicalTransaction, HierarchicalState>;
    /**
    * @hidden
    */
    flatData: any[];
    /**
    * @hidden
    */
    processedExpandedFlatData: any[];
    /**
     * Returns an array of the root level `ITreeGridRecord`s.
     * ```typescript
     * // gets the root record with index=2
     * const states = this.grid.rootRecords[2];
     * ```
     * @memberof IgxTreeGridComponent
     */
    rootRecords: ITreeGridRecord[];
    /**
     * Returns a map of all `ITreeGridRecord`s.
     * ```typescript
     * // gets the record with primaryKey=2
     * const states = this.grid.records.get(2);
     * ```
     * @memberof IgxTreeGridComponent
     */
    records: Map<any, ITreeGridRecord>;
    /**
     * Returns an array of processed (filtered and sorted) root `ITreeGridRecord`s.
     * ```typescript
     * // gets the processed root record with index=2
     * const states = this.grid.processedRootRecords[2];
     * ```
     * @memberof IgxTreeGridComponent
     */
    processedRootRecords: ITreeGridRecord[];
    /**
     * Returns a map of all processed (filtered and sorted) `ITreeGridRecord`s.
     * ```typescript
     * // gets the processed record with primaryKey=2
     * const states = this.grid.processedRecords.get(2);
     * ```
     * @memberof IgxTreeGridComponent
     */
    processedRecords: Map<any, ITreeGridRecord>;
    /**
     * An @Input property that sets the child data key of the `IgxTreeGridComponent`.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" [autoGenerate]="true"></igx-tree-grid>
     * ```
     * @memberof IgxTreeGridComponent
     */
    childDataKey: any;
    /**
     * An @Input property that sets the foreign key of the `IgxTreeGridComponent`.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" [autoGenerate]="true">
     * </igx-tree-grid>
     * ```
     * @memberof IgxTreeGridComponent
     */
    foreignKey: any;
    /**
     * An @Input property that sets the key indicating whether a row has children.
     * This property is only used for load on demand scenarios.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'"
     *                [loadChildrenOnDemand]="loadChildren"
     *                [hasChildrenKey]="'hasEmployees'">
     * </igx-tree-grid>
     * ```
     * @memberof IgxTreeGridComponent
     */
    hasChildrenKey: any;
    /**
     * An @Input property indicating whether child records should be deleted when their parent gets deleted.
     * By default it is set to true and deletes all children along with the parent.
     * ```html
     * <igx-tree-grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" cascadeOnDelete="false">
     * </igx-tree-grid>
     * ```
     * @memberof IgxTreeGridComponent
     */
    cascadeOnDelete: boolean;
    private _expansionDepth;
    /**
     * An @Input property that sets the count of levels to be expanded in the `IgxTreeGridComponent`. By default it is
     * set to `Infinity` which means all levels would be expanded.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" expansionDepth="1" [autoGenerate]="true"></igx-tree-grid>
     * ```
     * @memberof IgxTreeGridComponent
     */
    get expansionDepth(): number;
    set expansionDepth(value: number);
    /**
     * @hidden
     */
    protected rowLoadingTemplate: IgxRowLoadingIndicatorTemplateDirective;
    /**
     * An @Input property that provides a template for the row loading indicator when load on demand is enabled.
     * ```html
     * <ng-template #rowLoadingTemplate>
     *     <igx-icon fontSet="material">loop</igx-icon>
     * </ng-template>
     *
     * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'ID'" [foreignKey]="'parentID'"
     *                [loadChildrenOnDemand]="loadChildren"
     *                [rowLoadingIndicatorTemplate]="rowLoadingTemplate">
     * </igx-tree-grid>
     * ```
     * @memberof IgxTreeGridComponent
     */
    get rowLoadingIndicatorTemplate(): TemplateRef<any>;
    set rowLoadingIndicatorTemplate(value: TemplateRef<any>);
    /**
     * An @Input property that provides a callback for loading child rows on demand.
     * ```html
     * <igx-tree-grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" [loadChildrenOnDemand]="loadChildren">
     * </igx-tree-grid>
     * ```
     * ```typescript
     * public loadChildren = (parentID: any, done: (children: any[]) => void) => {
     *     this.dataService.getData(parentID, children => done(children));
     * }
     * ```
     * @memberof IgxTreeGridComponent
     */
    loadChildrenOnDemand: (parentID: any, done: (children: any[]) => void) => void;
    /**
     * @hidden
     */
    loadingRows: Set<any>;
    private get _gridAPI();
    private _filteredData;
    /**
     * @hidden
     * @internal
     */
    dragIndicatorIconBase: TemplateRef<any>;
    /**
     * @hidden
     */
    ngOnInit(): void;
    ngDoCheck(): void;
    /**
     * @hidden
     */
    ngAfterContentInit(): void;
    private loadChildrenOnRowExpansion;
    private addChildRows;
    private cloneMap;
    getDefaultExpandState(record: ITreeGridRecord): boolean;
    /**
     * Expands all rows.
     * ```typescript
     * this.grid.expandAll();
     * ```
     * @memberof IgxTreeGridComponent
     */
    expandAll(): void;
    /**
     * Collapses all rows.
     * ```typescript
     * this.grid.collapseAll();
     * ```
     * @memberof IgxTreeGridComponent
     */
    collapseAll(): void;
    /**
     * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created
     * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches
     * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.
     * ```typescript
     * const record = {
     *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.
     * ```
     * @param data
     * @param parentRowID
     * @memberof IgxTreeGridComponent
     */
    addRow(data: any, parentRowID?: any): void;
    /** @hidden */
    deleteRowById(rowId: any): void;
    /** @hidden */
    generateRowPath(rowId: any): any[];
    /**
     * @hidden @internal
     */
    protected getDataBasedBodyHeight(): number;
    /**
     * @hidden
     */
    protected scrollTo(row: any | number, column: any | number): void;
    /**
    * @hidden
    */
    getContext(rowData: any, rowIndex: Number): any;
    /**
     * @inheritdoc
     */
    getSelectedData(formatters?: boolean, headers?: boolean): any[];
    /**
    * @hidden
    */
    get template(): TemplateRef<any>;
    protected writeToData(rowIndex: number, value: any): void;
    /**
     * @hidden
    */
    protected initColumns(collection: QueryList<IgxColumnComponent>, cb?: Function): void;
    static Éµfac: Éµngcc0.ÉµÉµFactoryDef<IgxTreeGridComponent>;
    static Éµcmp: Éµngcc0.ÉµÉµComponentDefWithMeta<IgxTreeGridComponent, "igx-tree-grid", never, {
    "cascadeOnDelete": "cascadeOnDelete";
    "id": "id";
    "data": "data";
    "expansionDepth": "expansionDepth";
    "rowLoadingIndicatorTemplate": "rowLoadingIndicatorTemplate";
    "childDataKey": "childDataKey";
    "foreignKey": "foreignKey";
    "hasChildrenKey": "hasChildrenKey";
    "loadChildrenOnDemand": "loadChildrenOnDemand";
}, {}, ["rowLoadingTemplate"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ncmlkLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJ0cmVlLWdyaWQuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb1FBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT25Jbml0LCBUZW1wbGF0ZVJlZiwgUXVlcnlMaXN0LCBBZnRlckNvbnRlbnRJbml0LCBEb0NoZWNrIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZ3hHcmlkQmFzZURpcmVjdGl2ZSB9IGZyb20gJy4uL2dyaWQtYmFzZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSVRyZWVHcmlkUmVjb3JkIH0gZnJvbSAnLi90cmVlLWdyaWQuaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBIaWVyYXJjaGljYWxUcmFuc2FjdGlvbiwgSGllcmFyY2hpY2FsU3RhdGUgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy90cmFuc2FjdGlvbi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBJZ3hIaWVyYXJjaGljYWxUcmFuc2FjdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9pbmRleCc7XG5pbXBvcnQgeyBJZ3hSb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuL3RyZWUtZ3JpZC5kaXJlY3RpdmVzJztcbmltcG9ydCB7IEdyaWRUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElneENvbHVtbkNvbXBvbmVudCB9IGZyb20gJy4uL2NvbHVtbnMvY29sdW1uLmNvbXBvbmVudCc7XG4vKipcbiAqICoqSWduaXRlIFVJIGZvciBBbmd1bGFyIFRyZWUgR3JpZCoqIC1cbiAqIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5pbmZyYWdpc3RpY3MuY29tL3Byb2R1Y3RzL2lnbml0ZS11aS1hbmd1bGFyL2FuZ3VsYXIvY29tcG9uZW50cy9ncmlkLmh0bWwpXG4gKlxuICogVGhlIElnbml0ZSBVSSBUcmVlIEdyaWQgZGlzcGxheXMgYW5kIG1hbmlwdWxhdGVzIGhpZXJhcmNoaWNhbCBkYXRhIHdpdGggY29uc2lzdGVudCBzY2hlbWEgZm9ybWF0dGVkIGFzIGEgdGFibGUgYW5kXG4gKiBwcm92aWRlcyBmZWF0dXJlcyBzdWNoIGFzIHNvcnRpbmcsIGZpbHRlcmluZywgZWRpdGluZywgY29sdW1uIHBpbm5pbmcsIHBhZ2luZywgY29sdW1uIG1vdmluZyBhbmQgaGlkaW5nLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8aWd4LXRyZWUtZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBwcmltYXJ5S2V5PVwiZW1wbG95ZWVJRFwiIGZvcmVpZ25LZXk9XCJQSURcIiBhdXRvR2VuZXJhdGU9XCJmYWxzZVwiPlxuICogICA8aWd4LWNvbHVtbiBmaWVsZD1cImZpcnN0XCIgaGVhZGVyPVwiRmlyc3QgTmFtZVwiPjwvaWd4LWNvbHVtbj5cbiAqICAgPGlneC1jb2x1bW4gZmllbGQ9XCJsYXN0XCIgaGVhZGVyPVwiTGFzdCBOYW1lXCI+PC9pZ3gtY29sdW1uPlxuICogICA8aWd4LWNvbHVtbiBmaWVsZD1cInJvbGVcIiBoZWFkZXI9XCJSb2xlXCI+PC9pZ3gtY29sdW1uPlxuICogPC9pZ3gtdHJlZS1ncmlkPlxuICogYGBgXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneFRyZWVHcmlkQ29tcG9uZW50IGV4dGVuZHMgSWd4R3JpZEJhc2VEaXJlY3RpdmUgaW1wbGVtZW50cyBHcmlkVHlwZSwgT25Jbml0LCBEb0NoZWNrLCBBZnRlckNvbnRlbnRJbml0IHtcbiAgICBwcml2YXRlIF9pZDtcbiAgICBwcml2YXRlIF9kYXRhO1xuICAgIHByaXZhdGUgX3Jvd0xvYWRpbmdJbmRpY2F0b3JUZW1wbGF0ZTtcbiAgICBwcm90ZWN0ZWQgX3RyYW5zYWN0aW9uczogSWd4SGllcmFyY2hpY2FsVHJhbnNhY3Rpb25TZXJ2aWNlPEhpZXJhcmNoaWNhbFRyYW5zYWN0aW9uLCBIaWVyYXJjaGljYWxTdGF0ZT47XG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgdGhlIGBpZGAgYXR0cmlidXRlLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlLWdyaWQgW2lkXT1cIidpZ3gtdHJlZS1ncmlkLTEnXCI+PC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBpZCgpOiBzdHJpbmc7XG4gICAgc2V0IGlkKHZhbHVlOiBzdHJpbmcpO1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IGxldHMgeW91IGZpbGwgdGhlIGBJZ3hUcmVlR3JpZENvbXBvbmVudGAgd2l0aCBhbiBhcnJheSBvZiBkYXRhLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCBbZGF0YV09XCJEYXRhXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBkYXRhKCk6IGFueVtdO1xuICAgIHNldCBkYXRhKHZhbHVlOiBhbnlbXSk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIGZpbHRlcmVkIGRhdGEgaW4gdGhlIGBJZ3hHcmlkQ29tcG9uZW50YC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGZpbHRlcmVkRGF0YSA9IHRoaXMuZ3JpZC5maWx0ZXJlZERhdGE7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGZpbHRlcmVkRGF0YSgpOiBhbnk7XG4gICAgLyoqXG4gICAgICogU2V0cyBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIGZpbHRlcmVkIGRhdGEgaW4gdGhlIGBJZ3hHcmlkQ29tcG9uZW50YC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLmZpbHRlcmVkRGF0YSA9IFt7XG4gICAgICogICAgICAgSUQ6IDEsXG4gICAgICogICAgICAgTmFtZTogXCJBXCJcbiAgICAgKiB9XTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgZmlsdGVyZWREYXRhKHZhbHVlOiBhbnkpO1xuICAgIC8qKlxuICAgICAqIEdldCB0cmFuc2FjdGlvbnMgc2VydmljZSBmb3IgdGhlIGdyaWQuXG4gICAgICogQGV4cGVyaW1lbnRhbCBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHRyYW5zYWN0aW9ucygpOiBJZ3hIaWVyYXJjaGljYWxUcmFuc2FjdGlvblNlcnZpY2U8SGllcmFyY2hpY2FsVHJhbnNhY3Rpb24sIEhpZXJhcmNoaWNhbFN0YXRlPjtcbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgIGZsYXREYXRhOiBhbnlbXTtcbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgIHByb2Nlc3NlZEV4cGFuZGVkRmxhdERhdGE6IGFueVtdO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJvb3QgbGV2ZWwgYElUcmVlR3JpZFJlY29yZGBzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRzIHRoZSByb290IHJlY29yZCB3aXRoIGluZGV4PTJcbiAgICAgKiBjb25zdCBzdGF0ZXMgPSB0aGlzLmdyaWQucm9vdFJlY29yZHNbMl07XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcm9vdFJlY29yZHM6IElUcmVlR3JpZFJlY29yZFtdO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBtYXAgb2YgYWxsIGBJVHJlZUdyaWRSZWNvcmRgcy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0cyB0aGUgcmVjb3JkIHdpdGggcHJpbWFyeUtleT0yXG4gICAgICogY29uc3Qgc3RhdGVzID0gdGhpcy5ncmlkLnJlY29yZHMuZ2V0KDIpO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHJlY29yZHM6IE1hcDxhbnksIElUcmVlR3JpZFJlY29yZD47XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBwcm9jZXNzZWQgKGZpbHRlcmVkIGFuZCBzb3J0ZWQpIHJvb3QgYElUcmVlR3JpZFJlY29yZGBzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRzIHRoZSBwcm9jZXNzZWQgcm9vdCByZWNvcmQgd2l0aCBpbmRleD0yXG4gICAgICogY29uc3Qgc3RhdGVzID0gdGhpcy5ncmlkLnByb2Nlc3NlZFJvb3RSZWNvcmRzWzJdO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHByb2Nlc3NlZFJvb3RSZWNvcmRzOiBJVHJlZUdyaWRSZWNvcmRbXTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbWFwIG9mIGFsbCBwcm9jZXNzZWQgKGZpbHRlcmVkIGFuZCBzb3J0ZWQpIGBJVHJlZUdyaWRSZWNvcmRgcy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0cyB0aGUgcHJvY2Vzc2VkIHJlY29yZCB3aXRoIHByaW1hcnlLZXk9MlxuICAgICAqIGNvbnN0IHN0YXRlcyA9IHRoaXMuZ3JpZC5wcm9jZXNzZWRSZWNvcmRzLmdldCgyKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwcm9jZXNzZWRSZWNvcmRzOiBNYXA8YW55LCBJVHJlZUdyaWRSZWNvcmQ+O1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGNoaWxkIGRhdGEga2V5IG9mIHRoZSBgSWd4VHJlZUdyaWRDb21wb25lbnRgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCAjZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbY2hpbGREYXRhS2V5XT1cIidlbXBsb3llZXMnXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIGNoaWxkRGF0YUtleTogYW55O1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGZvcmVpZ24ga2V5IG9mIHRoZSBgSWd4VHJlZUdyaWRDb21wb25lbnRgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCAjZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbcHJpbWFyeUtleV09XCInZW1wbG95ZWVJRCdcIiBbZm9yZWlnbktleV09XCIncGFyZW50SUQnXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+XG4gICAgICogPC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIGZvcmVpZ25LZXk6IGFueTtcbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBrZXkgaW5kaWNhdGluZyB3aGV0aGVyIGEgcm93IGhhcyBjaGlsZHJlbi5cbiAgICAgKiBUaGlzIHByb3BlcnR5IGlzIG9ubHkgdXNlZCBmb3IgbG9hZCBvbiBkZW1hbmQgc2NlbmFyaW9zLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCAjZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbcHJpbWFyeUtleV09XCInZW1wbG95ZWVJRCdcIiBbZm9yZWlnbktleV09XCIncGFyZW50SUQnXCJcbiAgICAgKiAgICAgICAgICAgICAgICBbbG9hZENoaWxkcmVuT25EZW1hbmRdPVwibG9hZENoaWxkcmVuXCJcbiAgICAgKiAgICAgICAgICAgICAgICBbaGFzQ2hpbGRyZW5LZXldPVwiJ2hhc0VtcGxveWVlcydcIj5cbiAgICAgKiA8L2lneC10cmVlLWdyaWQ+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgaGFzQ2hpbGRyZW5LZXk6IGFueTtcbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgaW5kaWNhdGluZyB3aGV0aGVyIGNoaWxkIHJlY29yZHMgc2hvdWxkIGJlIGRlbGV0ZWQgd2hlbiB0aGVpciBwYXJlbnQgZ2V0cyBkZWxldGVkLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIHRydWUgYW5kIGRlbGV0ZXMgYWxsIGNoaWxkcmVuIGFsb25nIHdpdGggdGhlIHBhcmVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlLWdyaWQgW2RhdGFdPVwiZW1wbG95ZWVEYXRhXCIgW3ByaW1hcnlLZXldPVwiJ2VtcGxveWVlSUQnXCIgW2ZvcmVpZ25LZXldPVwiJ3BhcmVudElEJ1wiIGNhc2NhZGVPbkRlbGV0ZT1cImZhbHNlXCI+XG4gICAgICogPC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIGNhc2NhZGVPbkRlbGV0ZTogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9leHBhbnNpb25EZXB0aDtcbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBjb3VudCBvZiBsZXZlbHMgdG8gYmUgZXhwYW5kZWQgaW4gdGhlIGBJZ3hUcmVlR3JpZENvbXBvbmVudGAuIEJ5IGRlZmF1bHQgaXQgaXNcbiAgICAgKiBzZXQgdG8gYEluZmluaXR5YCB3aGljaCBtZWFucyBhbGwgbGV2ZWxzIHdvdWxkIGJlIGV4cGFuZGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCAjZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbY2hpbGREYXRhS2V5XT1cIidlbXBsb3llZXMnXCIgZXhwYW5zaW9uRGVwdGg9XCIxXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBleHBhbnNpb25EZXB0aCgpOiBudW1iZXI7XG4gICAgc2V0IGV4cGFuc2lvbkRlcHRoKHZhbHVlOiBudW1iZXIpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcm93TG9hZGluZ1RlbXBsYXRlOiBJZ3hSb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmU7XG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgcHJvdmlkZXMgYSB0ZW1wbGF0ZSBmb3IgdGhlIHJvdyBsb2FkaW5nIGluZGljYXRvciB3aGVuIGxvYWQgb24gZGVtYW5kIGlzIGVuYWJsZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSAjcm93TG9hZGluZ1RlbXBsYXRlPlxuICAgICAqICAgICA8aWd4LWljb24gZm9udFNldD1cIm1hdGVyaWFsXCI+bG9vcDwvaWd4LWljb24+XG4gICAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICAgKlxuICAgICAqIDxpZ3gtdHJlZS1ncmlkICNncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIFtwcmltYXJ5S2V5XT1cIidJRCdcIiBbZm9yZWlnbktleV09XCIncGFyZW50SUQnXCJcbiAgICAgKiAgICAgICAgICAgICAgICBbbG9hZENoaWxkcmVuT25EZW1hbmRdPVwibG9hZENoaWxkcmVuXCJcbiAgICAgKiAgICAgICAgICAgICAgICBbcm93TG9hZGluZ0luZGljYXRvclRlbXBsYXRlXT1cInJvd0xvYWRpbmdUZW1wbGF0ZVwiPlxuICAgICAqIDwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgcm93TG9hZGluZ0luZGljYXRvclRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgc2V0IHJvd0xvYWRpbmdJbmRpY2F0b3JUZW1wbGF0ZSh2YWx1ZTogVGVtcGxhdGVSZWY8YW55Pik7XG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgcHJvdmlkZXMgYSBjYWxsYmFjayBmb3IgbG9hZGluZyBjaGlsZCByb3dzIG9uIGRlbWFuZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlLWdyaWQgW2RhdGFdPVwiZW1wbG95ZWVEYXRhXCIgW3ByaW1hcnlLZXldPVwiJ2VtcGxveWVlSUQnXCIgW2ZvcmVpZ25LZXldPVwiJ3BhcmVudElEJ1wiIFtsb2FkQ2hpbGRyZW5PbkRlbWFuZF09XCJsb2FkQ2hpbGRyZW5cIj5cbiAgICAgKiA8L2lneC10cmVlLWdyaWQ+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBsb2FkQ2hpbGRyZW4gPSAocGFyZW50SUQ6IGFueSwgZG9uZTogKGNoaWxkcmVuOiBhbnlbXSkgPT4gdm9pZCkgPT4ge1xuICAgICAqICAgICB0aGlzLmRhdGFTZXJ2aWNlLmdldERhdGEocGFyZW50SUQsIGNoaWxkcmVuID0+IGRvbmUoY2hpbGRyZW4pKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgbG9hZENoaWxkcmVuT25EZW1hbmQ6IChwYXJlbnRJRDogYW55LCBkb25lOiAoY2hpbGRyZW46IGFueVtdKSA9PiB2b2lkKSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBsb2FkaW5nUm93czogU2V0PGFueT47XG4gICAgcHJpdmF0ZSBnZXQgX2dyaWRBUEkoKTtcbiAgICBwcml2YXRlIF9maWx0ZXJlZERhdGE7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGRyYWdJbmRpY2F0b3JJY29uQmFzZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICBuZ0RvQ2hlY2soKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBsb2FkQ2hpbGRyZW5PblJvd0V4cGFuc2lvbjtcbiAgICBwcml2YXRlIGFkZENoaWxkUm93cztcbiAgICBwcml2YXRlIGNsb25lTWFwO1xuICAgIGdldERlZmF1bHRFeHBhbmRTdGF0ZShyZWNvcmQ6IElUcmVlR3JpZFJlY29yZCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRXhwYW5kcyBhbGwgcm93cy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLmV4cGFuZEFsbCgpO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIGV4cGFuZEFsbCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENvbGxhcHNlcyBhbGwgcm93cy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLmNvbGxhcHNlQWxsKCk7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgY29sbGFwc2VBbGwoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBJZ3hUcmVlR3JpZFJvd0NvbXBvbmVudGAgd2l0aCB0aGUgZ2l2ZW4gZGF0YS4gSWYgYSBwYXJlbnRSb3dJRCBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgbmV3bHkgY3JlYXRlZFxuICAgICAqIHJvdyB3b3VsZCBiZSBhZGRlZCBhdCB0aGUgcm9vdCBsZXZlbC4gT3RoZXJ3aXNlLCBpdCB3b3VsZCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIHRoZSByb3cgd2hvc2UgcHJpbWFyeUtleSBtYXRjaGVzXG4gICAgICogdGhlIHNwZWNpZmllZCBwYXJlbnRSb3dJRC4gSWYgdGhlIHBhcmVudFJvd0lEIGRvZXMgbm90IGV4aXN0LCBhbiBlcnJvciB3b3VsZCBiZSB0aHJvd24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHJlY29yZCA9IHtcbiAgICAgKiAgICAgSUQ6IHRoaXMuZ3JpZC5kYXRhW3RoaXMuZ3JpZDEuZGF0YS5sZW5ndGggLSAxXS5JRCArIDEsXG4gICAgICogICAgIE5hbWU6IHRoaXMubmV3UmVjb3JkXG4gICAgICogfTtcbiAgICAgKiB0aGlzLmdyaWQuYWRkUm93KHJlY29yZCwgMSk7IC8vIEFkZHMgYSBuZXcgY2hpbGQgcm93IHRvIHRoZSByb3cgd2l0aCBJRD0xLlxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHBhcmFtIHBhcmVudFJvd0lEXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgYWRkUm93KGRhdGE6IGFueSwgcGFyZW50Um93SUQ/OiBhbnkpOiB2b2lkO1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgZGVsZXRlUm93QnlJZChyb3dJZDogYW55KTogdm9pZDtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGdlbmVyYXRlUm93UGF0aChyb3dJZDogYW55KTogYW55W107XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0RGF0YUJhc2VkQm9keUhlaWdodCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzY3JvbGxUbyhyb3c6IGFueSB8IG51bWJlciwgY29sdW1uOiBhbnkgfCBudW1iZXIpOiB2b2lkO1xuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICovXG4gICAgZ2V0Q29udGV4dChyb3dEYXRhOiBhbnksIHJvd0luZGV4OiBOdW1iZXIpOiBhbnk7XG4gICAgLyoqXG4gICAgICogQGluaGVyaXRkb2NcbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZERhdGEoZm9ybWF0dGVycz86IGJvb2xlYW4sIGhlYWRlcnM/OiBib29sZWFuKTogYW55W107XG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgICBnZXQgdGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICBwcm90ZWN0ZWQgd3JpdGVUb0RhdGEocm93SW5kZXg6IG51bWJlciwgdmFsdWU6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICovXG4gICAgcHJvdGVjdGVkIGluaXRDb2x1bW5zKGNvbGxlY3Rpb246IFF1ZXJ5TGlzdDxJZ3hDb2x1bW5Db21wb25lbnQ+LCBjYj86IEZ1bmN0aW9uKTogdm9pZDtcbn1cbiJdfQ==