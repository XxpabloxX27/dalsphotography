import { AfterContentInit, AfterViewInit, ChangeDetectorRef, ComponentFactoryResolver, ElementRef, EventEmitter, IterableDiffers, NgZone, OnDestroy, OnInit, QueryList, TemplateRef, ViewContainerRef, InjectionToken, DoCheck } from '@angular/core';
import ResizeObserver from 'resize-observer-polyfill';
import { Subject } from 'rxjs';
import { DataType } from '../data-operations/data-util';
import { FilteringLogic } from '../data-operations/filtering-expression.interface';
import { IGroupByRecord } from '../data-operations/groupby-record.interface';
import { ISortingExpression } from '../data-operations/sorting-expression.interface';
import { IForOfState, IgxGridForOfDirective } from '../directives/for-of/for_of.directive';
import { IgxOverlayService } from '../services/index';
import { GridBaseAPIService } from './api.service';
import { IgxGridCellComponent } from './cell.component';
import { IColumnVisibilityChangedEventArgs } from './hiding/column-hiding-item.directive';
import { ISummaryExpression } from './summaries/grid-summary';
import { IgxGridToolbarComponent } from './toolbar/grid-toolbar.component';
import { IgxRowDirective } from './row.directive';
import { IgxGridHeaderComponent } from './headers/grid-header.component';
import { IgxOverlayOutletDirective, IgxToggleDirective } from '../directives/toggle/toggle.directive';
import { IFilteringExpressionsTree } from '../data-operations/filtering-expressions-tree';
import { IFilteringOperation } from '../data-operations/filtering-condition';
import { Transaction, TransactionService, State } from '../services/index';
import { IgxRowEditTabStopDirective } from './grid.rowEdit.directive';
import { IgxGridNavigationService } from './grid-navigation.service';
import { IDisplayDensityOptions, DisplayDensityBase } from '../core/displayDensity';
import { IgxFilteringService } from './filtering/grid-filtering.service';
import { IgxGridFilteringCellComponent } from './filtering/base/grid-filtering-cell.component';
import { IgxGridHeaderGroupComponent } from './headers/grid-header-group.component';
import { IGridResourceStrings } from '../core/i18n/grid-resources';
import { IgxGridSummaryService } from './summaries/grid-summary.service';
import { IgxSummaryRowComponent } from './summaries/summary-row.component';
import { IgxGridSelectionService, GridSelectionRange, IgxGridCRUDService, IgxRow } from './selection/selection.service';
import { DragScrollDirection } from './selection/drag-select.directive';
import { ICachedViewLoadedEventArgs } from '../directives/template-outlet/template_outlet.directive';
import { IgxExcelStyleLoadingValuesTemplateDirective } from './filtering/excel-style/excel-style-search.component';
import { IgxExcelStyleSortingTemplateDirective, IgxExcelStylePinningTemplateDirective, IgxExcelStyleHidingTemplateDirective, IgxExcelStyleMovingTemplateDirective } from './filtering/excel-style/grid.excel-style-filtering.component';
import { IgxGridColumnResizerComponent } from './resizing/resizer.component';
import { IgxGridFilteringRowComponent } from './filtering/base/grid-filtering-row.component';
import { IgxColumnResizingService } from './resizing/resizing.service';
import { IFilteringStrategy } from '../data-operations/filtering-strategy';
import { GridSelectionMode, GridSummaryPosition, GridSummaryCalculationMode, FilterMode } from './common/enums';
import { IGridCellEventArgs, IRowSelectionEventArgs, IPinColumnEventArgs, IGridEditEventArgs, IPageEventArgs, IRowDataEventArgs, IColumnResizeEventArgs, IColumnMovingStartEventArgs, IColumnMovingEventArgs, IColumnMovingEndEventArgs, IGridKeydownEventArgs, IRowDragStartEventArgs, IRowDragEndEventArgs, IGridClipboardEvent, IGridToolbarExportEventArgs, ISearchInfo, ICellPosition, IRowToggleEventArgs } from './common/events';
import { GridType } from './common/grid.interface';
import { DropPosition } from './moving/moving.service';
import { IgxHeadSelectorDirective, IgxRowSelectorDirective } from './selection/row-selectors';
import { IgxGridToolbarCustomContentDirective } from './toolbar/toolbar.directive';
import { IgxColumnComponent } from './columns/column.component';
import { IGridSortingStrategy } from '../data-operations/sorting-strategy';
import * as Éµngcc0 from '@angular/core';
export declare const IgxGridTransaction: InjectionToken<string>;
export declare class IgxGridBaseDirective extends DisplayDensityBase implements OnInit, DoCheck, OnDestroy, AfterContentInit, AfterViewInit {
    selectionService: IgxGridSelectionService;
    crudService: IgxGridCRUDService;
    colResizingService: IgxColumnResizingService;
    protected gridAPI: GridBaseAPIService<IgxGridBaseDirective & GridType>;
    protected _transactions: TransactionService<Transaction, State>;
    private elementRef;
    private zone;
    document: any;
    cdr: ChangeDetectorRef;
    protected resolver: ComponentFactoryResolver;
    protected differs: IterableDiffers;
    protected viewRef: ViewContainerRef;
    navigation: IgxGridNavigationService;
    filteringService: IgxFilteringService;
    protected overlayService: IgxOverlayService;
    summaryService: IgxGridSummaryService;
    protected _displayDensityOptions: IDisplayDensityOptions;
    private _scrollWidth;
    private _customDragIndicatorIconTemplate;
    protected _init: boolean;
    private _cdrRequests;
    protected _cdrRequestRepaint: boolean;
    get scrollWidth(): number;
    private _resourceStrings;
    private _emptyGridMessage;
    private _emptyFilteredGridMessage;
    private _isLoading;
    private _locale;
    _destroyed: boolean;
    private overlayIDs;
    private _filteringStrategy;
    private _sortingStrategy;
    private _hostWidth;
    private _advancedFilteringOverlayId;
    private _advancedFilteringPositionSettings;
    private _advancedFilteringOverlaySettings;
    /**
    * @hidden @internal
    */
    protected defaultExpandedTemplate: TemplateRef<any>;
    /**
    * @hidden @internal
    */
    protected defaultCollapsedTemplate: TemplateRef<any>;
    /**
     * Gets/Sets the resource strings.
     * @remarks
     * By default it uses EN resources.
    */
    set resourceStrings(value: IGridResourceStrings);
    get resourceStrings(): IGridResourceStrings;
    /**
     * Gets/Sets whether to autogenerate the columns.
     * @remarks
     * The default value is false. When set to true, it will override all columns declared through code or in markup.
     * @example
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
     * ```
     */
    autoGenerate: boolean;
    /**
    * @hidden @internal
    */
    id: string;
    /**
     * Gets/Sets a custom template when empty.
     * @example
     * ```html
     * <igx-grid [id]="'igx-grid-1'" [data]="Data" [emptyGridTemplate]="myTemplate" [autoGenerate]="true"></igx-grid>
     * ```
     */
    emptyGridTemplate: TemplateRef<any>;
    /**
     * Gets/Sets a custom template when loading.
     * @example
     * ```html
     * <igx-grid [id]="'igx-grid-1'" [data]="Data" [loadingGridTemplate]="myTemplate" [autoGenerate]="true"></igx-grid>
     * ```
     */
    loadingGridTemplate: TemplateRef<any>;
    /**
     * Gets/Sets the filtering logic of the `IgxGridComponent`.
     * @remarks
     * The default is AND.
     * @example
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true" [filteringLogic]="filtering"></igx-grid>
     * ```
     */
    get filteringLogic(): FilteringLogic;
    set filteringLogic(value: FilteringLogic);
    /**
     * Gets/Sets the filtering state.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(filteringExpressionsTree)]="model.filteringExpressions"></igx-grid>
     * ```
     * @remarks
     * Supports two-way binding.
     */
    get filteringExpressionsTree(): IFilteringExpressionsTree;
    set filteringExpressionsTree(value: IFilteringExpressionsTree);
    /**
     * Emitted after filtering is performed.
     * @remarks
     * Returns the filtering expressions tree of the column for which filtering was performed.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true"
     *              (filteringExpressionsTreeChange)="filteringExprTreeChange($event)"></igx-grid>
     * ```
    */
    filteringExpressionsTreeChange: EventEmitter<IFilteringExpressionsTree>;
    /**
     * Emitted after advanced filtering is performed.
     * @remarks
     * Returns the advanced filtering expressions tree.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true"
     *           (advancedFilteringExpressionsTreeChange)="advancedFilteringExprTreeChange($event)"></igx-grid>
     * ```
    */
    advancedFilteringExpressionsTreeChange: EventEmitter<IFilteringExpressionsTree>;
    /**
     * Gets/Sets the advanced filtering state.
     * @example
     * ```typescript
     * let advancedFilteringExpressionsTree = this.grid.advancedFilteringExpressionsTree;
     * this.grid.advancedFilteringExpressionsTree = logic;
     * ```
     */
    get advancedFilteringExpressionsTree(): IFilteringExpressionsTree;
    set advancedFilteringExpressionsTree(value: IFilteringExpressionsTree);
    /**
     * Gets/Sets the locale.
     * @remarks
     * If not set, returns browser's language.
     */
    get locale(): string;
    set locale(value: string);
    /**
     * Gets/Sets whether the paging feature is enabled.
     * @remarks
     * The default state is disabled (false).
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [paging]="true"></igx-grid>
     * ```
     */
    get paging(): boolean;
    set paging(value: boolean);
    /**
     * Gets/Sets the current page index.
    *@example
    * ```html
     * <igx-grid #grid [data]="Data" [paging]="true" [(page)]="model.page" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * Supports two-way binding.
     */
    get page(): number;
    set page(val: number);
    /**
     *@hidden @internal
     */
    pageChange: EventEmitter<number>;
    /**
     * Gets/Sets the number of visible items per page.
     * @remarks
     * The default is 15.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [paging]="true" [(perPage)]="model.perPage" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get perPage(): number;
    set perPage(val: number);
    /**
     *@hidden @internal
     */
    perPageChange: EventEmitter<number>;
    /**
     * Gets/Sets a custom `ng-template` for the pagination UI of the grid.
     * @example
     * ```html
     * <igx-grid #grid [paging]="true" [myTemplate]="myTemplate" [height]="'305px'"></igx-grid>
     * ```
     */
    paginationTemplate: TemplateRef<any>;
    /**
     * Gets/Sets whether the column hiding UI is enabled.
     * @remarks
     * By default it is disabled (false). In order for the UI to work, you need to enable the toolbar as shown in the example below.
     * @example
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true" [showToolbar]="true" [columnHiding]="true"></igx-grid>
     * ```
     */
    get columnHiding(): boolean;
    set columnHiding(value: boolean);
    get rowSelectable(): boolean;
    set rowSelectable(val: boolean);
    /**
     * Gets/Sets if the row selectors are hidden.
     * @remarks
     *  By default row selectors are shown
    */
    get hideRowSelectors(): boolean;
    set hideRowSelectors(value: boolean);
    /**
     * Gets/Sets whether rows can be moved.
     * @example
     * ```html
     * <igx-grid #grid [rowDraggable]="true"></igx-grid>
     * ```
     */
    get rowDraggable(): boolean;
    set rowDraggable(val: boolean);
    /**
     * @hidden
     * @internal
     */
    rowDragging: boolean;
    /**
    * Gets/Sets whether the rows are editable.
    * @remarks
    * By default it is set to false.
    * @example
    * ```html
    * <igx-grid #grid [showToolbar]="true" [rowEditable]="true" [primaryKey]="'ProductID'" [columnHiding]="true"></igx-grid>
    * ```
    */
    get rowEditable(): boolean;
    set rowEditable(val: boolean);
    /**
     * Gets/Sets the height.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get height(): string;
    set height(value: string);
    /**
     * @hidden @internal
    */
    get hostWidth(): any;
    /**
     * Gets/Sets the width of the grid.
     * @example
     * ```typescript
     * let gridWidth = this.grid.width;
     * ```
     */
    get width(): string;
    set width(value: string);
    /**
     * Gets the width of the header.
     * @example
     * ```html
     * let gridHeaderWidth = this.grid.headerWidth;
     * ```
     */
    get headerWidth(): number;
    /**
     * Gets/Sets the styling classes applied to all even `IgxGridRowComponent`s in the grid.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-even-class'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    evenRowCSS: string;
    /**
     * Gets/Sets the styling classes applied to all odd `IgxGridRowComponent`s in the grid.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-odd-class'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    oddRowCSS: string;
    /**
     * Gets/Sets the row height.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [showToolbar]="true" [rowHeight]="100" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get rowHeight(): any;
    set rowHeight(value: any);
    /**
     * Gets/Sets the default width of the columns.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [showToolbar]="true" [columnWidth]="100" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get columnWidth(): string;
    set columnWidth(value: string);
    /**
     * Gets/Sets the primary key.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [showToolbar]="true" [primaryKey]="'ProductID'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    primaryKey: any;
    /**
     * Get/Sets the message displayed when there are no records.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    set emptyGridMessage(value: string);
    get emptyGridMessage(): string;
    /**
     * Gets/Sets whether the grid is going to show a loading indicator.
     *@example
     * ```html
     * <igx-grid #grid [data]="Data" [isLoading]="true" [autoGenerate]="true"></igx-grid>
     * ```
     */
    set isLoading(value: boolean);
    get isLoading(): boolean;
    /**
     * Gets/Sets whether the columns should be auto-generated once again after the initialization of the grid
     * @remarks
     * This will allow to bind the grid to remote data and having auto-generated columns at the same time.
     * Note that after generating the columns, this property would be disabled to avoid re-creating
     * columns each time a new data is assigned.
     * @example
     * ```typescript
     *  this.grid.shouldGenerate = true;
     * ```
     */
    shouldGenerate: boolean;
    /**
     * Gets/Sets the message displayed when there are no records and the grid is filtered.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    set emptyFilteredGridMessage(value: string);
    get emptyFilteredGridMessage(): string;
    /**
     * Gets/Sets the title to be displayed in the built-in column hiding UI.
     * @example
     * ```html
     * <igx-grid [showToolbar]="true" [columnHiding]="true" columnHidingTitle="Column Hiding"></igx-grid>
     * ```
     */
    columnHidingTitle: string;
    /**
     * Gets/Sets if the built-in column pinning UI should be shown in the toolbar.
     * @example
    * ```html
     * <igx-grid #grid [data]="localData" [columnPinning]="'true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get columnPinning(): boolean;
    set columnPinning(value: boolean);
    /**
     * Gets/Sets the title to be displayed in the UI of the column pinning.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [columnPinning]="'true" [columnPinningTitle]="'Column Hiding'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    columnPinningTitle: string;
    /**
     * Gets/Sets if the filtering is enabled.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [allowFiltering]="true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get allowFiltering(): boolean;
    set allowFiltering(value: boolean);
    /**
     * Gets/Sets a value indicating whether the advanced filtering is enabled.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [allowAdvancedFiltering]="true" [showToolbar]="true" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get allowAdvancedFiltering(): boolean;
    set allowAdvancedFiltering(value: boolean);
    /**
     * Gets/Sets the filter mode.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [filterMode]="'quickFilter'" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * By default it's set to FilterMode.quickFilter.
     */
    get filterMode(): FilterMode;
    set filterMode(value: FilterMode);
    /**
     * Gets/Sets the summary position.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" summaryPosition="top" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * By default it is bottom.
     */
    get summaryPosition(): GridSummaryPosition;
    set summaryPosition(value: GridSummaryPosition);
    /**
     * Gets/Sets the summary calculation mode.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" summaryCalculationMode="rootLevelOnly" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * By default it is rootAndChildLevels which means the summaries are calculated for the root level and each child level.
     */
    get summaryCalculationMode(): GridSummaryCalculationMode;
    set summaryCalculationMode(value: GridSummaryCalculationMode);
    /**
     * Gets/Sets the filtering strategy of the grid.
     * @example
     * ```html
     *  <igx-grid #grid [data]="localData" [filterStrategy]="filterStrategy"></igx-grid>
     * ```
     */
    get filterStrategy(): IFilteringStrategy;
    set filterStrategy(classRef: IFilteringStrategy);
    /**
     * Gets/Sets the sorting strategy of the grid.
     * @example
     * ```html
     *  <igx-grid #grid [data]="localData" [sortStrategy]="sortStrategy"></igx-grid>
     * ```
     */
    get sortStrategy(): IGridSortingStrategy;
    set sortStrategy(value: IGridSortingStrategy);
    /**
     * Gets/Sets a unique values strategy used by the Excel Style Filtering
     * @remarks
     * Provides a callback for loading unique column values on demand.
     * If this property is provided, the unique values it generates will be used by the Excel Style Filtering.
     * @example
     * ```html
     * <igx-grid [data]="localData" [filterMode]="'excelStyleFilter'" [uniqueColumnValuesStrategy]="columnValuesStrategy"></igx-grid>
     * ```
     */
    uniqueColumnValuesStrategy: (column: IgxColumnComponent, filteringExpressionsTree: IFilteringExpressionsTree, done: (values: any[]) => void) => void;
    /**
     * Emitted when `IgxGridCellComponent` is clicked.
     * @remarks
     * Returns the `IgxGridCellComponent`.
     * @example
     * ```html
     * <igx-grid #grid (onCellClick)="onCellClick($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    onCellClick: EventEmitter<IGridCellEventArgs>;
    /**
     * Emitted when `IgxGridCellComponent` is selected.
     * @remarks
     *  Returns the `IgxGridCellComponent`.
     * @example
     * ```html
     * <igx-grid #grid (onSelection)="onCellSelect($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    onSelection: EventEmitter<IGridCellEventArgs>;
    /**
     *  Emitted when `IgxGridRowComponent` is selected.
     * @example
     * ```html
     * <igx-grid #grid (onRowSelectionChange)="onCellClickChange($event)" [data]="localData" [autoGenerate]="true"></igx-grid>
     * ```
     */
    onRowSelectionChange: EventEmitter<IRowSelectionEventArgs>;
    /**
     * Emitted when `IgxColumnComponent` is pinned.
     * @remarks
     * The index that the column is inserted at may be changed through the `insertAtIndex` property.
     * @example
     * ```typescript
     * public columnPinning(event) {
     *     if (event.column.field === "Name") {
     *       event.insertAtIndex = 0;
     *     }
     * }
     * ```
     */
    onColumnPinning: EventEmitter<IPinColumnEventArgs>;
    /**
     * Emitted when editing and **not** submitting the value.
     * @remarks
     * (e.g. `Esc` key was pressed)
     * This event is cancelable.
     *@example
     * ```html
     * <igx-grid #grid3 (onCellEditCancel)="editCancel($event)" [data]="data" [primaryKey]="'ProductID'">
     * </igx-grid>
     * ```
     */
    onCellEditCancel: EventEmitter<IGridEditEventArgs>;
    /**
     * Emitted when cell enters edit mode.
     * @remarks
     * This event is cancelable.
     *@example
     * ```html
     * <igx-grid #grid3 (onCellEditEnter)="editStart($event)" [data]="data" [primaryKey]="'ProductID'">
     * </igx-grid>
     * ```
     */
    onCellEditEnter: EventEmitter<IGridEditEventArgs>;
    /**
     * Emitted when cell has been edited.
     * @remarks
     * Event is fired after editing is completed, when the cell is exiting edit mode.
     * This event is cancelable.
     * @example
     * ```html
     * <igx-grid #grid3 (onCellEdit)="editDone($event)" [data]="data" [primaryKey]="'ProductID'">
     * </igx-grid>
     * ```
     */
    onCellEdit: EventEmitter<IGridEditEventArgs>;
    /**
     * Emitted when a row enters edit mode.
     * @remarks
     * Emitted when [rowEditable]="true".
     * This event is cancelable.
     *@example
     * ```html
     * <igx-grid #grid3 (onRowEditEnter)="editStart($event)" [primaryKey]="'ProductID'" [rowEditable]="true">
     * </igx-grid>
     * ```
     */
    onRowEditEnter: EventEmitter<IGridEditEventArgs>;
    /**
     * Emitted when exiting edit mode for a row.
     * @remarks
     * Emitted when [rowEditable]="true" & `endEdit(true)` is called.
     * Emitted when changing rows during edit mode, selecting an un-editable cell in the edited row,
     * performing paging operation, column resizing, pinning, moving or hitting  `Done`
     * button inside of the rowEditingOverlay, or hitting the `Enter` key while editing a cell.
     * This event is cancelable.
     *@example
     * ```html
     * <igx-grid #grid3 (onRowEdit)="editDone($event)" [data]="data" [primaryKey]="'ProductID'" [rowEditable]="true">
     * </igx-grid>
     * ```
     */
    onRowEdit: EventEmitter<IGridEditEventArgs>;
    /**
     * Emitted when row editing is canceled.
     * @remarks
     * Emits when [rowEditable]="true" & `endEdit(false)` is called.
     * Emitted when changing hitting `Esc` key during cell editing and when click on the `Cancel` button
     * in the row editing overlay.
     * This event is cancelable.
     *@example
     * ```html
     * <igx-grid #grid3 (onRowEditCancel)="editCancel($event)" [data]="data" [primaryKey]="'ProductID'" [rowEditable]="true">
     * </igx-grid>
     * ```
     */
    onRowEditCancel: EventEmitter<IGridEditEventArgs>;
    /**
     * Emitted when a column is initialized.
     * @remarks
     * Returns the column object.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [onColumnInit]="initColumns($event)" [autoGenerate]="true"></igx-grid>
     * ```
     */
    onColumnInit: EventEmitter<IgxColumnComponent>;
    /**
     * Emitted when sorting is performed through the UI.
     * @remarks
     * Returns the sorting expression.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [autoGenerate]="true" (onSortingDone)="sortingDone($event)"></igx-grid>
     * ```
     */
    onSortingDone: EventEmitter<ISortingExpression | ISortingExpression[]>;
    /**
     * Emitted when filtering is performed through the UI.
     * @remarks
     * Returns the filtering expressions tree of the column for which filtering was performed.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onFilteringDone)="filteringDone($event)"></igx-grid>
     * ```
     */
    onFilteringDone: EventEmitter<IFilteringExpressionsTree>;
    /**
     * Emitted when paging is performed.
     * @remarks
     * Returns an object consisting of the previous and next pages.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onPagingDone)="pagingDone($event)"></igx-grid>
     * ```
     */
    onPagingDone: EventEmitter<IPageEventArgs>;
    /**
     * Emitted when a row added through the API.
     * @remarks
     * Returns the data for the new `IgxGridRowComponent` object.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" (onRowAdded)="rowAdded($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    onRowAdded: EventEmitter<IRowDataEventArgs>;
    /**
     * Emitted when a row is deleted through API.
     * @remarks
     * Returns an `IRowDataEventArgs` object.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" (onRowDeleted)="rowDeleted($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    onRowDeleted: EventEmitter<IRowDataEventArgs>;
    /**
     * Emitted when a new chunk of data is loaded from virtualization.
     * @example
     * ```typescript
     *  <igx-grid #grid [data]="localData" [autoGenerate]="true" (onDataPreLoad)='handleDataPreloadEvent()'></igx-grid>
     * ```
     */
    onDataPreLoad: EventEmitter<IForOfState>;
    /**
     * Emitted when column is resized.
     * @remarks
     * Returns the `IgxColumnComponent` object's old and new width.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" (onColumnResized)="resizing($event)" [autoGenerate]="true"></igx-grid>
     * ```
     */
    onColumnResized: EventEmitter<IColumnResizeEventArgs>;
    /**
     * Emitted when a cell is right clicked.
     * @remarks
     * Returns the `IgxGridCellComponent` object.
     * ```html
     * <igx-grid #grid [data]="localData" (onContextMenu)="contextMenu($event)" [autoGenerate]="true"></igx-grid>
     * ```
     */
    onContextMenu: EventEmitter<IGridCellEventArgs>;
    /**
     * Emitted when a cell is double clicked.
     * @remarks
     * Returns the `IgxGridCellComponent` object.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" (onDoubleClick)="dblClick($event)" [autoGenerate]="true"></igx-grid>
     * ```
     */
    onDoubleClick: EventEmitter<IGridCellEventArgs>;
    /**
     * Emitted when column visibility is changed.
     * @remarks
     * Args: { column: any, newValue: boolean }
     * @example
     * ```html
     * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnVisibilityChanged)="visibilityChanged($event)"></igx-grid>
     * ```
     */
    onColumnVisibilityChanged: EventEmitter<IColumnVisibilityChangedEventArgs>;
    /**
     * Emitted when column moving starts.
     * @remarks
     * Returns the moved `IgxColumnComponent` object.
     * @example
     * ```html
     * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingStart)="movingStart($event)"></igx-grid>
     * ```
     */
    onColumnMovingStart: EventEmitter<IColumnMovingStartEventArgs>;
    /**
     * Emitted during the column moving operation.
     * @remarks
     * Returns the source and target `IgxColumnComponent` objects. This event is cancelable.
     * @example
     * ```html
     * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMoving)="moving($event)"></igx-grid>
     * ```
     */
    onColumnMoving: EventEmitter<IColumnMovingEventArgs>;
    /**
     * Emitted when column moving ends.
     * @remarks
     * Returns the source and target `IgxColumnComponent` objects.
     * @example
     * ```html
     * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingEnd)="movingEnds($event)"></igx-grid>
     * ```
     */
    onColumnMovingEnd: EventEmitter<IColumnMovingEndEventArgs>;
    /**
     * Emitted when keydown is triggered over element inside grid's body.
     * @remarks
     * This event is fired only if the key combination is supported in the grid.
     * Return the target type, target object and the original event. This event is cancelable.
     * @example
     * ```html
     *  <igx-grid (onGridKeydown)="customKeydown($event)"></igx-grid>
     * ```
     */
    onGridKeydown: EventEmitter<IGridKeydownEventArgs>;
    /**
     * Emitted when start dragging a row.
     * @remarks
     * Return the dragged row.
     */
    onRowDragStart: EventEmitter<IRowDragStartEventArgs>;
    /**
     * Emitted when dropping a row.
     * @remarks
     * Return the dropped row.
     */
    onRowDragEnd: EventEmitter<IRowDragEndEventArgs>;
    /**
     * Emitted when a copy operation is executed.
     * @remarks
     * Fired only if copy behavior is enabled through the [`clipboardOptions`]{@link IgxGridBaseDirective#clipboardOptions}.
     */
    onGridCopy: EventEmitter<IGridClipboardEvent>;
    /**
     *@hidden @internal
     */
    expansionStatesChange: EventEmitter<Map<any, boolean>>;
    /**
     * Emitted when the expanded state of a row gets changed.
     * @example
     * ```html
     * <igx-grid [data]="employeeData" (onRowToggle)="rowToggle($event)" [autoGenerate]="true"></igx-grid>
     * ```
     */
    onRowToggle: EventEmitter<IRowToggleEventArgs>;
    /**
     * @hidden @internal
     */
    resizeLine: IgxGridColumnResizerComponent;
    /**
     * @hidden @internal
     */
    loadingOverlay: ElementRef;
    /**
     * @hidden @internal
     */
    loadingOutlet: IgxOverlayOutletDirective;
    /**
     * @hidden @internal
     */
    columnList: QueryList<IgxColumnComponent>;
    /**
     *@hidden @internal
     */
    excelStyleSortingTemplateDirective: IgxExcelStyleSortingTemplateDirective;
    /**
     *@hidden @internal
     */
    excelStyleMovingTemplateDirective: IgxExcelStyleMovingTemplateDirective;
    /**
     *@hidden @internal
     */
    excelStyleHidingTemplateDirective: IgxExcelStyleHidingTemplateDirective;
    /**
     *@hidden @internal
     */
    excelStylePinningTemplateDirective: IgxExcelStylePinningTemplateDirective;
    /**
     *@hidden @internal
     */
    excelStyleLoadingValuesTemplateDirective: IgxExcelStyleLoadingValuesTemplateDirective;
    /**
     * @hidden @internal
     */
    headerGroups: QueryList<IgxGridHeaderGroupComponent>;
    /**
     * A list of all `IgxGridHeaderGroupComponent`.
     * @example
     * ```typescript
     * const headerGroupsList = this.grid.headerGroupsList;
     * ```
     */
    get headerGroupsList(): IgxGridHeaderGroupComponent[];
    /**
     * A list of all `IgxGridHeaderComponent`.
     * @example
     * ```typescript
     * const headers = this.grid.headerCellList;
     * ```
     */
    get headerCellList(): IgxGridHeaderComponent[];
    /**
     * A list of all `IgxGridFilteringCellComponent`.
     * @example
     * ```typescript
     * const filterCells = this.grid.filterCellList;
     * ```
     */
    get filterCellList(): IgxGridFilteringCellComponent[];
    private _rowList;
    protected _summaryRowList: QueryList<IgxSummaryRowComponent>;
    /**
     * @hidden @internal
    */
    get summariesRowList(): QueryList<any>;
    /**
     * A list of `IgxGridRowComponent`.
     * @example
     * ```typescript
     * const rowList = this.grid.rowList;
     * ```
     */
    get rowList(): QueryList<any>;
    private _dataRowList;
    /**
     * A list of currently rendered `IgxGridRowComponent`'s.
     * @example
     * ```typescript
     * const dataList = this.grid.dataRowList;
     * ```
     */
    get dataRowList(): QueryList<IgxRowDirective<IgxGridBaseDirective>>;
    /**
     * A template reference for the template when the filtered grid is empty.
     * @example
     * ```
     * const emptyTempalte = this.grid.emptyGridTemplate;
     * ```
     */
    emptyFilteredGridTemplate: TemplateRef<any>;
    /**
     * A template reference for the template when the grid is empty.
     * @example
     * ```
     * const emptyTempalte = this.grid.emptyGridTemplate;
     * ```
     */
    emptyGridDefaultTemplate: TemplateRef<any>;
    /**
     * @hidden @internal
    */
    loadingGridDefaultTemplate: TemplateRef<any>;
    /**
     * @hidden @internal
     */
    parentVirtDir: IgxGridForOfDirective<any>;
    /**
     * Returns the template which will be used by the toolbar to show custom content.
     * @example
     * ```typescript
     * let customContentTemplate = this.grid.toolbarCustomContentTemplate;
     * ```
    */
    get toolbarCustomContentTemplate(): IgxGridToolbarCustomContentDirective;
    /**
     * @hidden
     * @internal
     */
    toolbarCustomContentTemplates: QueryList<IgxGridToolbarCustomContentDirective>;
    /**
     * @hidden
     * @internal
     */
    get headSelectorTemplate(): TemplateRef<IgxHeadSelectorDirective>;
    /**
     * @hidden
     * @internal
     */
    headSelectorsTemplates: QueryList<IgxHeadSelectorDirective>;
    /**
     * @hidden
     * @internal
     */
    get rowSelectorTemplate(): TemplateRef<IgxRowSelectorDirective>;
    /**
     * @hidden
     * @internal
     */
    rowSelectorsTemplates: QueryList<IgxRowSelectorDirective>;
    /**
     * @hidden
     * @internal
     */
    dragGhostCustomTemplates: QueryList<TemplateRef<any>>;
    /**
     * @hidden @internal
     */
    verticalScrollContainer: IgxGridForOfDirective<any>;
    /**
     * @hidden @internal
     */
    verticalScroll: IgxGridForOfDirective<any>;
    /**
     * @hidden @internal
     */
    scr: ElementRef;
    /**
     * @hidden @internal
     */
    footer: ElementRef;
    /**
     * @hidden @internal
     */
    headerContainer: IgxGridForOfDirective<any>;
    /**
     * @hidden @internal
     */
    headerSelectorContainer: ElementRef;
    /**
     * @hidden @internal
     */
    headerDragContainer: ElementRef;
    /**
     * @hidden @internal
     */
    headerGroupContainer: ElementRef;
    /**
     * @hidden @internal
     */
    filteringRow: IgxGridFilteringRowComponent;
    /**
     * @hidden @internal
     */
    theadRow: ElementRef;
    /**
     * @hidden @internal
     */
    tbody: ElementRef;
    /**
     * @hidden @internal
    */
    tfoot: ElementRef;
    /**
     * @hidden @internal
     */
    protected _outletDirective: IgxOverlayOutletDirective;
    /**
     * @hidden @internal
     */
    get outletDirective(): IgxOverlayOutletDirective;
    /**
     * @hidden @internal
     */
    rowEditingOutletDirective: IgxOverlayOutletDirective;
    /**
     * @hidden @internal
    */
    tmpOutlets: QueryList<any>;
    /**
     * @hidden @internal
    */
    get rowOutletDirective(): IgxOverlayOutletDirective;
    /**
     * @hidden @internal
    */
    get parentRowOutletDirective(): IgxOverlayOutletDirective;
    /**
     * @hidden
     * @internal
     */
    dragIndicatorIconBase: TemplateRef<any>;
    /**
     * @hidden @internal
    */
    private defaultRowEditTemplate;
    /**
     * @hidden @internal
    */
    rowEditCustom: TemplateRef<any>;
    /**
     * @hidden @internal
     */
    get rowEditContainer(): TemplateRef<any>;
    /**
     * @hidden @internal
     */
    rowEditText: TemplateRef<any>;
    /**
     * @hidden @internal
     */
    rowEditActions: TemplateRef<any>;
    /**
    * The custom template, if any, that should be used when rendering a row expand indicator.
    */
    rowExpandedIndicatorTemplate: TemplateRef<any>;
    /**
    * The custom template, if any, that should be used when rendering a row collapse indicator.
    */
    rowCollapsedIndicatorTemplate: TemplateRef<any>;
    /**
    * The custom template, if any, that should be used when rendering a header expand indicator.
    */
    headerExpandIndicatorTemplate: TemplateRef<any>;
    /**
    * The custom template, if any, that should be used when rendering a header collapse indicator.
    */
    headerCollapseIndicatorTemplate: TemplateRef<any>;
    /**
     * @hidden
     * @internal
     */
    dragIndicatorIconTemplates: QueryList<TemplateRef<any>>;
    /**
    * The custom template, if any, that should be used when rendering the row drag indicator icon
    */
    get dragIndicatorIconTemplate(): TemplateRef<any>;
    set dragIndicatorIconTemplate(val: TemplateRef<any>);
    /**
     * @hidden @internal
    */
    get rowInEditMode(): IgxRowDirective<IgxGridBaseDirective & GridType>;
    /**
     * @hidden @internal
     */
    get firstEditableColumnIndex(): number;
    /**
     * @hidden @internal
     */
    get lastEditableColumnIndex(): number;
    /**
     * @hidden @internal
     */
    rowEditTabsDEFAULT: QueryList<IgxRowEditTabStopDirective>;
    /**
     * @hidden @internal
     */
    rowEditTabsCUSTOM: QueryList<IgxRowEditTabStopDirective>;
    /**
     * @hidden @internal
     * TODO: Nav service logic doesn't handle 0 results from this querylist
     */
    get rowEditTabs(): QueryList<IgxRowEditTabStopDirective>;
    /**
     * @hidden @internal
     */
    rowEditingOverlay: IgxToggleDirective;
    /**
     * @hidden @internal
     */
    tabindex: number;
    /**
     * @hidden @internal
     */
    get hostClass(): string;
    get bannerClass(): string;
    /**
     * @hidden @internal
     */
    hostRole: string;
    /**
     * @hidden @internal
     */
    get pipeTrigger(): number;
    /**
     * @hidden @internal
     */
    get filteringPipeTrigger(): number;
    /**
     * @hidden @internal
     */
    get summaryPipeTrigger(): number;
    /**
     * Gets/Sets the sorting state.
     * @remarks
     * Supports two-way data binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(sortingExpressions)]="model.sortingExpressions"></igx-grid>
     * ```
     */
    get sortingExpressions(): ISortingExpression[];
    set sortingExpressions(value: ISortingExpression[]);
    /**
     * Emitted before sorting is performed.
     * @remarks
     * Returns the sorting expressions.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [autoGenerate]="true" (sortingExpressionsChange)="sortingExprChange($event)"></igx-grid>
     * ```
    */
    sortingExpressionsChange: EventEmitter<ISortingExpression[]>;
    /**
     * @hidden @internal
     */
    get maxLevelHeaderDepth(): any;
    /**
     * Gets the number of hidden columns.
     * @example
     * ```typescript
     * const hiddenCol = this.grid.hiddenColumnsCount;
     * ``
     */
    get hiddenColumnsCount(): number;
    /**
     * Gets/Sets the text to be displayed inside the toggle button.
     * @remarks
     * Used for the built-in column hiding UI of the`IgxColumnComponent`.
     * @example
     * ```html
     * <igx-grid [columnHiding]="true" [showToolbar]="true" [hiddenColumnsText]="'Hidden Columns'"></igx-grid>
     * ```
     */
    get hiddenColumnsText(): string;
    set hiddenColumnsText(value: string);
    /**
     * Gets/Sets the text to be displayed inside the toggle button.
     * @remarks
     * Used for the built-in column pinning UI of the`IgxColumnComponent`.
     * @example
     * ```html
     * <igx-grid [pinnedColumnsText]="'PinnedCols Text" [data]="data" [width]="'100%'" [height]="'500px'"></igx-grid>
     * ```
     */
    get pinnedColumnsText(): string;
    set pinnedColumnsText(value: string);
    /**
     * Get transactions service for the grid.
     */
    get transactions(): TransactionService<Transaction, State>;
    /**
     * @hidden @internal
    */
    columnsWithNoSetWidths: any;
    private _showToolbar;
    private _exportExcel;
    private _exportCsv;
    private _toolbarTitle;
    private _exportText;
    private _exportExcelText;
    private _exportCsvText;
    private _rowEditable;
    private _currentRowState;
    private _filteredSortedData;
    /**
     * @hidden @internal
    */
    get currentRowState(): any;
    /**
     * Provides access to the `IgxToolbarComponent`.
     * @example
     * ```typescript
     * const gridToolbar = this.grid.toolbar;
     * ```
     */
    toolbar: IgxGridToolbarComponent;
    private toolbarHtml;
    /**
     * Gets/Sets whether the toolbar is shown.
     * @example
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" ></igx-grid>
     * ```
     */
    get showToolbar(): boolean;
    set showToolbar(newValue: boolean);
    /**
     * Gets/Sets the toolbar's title.
     * @example
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [toolbarTitle]="'My Grid'"></igx-grid>
     * ```
     */
    get toolbarTitle(): string;
    set toolbarTitle(newValue: string);
    /**
     * Gets/Sets whether exporting to MS Excel is enabled or disabled.
     * @example
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportExcel]="true"></igx-grid>
     * ```
     */
    get exportExcel(): boolean;
    set exportExcel(newValue: boolean);
    /**
     * Gets/Sets whether the option for exporting to CSV is enabled or disabled.
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportCsv]="true"></igx-grid>
     * ```
     */
    get exportCsv(): boolean;
    set exportCsv(newValue: boolean);
    /**
     * Gets/Sets the textual content for the main export button.
     * @example
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
     * ```
     */
    get exportText(): string;
    set exportText(newValue: string);
    /**
     * Gets/Sets the textual content for the MS Excel export button.
     * ```html
     * <igx-grid [exportExcelText]="'My Excel Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
     * ```
     */
    get exportExcelText(): string;
    set exportExcelText(newValue: string);
    /**
     * Gets/Sets the textual content for the CSV export button.
     * @example
     * ```html
     * <igx-grid [exportCsvText]="'My Csv Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportExcel]="true"></igx-grid>
     * ```
     */
    get exportCsvText(): string;
    set exportCsvText(newValue: string);
    /**
     * Controls the copy behavior of the grid.
     */
    clipboardOptions: {
        /**
         * Enables/disables the copy behavior
         */
        enabled: boolean;
        /**
         * Include the columns headers in the clipboard output.
         */
        copyHeaders: boolean;
        /**
         * Apply the columns formatters (if any) on the data in the clipboard output.
         */
        copyFormatters: boolean;
        /**
         * The separator used for formatting the copy output. Defaults to `\t`.
         */
        separator: string;
    };
    /**
     * Gets/Sets cell selection mode.
     * @remarks
     * By default the cell selection mode is multiple
     * @param selectionMode: GridSelectionMode
    */
    get cellSelection(): GridSelectionMode;
    set cellSelection(selectionMode: GridSelectionMode);
    /**
     * Gets/Sets row selection mode
     * @remarks
     * By default the row selection mode is none
     * @param selectionMode: GridSelectionMode
    */
    get rowSelection(): GridSelectionMode;
    set rowSelection(selectionMode: GridSelectionMode);
    /**
     * @hidden @internal
     */
    rowEditMessage: any;
    /**
     * Emitted when an export process is initiated by the user.
     * @example
     * ```typescript
     * toolbarExporting(event: IGridToolbarExportEventArgs){
     *     const toolbarExporting = event;
     * }
     * ```
     */
    onToolbarExporting: EventEmitter<IGridToolbarExportEventArgs>;
    /**
     * Emitted when making a range selection.
     * @remarks
     * Range selection can be made either through drag selection or through keyboard selection.
     */
    onRangeSelection: EventEmitter<GridSelectionRange>;
    /**
     * @hidden @internal
     */
    pagingState: any;
    /**
     * @hidden @internal
     */
    calcWidth: number;
    /**
     * @hidden @internal
     */
    calcHeight: number;
    /**
     * @hidden @internal
     */
    tfootHeight: number;
    /**
     * @hidden @internal
     */
    chipsGoupingExpressions: any[];
    /**
     * @hidden @internal
     */
    summariesHeight: number;
    /**
     * @hidden @internal
     */
    draggedColumn: IgxColumnComponent;
    /**
     * @hidden @internal
     */
    disableTransitions: boolean;
    /**
     * @hidden @internal
     */
    lastSearchInfo: ISearchInfo;
    /**
     * @hidden @internal
     */
    columnWidthSetByUser: boolean;
    data: any[];
    filteredData: any[];
    /**
     * @hidden
     */
    protected destroy$: Subject<any>;
    /**
     * @hidden
     */
    protected _perPage: number;
    /**
     * @hidden
     */
    protected _page: number;
    /**
     * @hidden
     */
    protected _paging: boolean;
    /**
     * @hidden
     */
    protected _hideRowSelectors: boolean;
    /**
     * @hidden
     */
    protected _rowDrag: boolean;
    /**
     * @hidden
     */
    protected _pipeTrigger: number;
    /**
     * @hidden
     */
    protected _filteringPipeTrigger: number;
    /**
     * @hidden
     */
    protected _summaryPipeTrigger: number;
    /**
     * @hidden
     */
    protected _columns: IgxColumnComponent[];
    /**
     * @hidden
     */
    protected _pinnedColumns: IgxColumnComponent[];
    /**
     * @hidden
     */
    protected _unpinnedColumns: IgxColumnComponent[];
    /**
     * @hidden
     */
    protected _filteringExpressionsTree: IFilteringExpressionsTree;
    /**
     * @hidden
     */
    protected _advancedFilteringExpressionsTree: IFilteringExpressionsTree;
    /**
     * @hidden
     */
    protected _sortingExpressions: Array<ISortingExpression>;
    /**
     * @hidden
     */
    protected _maxLevelHeaderDepth: any;
    /**
     * @hidden
     */
    protected _columnHiding: boolean;
    /**
     * @hidden
     */
    protected _columnPinning: boolean;
    /**
     * @hidden
     */
    protected _hasVisibleColumns: any;
    protected _allowFiltering: boolean;
    protected _allowAdvancedFiltering: boolean;
    protected _filterMode: FilterMode;
    protected observer: ResizeObserver;
    protected resizeNotify: Subject<unknown>;
    private columnListDiffer;
    private _hiddenColumnsText;
    private _pinnedColumnsText;
    private _height;
    private _width;
    private _rowHeight;
    protected _baseFontSize: number;
    private _horizontalForOfs;
    private _multiRowLayoutRowSize;
    protected _loadingId: any;
    protected _expansionStates: Map<any, boolean>;
    protected _defaultExpandState: boolean;
    private _totalWidth;
    private _pinnedVisible;
    private _unpinnedVisible;
    private _pinnedWidth;
    private _unpinnedWidth;
    private _visibleColumns;
    private _columnGroups;
    private _autoGeneratedCols;
    protected _headerFeaturesWidth: number;
    private _columnWidth;
    protected _defaultTargetRecordNumber: number;
    private _summaryPosition;
    private _summaryCalculationMode;
    private _cellSelectionMode;
    private _rowSelectionMode;
    private rowEditPositioningStrategy;
    private rowEditSettings;
    private verticalScrollHandler;
    private horizontalScrollHandler;
    /**
    * @hidden
    * @internal
    */
    isDetailRecord(rec: any): boolean;
    /**
    * @hidden
    * @internal
    */
    isGroupByRecord(rec: any): boolean;
    /**
    * @hidden
    * @internal
    */
    get hasDetails(): boolean;
    /**
     * Returns the state of the grid virtualization.
     * @remarks
     * Includes the start index and how many records are rendered.
     * @example
     * ```typescript
     * const gridVirtState = this.grid1.virtualizationState;
     * ```
     */
    get virtualizationState(): IForOfState;
    /**
     * @hidden
     */
    set virtualizationState(state: IForOfState);
    /**
    * @hidden
    * @internal
    */
    hideOverlays(): void;
    private keydownHandler;
    constructor(selectionService: IgxGridSelectionService, crudService: IgxGridCRUDService, colResizingService: IgxColumnResizingService, gridAPI: GridBaseAPIService<IgxGridBaseDirective & GridType>, _transactions: TransactionService<Transaction, State>, elementRef: ElementRef, zone: NgZone, document: any, cdr: ChangeDetectorRef, resolver: ComponentFactoryResolver, differs: IterableDiffers, viewRef: ViewContainerRef, navigation: IgxGridNavigationService, filteringService: IgxFilteringService, overlayService: IgxOverlayService, summaryService: IgxGridSummaryService, _displayDensityOptions: IDisplayDensityOptions);
    _setupServices(): void;
    _setupListeners(): void;
    /**
     * @hidden
     */
    ngOnInit(): void;
    protected setupColumns(): void;
    /**
     * @hidden
     * @internal
     */
    resetColumnsCaches(): void;
    /**
     * @hidden
     * @internal
     */
    resetForOfCache(): void;
    /**
     * @hidden
     * @internal
     */
    resetColumnCollections(): void;
    /**
     * @hidden
     * @internal
     */
    resetCachedWidths(): void;
    /**
     * @hidden
     * @internal
     */
    resetCaches(recalcFeatureWidth?: boolean): void;
    /**
     * @hidden
     */
    ngAfterContentInit(): void;
    /**
     * @hidden @internal
     */
    _setupRowObservers(): void;
    /**
     * @hidden @internal
    */
    _zoneBegoneListeners(): void;
    /**
     * @hidden
     */
    ngAfterViewInit(): void;
    /**
     * @hidden @internal
    */
    notifyChanges(repaint?: boolean): void;
    protected resetNotifyChanges(): void;
    /**
     * @hidden @internal
    */
    ngDoCheck(): void;
    /**
     * @hidden
     * @internal
    */
    getDragGhostCustomTemplate(): TemplateRef<any>;
    /**
     * @hidden @internal
     */
    ngOnDestroy(): void;
    /**
     * @hidden @internal
    */
    dataLoading(event: any): void;
    /**
     * Toggles the specified column's visibility.
     * @example
     * ```typescript
     * this.grid1.toggleColumnVisibility({
     *       column: this.grid1.columns[0],
     *       newValue: true
     * });
     * ```
     */
    toggleColumnVisibility(args: IColumnVisibilityChangedEventArgs): void;
    /**
     * Gets/Sets a list of key-value pairs [row ID, expansion state].
     * @remarks
     * Includes only states that differ from the default one.
     * Supports two-way binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="data" [(expansionStates)]="model.expansionStates">
     * </igx-grid>
     * ```
     */
    get expansionStates(): Map<any, boolean>;
    set expansionStates(value: Map<any, boolean>);
    /**
      * Expands all rows.
      * @example
      * ```typescript
      * this.grid.expandAll();
      * ```
     */
    expandAll(): void;
    /**
      * Collapses all rows.
      * @example
      * ```typescript
      * this.grid.collapseAll();
      * ```
     */
    collapseAll(): void;
    /**
     * Expands the row by its id.
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.expandRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
     */
    expandRow(rowID: any): void;
    /**
     * Collapses the row by its id.
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.collapseRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
    */
    collapseRow(rowID: any): void;
    /**
     * Toggles the row by its id.
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.toggleRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
    */
    toggleRow(rowID: any): void;
    /**
     * @hidden
     * @internal
    */
    getDefaultExpandState(rec: any): boolean;
    /**
     * Gets the native element.
     * @example
     * ```typescript
     * const nativeEl = this.grid.nativeElement.
     * ```
     */
    get nativeElement(): any;
    /**
     * @hidden @internal
     */
    protected get outlet(): IgxOverlayOutletDirective;
    /**
     * Gets the default row height.
     * @example
     * ```typescript
     * const rowHeigh = this.grid.defaultRowHeight;
     * ```
     */
    get defaultRowHeight(): number;
    /**
     * @hidden @internal
     */
    get defaultSummaryHeight(): number;
    /**
     * Returns the `IgxGridHeaderGroupComponent`'s minimum allowed width.
     * @remarks
     * Used internally for restricting header group component width.
     * The values below depend on the header cell default right/left padding values.
     */
    get defaultHeaderGroupMinWidth(): number;
    /**
     * @hidden @internal
     */
    paginatorClassName(): string;
    /**
     * Gets the current width of the container for the pinned `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const pinnedWidth = this.grid.getPinnedWidth;
     * ```
     */
    get pinnedWidth(): number;
    /**
     * Gets the current width of the container for the unpinned `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const unpinnedWidth = this.grid.getUnpinnedWidth;
     * ```
     */
    get unpinnedWidth(): number;
    /**
     * @hidden @internal
    */
    get isHorizontalScrollHidden(): boolean;
    /**
     * @hidden @internal
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     */
    featureColumnsWidth(expander?: ElementRef): number;
    /**
     * @hidden @internal
    */
    get summariesMargin(): number;
    /**
     * Gets an array of `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const colums = this.grid.columns.
     * ```
     */
    get columns(): IgxColumnComponent[];
    /**
     * Gets an array of the pinned `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const pinnedColumns = this.grid.pinnedColumns.
     * ```
     */
    get pinnedColumns(): IgxColumnComponent[];
    /**
     * Gets an array of unpinned `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const unpinnedColumns = this.grid.unpinnedColumns.
     * ```
     */
    get unpinnedColumns(): IgxColumnComponent[];
    /**
     * Gets the `width` to be set on `IgxGridHeaderGroupComponent`.
     */
    getHeaderGroupWidth(column: IgxColumnComponent): string;
    /**
     * Returns the `IgxColumnComponent` by field name.
     * @example
     * ```typescript
     * const myCol = this.grid1.getColumnByName("ID");
     * ```
     * @param name
    */
    getColumnByName(name: string): IgxColumnComponent;
    /**
     * Returns the `IgxRowDirective` by index.
     * @example
     * ```typescript
     * const myRow = this.grid1.getRowByIndex(1);
     * ```
     * @param index
    */
    getRowByIndex(index: number): IgxRowDirective<IgxGridBaseDirective & GridType>;
    /**
     * Returns `IgxGridRowComponent` object by the specified primary key .
     * @remarks
     * Requires that the `primaryKey` property is set.
     * @example
     * ```typescript
     * const myRow = this.grid1.getRowByKey("cell5");
     * ```
     * @param keyValue
    */
    getRowByKey(keyValue: any): IgxRowDirective<IgxGridBaseDirective & GridType>;
    /**
     * Returns an array of visible `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const visibleColumns = this.grid.visibleColumns.
     * ```
     */
    get visibleColumns(): IgxColumnComponent[];
    /**
     * Returns the `IgxGridCellComponent` that matches the conditions.
     * @example
     * ```typescript
     * const myCell = this.grid1.getCellByColumn(2,"UnitPrice");
     * ```
     * @param rowIndex
     * @param columnField
    */
    getCellByColumn(rowIndex: number, columnField: string): IgxGridCellComponent;
    /**
     * Returns an `IgxGridCellComponent` object by the specified primary key and column field.
     * @remarks
     * Requires that the primaryKey property is set.
     * @example
     * ```typescript
     * grid.getCellByKey(1, 'index');
     * ```
     * @param rowSelector match any rowID
     * @param columnField
    */
    getCellByKey(rowSelector: any, columnField: string): IgxGridCellComponent;
    /**
     * Gets the total number of pages.
     * @example
     * ```typescript
     * const totalPages = this.grid.totalPages;
     * ```
     */
    get totalPages(): number;
    /**
     * Gets if the current page is the first page.
     * @example
     * ```typescript
     * const firstPage = this.grid.isFirstPage;
     * ```
     */
    get isFirstPage(): boolean;
    /**
     * Goes to the next page, if the grid is not already at the last page.
     * @example
     * ```typescript
     * this.grid1.nextPage();
     * ```
     */
    nextPage(): void;
    /**
     * Goes to the previous page, if the grid is not already at the first page.
     * @example
     * ```typescript
     * this.grid1.previousPage();
     * ```
     */
    previousPage(): void;
    /**
     * Returns the total number of records.
     * @remarks
     * Only functions when paging is enabled.
     * @example
     * ```typescript
     * const totalRecords = this.grid.totalRecords;
     * ```
     */
    get totalRecords(): number;
    /**
     * Returns if the current page is the last page.
     * @example
     * ```typescript
     * const lastPage = this.grid.isLastPage;
     * ```
     */
    get isLastPage(): boolean;
    /**
     * Returns the total width of the `IgxGridComponent`.
     * @example
     * ```typescript
     * const gridWidth = this.grid.totalWidth;
     * ```
     */
    get totalWidth(): number;
    /**
     * @hidden
     * @internal
     */
    get showRowSelectors(): boolean;
    /**
     * @hidden
     * @internal
     */
    get showDragIcons(): boolean;
    /**
     * @hidden
     */
    protected _moveColumns(from: IgxColumnComponent, to: IgxColumnComponent, pos: DropPosition): void;
    /**
     * @hidden
     */
    protected _resetColumnList(list?: any): any[];
    /**
     * @hidden
     */
    protected _reorderColumns(from: IgxColumnComponent, to: IgxColumnComponent, position: DropPosition, columnCollection: any[]): void;
    /**
     * @hidden
     */
    protected _moveChildColumns(parent: IgxColumnComponent, from: IgxColumnComponent, to: IgxColumnComponent, pos: DropPosition): void;
    /**
     * Moves a column to the specified drop target.
     * @example
     * ```typescript
     * grid.moveColumn(compName, persDetails);
     * ```
      */
    moveColumn(column: IgxColumnComponent, dropTarget: IgxColumnComponent, pos?: DropPosition): void;
    /**
     * Goes to the desired page index.
     * @example
     * ```typescript
     * this.grid1.paginate(1);
     * ```
     * @param val
    */
    paginate(val: number): void;
    /**
     * Manually marks the `IgxGridComponent` for change detection.
     * @example
     * ```typescript
     * this.grid1.markForCheck();
     * ```
     */
    markForCheck(): void;
    /**
     * Creates a new `IgxGridRowComponent` and adds the data record to the end of the data source.
     * @example
     * ```typescript
     * this.grid1.addRow(record);
     * ```
     * @param data
    */
    addRow(data: any): void;
    /**
     * Removes the `IgxGridRowComponent` and the corresponding data record by primary key.
     * @remarks
     * Requires that the `primaryKey` property is set.
     * The method accept rowSelector as a parameter, which is the rowID.
     * @example
     * ```typescript
     * this.grid1.deleteRow(0);
     * ```
     * @param rowSelector
    */
    deleteRow(rowSelector: any): void;
    /** @hidden */
    deleteRowById(rowId: any): void;
    /**
     * @hidden
     */
    protected deleteRowFromData(rowID: any, index: number): void;
    /**
     * Updates the `IgxGridRowComponent` and the corresponding data record by primary key.
     * @remarks
     * Requires that the `primaryKey` property is set.
     * @example
     * ```typescript
     * this.gridWithPK.updateCell('Updated', 1, 'ProductName');
     * ```
     * @param value the new value which is to be set.
     * @param rowSelector corresponds to rowID.
     * @param column corresponds to column field.
    */
    updateCell(value: any, rowSelector: any, column: string): void;
    /**
     * Updates the `IgxGridRowComponent`
     * @remarks
     * The row is specified by
     * rowSelector parameter and the data source record with the passed value.
     * This method will apply requested update only if primary key is specified in the grid.
     * @example
     * ```typescript
     * grid.updateRow({
     *       ProductID: 1, ProductName: 'Spearmint', InStock: true, UnitsInStock: 1, OrderDate: new Date('2005-03-21')
     *   }, 1);
     * ```
     * @param value
     * @param rowSelector correspond to rowID
    */
    updateRow(value: any, rowSelector: any): void;
    /**
     * Sort a single `IgxColumnComponent`.
     * @remarks
     * Sort the `IgxGridComponent`'s `IgxColumnComponent` based on the provided array of sorting expressions.
     * @example
     * ```typescript
     * this.grid.sort({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * ```
     */
    sort(expression: ISortingExpression | Array<ISortingExpression>): void;
    /**
     * Filters a single `IgxColumnComponent`.
     * @example
     * ```typescript
     * public filter(term) {
     *      this.grid.filter("ProductName", term, IgxStringFilteringOperand.instance().condition("contains"));
     * }
     * ```
     * @param name
     * @param value
     * @param conditionOrExpressionTree
     * @param ignoreCase
    */
    filter(name: string, value: any, conditionOrExpressionTree?: IFilteringOperation | IFilteringExpressionsTree, ignoreCase?: boolean): void;
    /**
     * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
     * @example
     * ```typescript
     * grid.filterGlobal('some', IgxStringFilteringOperand.instance().condition('contains'));
     * ```
     * @param value
     * @param condition
     * @param ignoreCase
    */
    filterGlobal(value: any, condition: any, ignoreCase?: any): void;
    /**
     * Enables summaries for the specified column and applies your customSummary.
     * @remarks
     * If you do not provide the customSummary, then the default summary for the column data type will be applied.
     * @example
     * ```typescript
     * grid.enableSummaries([{ fieldName: 'ProductName' }, { fieldName: 'ID' }]);
     * ```
     * Enable summaries for the listed columns.
     * @example
     * ```typescript
     * grid.enableSummaries('ProductName');
     * ```
     * @param rest
    */
    enableSummaries(...rest: any[]): void;
    /**
     * Disable summaries for the specified column.
     * @example
     * ```typescript
     * grid.disableSummaries('ProductName');
     * ```
     *@remarks
     * Disable summaries for the listed columns.
     *@example
     * ```typescript
     * grid.disableSummaries([{ fieldName: 'ProductName' }]);
     * ```
     */
    disableSummaries(...rest: any[]): void;
    /**
     * If name is provided, clears the filtering state of the corresponding `IgxColumnComponent`.
     *@remarks
     Otherwise clears the filtering state of all `IgxColumnComponent`s.
     *@example
     * ```typescript
     * this.grid.clearFilter();
     * ```
     * @param name
    */
    clearFilter(name?: string): void;
    /**
     * If name is provided, clears the sorting state of the corresponding `IgxColumnComponent`.
     * @remarks
     * otherwise clears the sorting state of all `IgxColumnComponent`.
     * @example
     * ```typescript
     * this.grid.clearSort();
     * ```
     * @param name
    */
    clearSort(name?: string): void;
    /**
     * @hidden @internal
     */
    refreshGridState(args?: any): void;
    /**
     * Pins a column by field name.
     * @remarks
     * Returns whether the operation is successful.
     * @example
     * ```typescript
     * this.grid.pinColumn("ID");
     * ```
     * @param columnName
     * @param index
    */
    pinColumn(columnName: string | IgxColumnComponent, index?: any): boolean;
    /**
     * Unpins a column by field name. Returns whether the operation is successful.
     * @example
     * ```typescript
     * this.grid.pinColumn("ID");
     * ```
     * @param columnName
     * @param index
    */
    unpinColumn(columnName: string | IgxColumnComponent, index?: any): boolean;
    /**
     * Recalculates grid width/height dimensions.
     * @remarks
     * Should be run when changing DOM elements dimentions manually that affect the grid's size.
     * @example
     * ```typescript
     * this.grid.reflow();
     * ```
     */
    reflow(): void;
    /**
     * Finds the next occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
     * @remarks
     * Returns how many times the grid contains the string.
     * @example
     * ```typescript
     * this.grid.findNext("financial");
     * ```
     * @param text the string to search.
     * @param caseSensitive optionally, if the search should be case sensitive (defaults to false).
     * @param exactMatch optionally, if the text should match the entire value  (defaults to false).
    */
    findNext(text: string, caseSensitive?: boolean, exactMatch?: boolean): number;
    /**
     * Finds the previous occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
     * @remarks
     * Returns how many times the grid contains the string.
     * @example
     * ```typescript
     * this.grid.findPrev("financial");
     * ```
     * @param text the string to search.
     * @param caseSensitive optionally, if the search should be case sensitive (defaults to false).
     * @param exactMatch optionally, if the text should match the entire value (defaults to false).
    */
    findPrev(text: string, caseSensitive?: boolean, exactMatch?: boolean): number;
    /**
     * Reapplies the existing search.
     * @remarks
     * Returns how many times the grid contains the last search.
     * @example
     * ```typescript
     * this.grid.refreshSearch();
     * ```
     * @param updateActiveInfo
    */
    refreshSearch(updateActiveInfo?: boolean): number;
    /**
     * Removes all the highlights in the cell.
     * @example
     * ```typescript
     * this.grid.clearSearch();
     * ```
     */
    clearSearch(): void;
    /**
     * Returns if the `IgxGridComponent` has sortable columns.
     * @example
     * ```typescript
     * const sortableGrid = this.grid.hasSortableColumns;
     * ```
     */
    get hasSortableColumns(): boolean;
    /**
     * Returns if the `IgxGridComponent` has editable columns.
     * @example
     * ```typescript
     * const editableGrid = this.grid.hasEditableColumns;
     * ```
     */
    get hasEditableColumns(): boolean;
    /**
     * Returns if the `IgxGridComponent` has fiterable columns.
     * @example
     * ```typescript
     * const filterableGrid = this.grid.hasFilterableColumns;
     * ```
     */
    get hasFilterableColumns(): boolean;
    /**
     * Returns if the `IgxGridComponent` has summarized columns.
     * @example
     * ```typescript
     * const summarizedGrid = this.grid.hasSummarizedColumns;
     * ```
     */
    get hasSummarizedColumns(): boolean;
    /**
     * @hidden @internal
     */
    get rootSummariesEnabled(): boolean;
    /**
     * @hidden @internal
     */
    get hasVisibleColumns(): boolean;
    set hasVisibleColumns(value: boolean);
    /**
     * Returns if the `IgxGridComponent` has moveable columns.
     * @example
     * ```typescript
     * const movableGrid = this.grid.hasMovableColumns;
     * ```
     */
    get hasMovableColumns(): boolean;
    /**
     * Returns if the `IgxGridComponent` has column groups.
     * @example
     * ```typescript
     * const groupGrid = this.grid.hasColumnGroups;
     * ```
     */
    get hasColumnGroups(): boolean;
    /**
     * Returns if the `IgxGridComponent` has column layouts for multi-row layout definition.
     * @example
     * ```typescript
     * const layoutGrid = this.grid.hasColumnLayouts;
     * ```
     */
    get hasColumnLayouts(): boolean;
    /**
     * Returns an array of the selected `IgxGridCellComponent`s.
     * @example
     * ```typescript
     * const selectedCells = this.grid.selectedCells;
     * ```
     */
    get selectedCells(): IgxGridCellComponent[] | any[];
    /**
     * @hidden @internal
     */
    get multiRowLayoutRowSize(): number;
    /**
     * @hidden
     */
    protected get rowBasedHeight(): number;
    /**
     * @hidden
     */
    protected get isPercentWidth(): boolean;
    /**
     * @hidden @internal
     */
    get isPercentHeight(): boolean;
    /**
     * @hidden
     * Sets columns defaultWidth property
     */
    protected _derivePossibleWidth(): void;
    /**
     * @hidden
     */
    protected get defaultTargetBodyHeight(): number;
    /**
     * @hidden @internal
     * The rowHeight input is bound to min-height css prop of rows that adds a 1px border in all cases
     */
    get renderedRowHeight(): number;
    /**
     * @hidden
     * @internal
     */
    protected calcGridHeadRow(): void;
    /**
     * @hidden
     * Sets TBODY height i.e. this.calcHeight
     */
    protected calculateGridHeight(): void;
    /**
     * @hidden
     */
    protected getGroupAreaHeight(): number;
    /**
     * @hidden
     */
    protected getToolbarHeight(): number;
    /**
     * @hidden
     */
    protected getPagingHeight(): number;
    /**
     * @hidden
     */
    protected getFilterCellHeight(): number;
    /**
     * @hidden
     */
    protected _calculateGridBodyHeight(): number;
    protected checkContainerSizeChange(): boolean;
    protected _shouldAutoSize(renderedHeight: any): boolean;
    /**
     * @hidden @internal
     */
    get outerWidth(): number;
    /**
     * @hidden @internal
     * Gets the visible content height that includes header + tbody + footer.
     */
    getVisibleContentHeight(): any;
    /**
     * @hidden @internal
     */
    getPossibleColumnWidth(baseWidth?: number): string;
    /**
     * @hidden
     * Sets grid width i.e. this.calcWidth
     */
    protected calculateGridWidth(): void;
    private getColumnWidthSum;
    /**
     * @hidden @internal
     */
    hasVerticalSroll(): boolean;
    /**
     * @hidden @internal
     */
    protected getDataBasedBodyHeight(): number;
    /**
     * @hidden
     */
    protected onColumnsChanged(change: QueryList<IgxColumnComponent>): void;
    /**
     * @hidden
     */
    protected calculateGridSizes(recalcFeatureWidth?: boolean): void;
    private _applyWidthHostBinding;
    /**
     * Gets calculated width of the pinned area.
     * @example
     * ```typescript
     * const pinnedWidth = this.grid.getPinnedWidth();
     * ```
     * @param takeHidden If we should take into account the hidden columns in the pinned area.
    */
    getPinnedWidth(takeHidden?: boolean): number;
    /**
     * @hidden
     * Gets calculated width of the unpinned area
     * @param takeHidden If we should take into account the hidden columns in the pinned area.
    */
    protected getUnpinnedWidth(takeHidden?: boolean): number;
    /**
     * @hidden
     */
    protected _summaries(fieldName: string, hasSummary: boolean, summaryOperand?: any): void;
    /**
     * @hidden
     */
    protected _multipleSummaries(expressions: ISummaryExpression[], hasSummary: boolean): void;
    /**
     * @hidden
     */
    protected _disableMultipleSummaries(expressions: any): void;
    /**
     * @hidden
     */
    protected resolveDataTypes(rec: any): DataType;
    private getScrollWidth;
    /**
     * @hidden
     */
    protected autogenerateColumns(): void;
    protected generateDataFields(data: any[]): string[];
    /**
     * @hidden
     */
    onlyTopLevel(arr: any): any;
    /**
     * @hidden
     */
    protected initColumns(collection: QueryList<IgxColumnComponent>, cb?: Function): void;
    /**
     * @hidden
     */
    protected reinitPinStates(): void;
    /**
     * @hidden @internal
    */
    isColumnGrouped(fieldName: string): boolean;
    /**
     * @hidden @internal
    */
    onHeaderSelectorClick(event: any): void;
    /**
     * @hidden @internal
     */
    get headSelectorBaseAriaLabel(): "Deselect all filtered" | "Select all filtered" | "Deselect all" | "Select all";
    /**
     * @hidden
     * @internal
     */
    get totalRowsCountAfterFilter(): number;
    /**
     * Returns the currently transformed paged/filtered/sorted/grouped data, displayed in the grid.
     * @example
     * ```typescript
     *      const dataView = this.grid.dataView;
     * ```
     */
    get dataView(): any[];
    /**
     * Get current selection state.
     * @example
     * Returns an array with selected rows' IDs (primaryKey or rowData)
     * ```typescript
     * const selectedRows = this.grid.selectedRows();
     * ```
     */
    selectedRows(): any[];
    /**
     * Select specified rows by ID.
     * @example
     * ```typescript
     * this.grid.selectRows([1,2,5], true);
     * ```
     * @param rowIDs
     * @param clearCurrentSelection if true clears the current selection
    */
    selectRows(rowIDs: any[], clearCurrentSelection?: boolean): void;
    /**
     * Deselect specified rows by ID.
     * @example
     * ```typescript
     * this.grid.deselectRows([1,2,5]);
     * ```
     * @param rowIDs
    */
    deselectRows(rowIDs: any[]): void;
    /**
     * Selects all rows
     * @remarks
     * By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
     * If you set the parameter onlyFilterData to false that will select all rows in the grid exept deleted rows.
     * @example
     * ```typescript
     * this.grid.selectAllRows();
     * this.grid.selectAllRows(false);
     * ```
     * @param onlyFilterData
     */
    selectAllRows(onlyFilterData?: boolean): void;
    /**
     * Deselects all rows
     * @remarks
     * By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
     * If you set the parameter onlyFilterData to false that will select all rows in the grid exept deleted rows.
     * @example
     * ```typescript
     * this.grid.deselectAllRows();
     * ```
     * @param onlyFilterData
     */
    deselectAllRows(onlyFilterData?: boolean): void;
    /**
     * @hidden @internal
     */
    clearCellSelection(): void;
    /**
     * @hidden @internal
    */
    dragScroll(dir: DragScrollDirection): void;
    /**
     * @hidden @internal
    */
    isDefined(arg: any): boolean;
    /**
     * @hidden @internal
     */
    selectRange(arg: GridSelectionRange | GridSelectionRange[] | null | undefined): void;
    /**
     * @hidden @internal
    */
    columnToVisibleIndex(field: string | number): number;
    /**
     * @hidden @internal
    */
    setSelection(range: GridSelectionRange): void;
    /**
     * @hidden @internal
     */
    getSelectedRanges(): GridSelectionRange[];
    protected extractDataFromSelection(source: any[], formatters?: boolean, headers?: boolean): any[];
    protected getSelectableColumnsAt(index: any): IgxColumnComponent[];
    /**
     *
     * Returns an array of the current cell selection in the form of `[{ column.field: cell.value }, ...]`.
     * @remarks
     * If `formatters` is enabled, the cell value will be formatted by its respective column formatter (if any).
     * If `headers` is enabled, it will use the column header (if any) instead of the column field.
     */
    getSelectedData(formatters?: boolean, headers?: boolean): any[];
    /**
     * @hidden @internal
    */
    scrollHandler: (event: any) => void;
    /**
     * @hidden @internal
     */
    copyHandlerIE(): void;
    /**
     * @hidden
     * @internal
     */
    copyHandler(event: any, ie11?: boolean): void;
    /**Navigates to a posution in the grid based on provided `rowindex` and `visibleColumnIndex`.
     * @remarks
     * Also can execute a custom logic over the target element,
     * through a callback function that accepts { targetType: GridKeydownTargetType, target: Object }
     * @example
     * ```typescript
     *  this.grid.navigateTo(10, 3, (args) => { args.target.nativeElement.focus(); });
     * ```
     */
    navigateTo(rowIndex: number, visibleColIndex?: number, cb?: Function): void;
    /**
    * Returns `ICellPosition` which defines the next cell,
    * according to the current position, that match specific criteria.
    * @remarks
    * You can pass callback function as a third parameter of `getPreviousCell` method.
    * The callback function accepts IgxColumnComponent as a param
    * @example
    * ```typescript
    *  const nextEditableCellPosition = this.grid.getNextCell(0, 3, (column) => column.editable);
    * ```
    */
    getNextCell(currRowIndex: number, curVisibleColIndex: number, callback?: (IgxColumnComponent: any) => boolean): ICellPosition;
    /**
    * Returns `ICellPosition` which defines the previous cell,
    * according to the current position, that match specific criteria.
    * @remarks
    * You can pass callback function as a third parameter of `getPreviousCell` method.
    * The callback function accepts IgxColumnComponent as a param
    * @example
    * ```typescript
    *  const previousEditableCellPosition = this.grid.getPreviousCell(0, 3, (column) => column.editable);
    * ```
    */
    getPreviousCell(currRowIndex: number, curVisibleColIndex: number, callback?: (IgxColumnComponent: any) => boolean): ICellPosition;
    private executeCallback;
    private getPrevDataRowIndex;
    private getNextDataRowIndex;
    private isValidPosition;
    /**
     * @hidden @internal
     */
    wheelHandler: (isScroll?: boolean) => void;
    /**
     * @hidden @internal
     */
    trackColumnChanges(index: any, col: any): any;
    private find;
    /**
     * Returns an array containing the filtered sorted data.
     * @example
     * ```typescript
     * const filteredSortedData = this.grid1.filteredSortedData;
     * ```
    */
    get filteredSortedData(): any[];
    set filteredSortedData(value: any[]);
    /**
     * @hidden
     */
    protected initPinning(): void;
    /**
     * @hidden
     */
    protected scrollTo(row: any | number, column: any | number, inCollection?: any[]): void;
    /**
     * @hidden
     */
    protected scrollToHorizontally(column: any | number): void;
    /**
     * @hidden
     */
    protected scrollDirective(directive: IgxGridForOfDirective<any>, goal: number): void;
    private rebuildMatchCache;
    /**
     * @hidden
     */
    isExpandedGroup(_group: IGroupByRecord): boolean;
    protected changeRowEditingOverlayStateOnScroll(row: IgxRowDirective<IgxGridBaseDirective & GridType>): void;
    /**
     * Should be called when data and/or isLoading input changes so that the overlay can be
     * hidden/shown based on the current value of shouldOverlayLoading
     */
    protected evaluateLoadingState(): void;
    /**
     * @hidden @internal
    */
    openRowOverlay(id: any): void;
    /**
     * @hidden @internal
     */
    closeRowEditingOverlay(): void;
    /**
     * @hidden @internal
    */
    toggleRowEditingOverlay(show: any): void;
    /**
     * @hidden @internal
     */
    repositionRowEditingOverlay(row: IgxRowDirective<IgxGridBaseDirective & GridType>): void;
    private configureRowEditingOverlay;
    /**
     * @hidden @internal
    */
    get rowChangesCount(): number;
    protected writeToData(rowIndex: number, value: any): void;
    /**
     * @hidden @internal
     */
    endRowTransaction(commit: boolean, row: IgxRow): void;
    /**
     * @hidden @internal
    */
    gridOutletKeyboardHandler(event: any): void;
    /**
     * Finishes the row transactions on the current row.
     * @remarks
     * If `commit === true`, passes them from the pending state to the data (or transaction service)
     * @example
     * ```html
     * <button igxButton (click)="grid.endEdit(true)">Commit Row</button>
     * ```
     * @param commit
     */
    endEdit(commit?: boolean, event?: Event): void;
    /**
     * @hidden
     */
    private rowEditingWheelHandler;
    /**
     * @hidden @internal
     */
    get dataWithAddedInTransactionRows(): any;
    /**
     * @hidden @internal
    */
    get dataLength(): any;
    /**
     * @hidden @internal
     */
    hasHorizontalScroll(): boolean;
    protected _restoreVirtState(row: any): void;
    /**
     * @hidden
     */
    protected getExportExcel(): boolean;
    /**
     * @hidden
     */
    protected getExportCsv(): boolean;
    /**
     * @hidden @internal
     */
    get shouldOverlayLoading(): boolean;
    /**
     * @hidden @internal
    */
    isSummaryRow(rowData: any): boolean;
    /**
     * @hidden @internal
     */
    get isMultiRowSelectionEnabled(): boolean;
    /**
     * @hidden @internal
     */
    get isRowSelectable(): boolean;
    /**
     * @hidden @internal
     */
    get isCellSelectable(): boolean;
    /**
     * @hidden @internal
    */
    viewDetachHandler(args: ICachedViewLoadedEventArgs): void;
    /**
     * @hidden @internal
    */
    cachedViewLoaded(args: ICachedViewLoadedEventArgs): void;
    /**
     * Opens the advanced filtering dialog.
     */
    openAdvancedFilteringDialog(): void;
    /**
     * Closes the advanced filtering dialog.
     * @param applyChanges indicates whether the changes should be applied
     */
    closeAdvancedFilteringDialog(applyChanges: boolean): void;
    static Éµfac: Éµngcc0.ÉµÉµFactoryDef<IgxGridBaseDirective>;
    static Éµdir: Éµngcc0.ÉµÉµDirectiveDefWithMeta<IgxGridBaseDirective, "[igxGridBaseComponent]", never, {
    "autoGenerate": "autoGenerate";
    "evenRowCSS": "evenRowCSS";
    "oddRowCSS": "oddRowCSS";
    "columnHidingTitle": "columnHidingTitle";
    "columnPinningTitle": "columnPinningTitle";
    "clipboardOptions": "clipboardOptions";
    "resourceStrings": "resourceStrings";
    "filteringLogic": "filteringLogic";
    "filteringExpressionsTree": "filteringExpressionsTree";
    "advancedFilteringExpressionsTree": "advancedFilteringExpressionsTree";
    "locale": "locale";
    "paging": "paging";
    "page": "page";
    "perPage": "perPage";
    "columnHiding": "columnHiding";
    "rowSelectable": "rowSelectable";
    "rowSelection": "rowSelection";
    "hideRowSelectors": "hideRowSelectors";
    "rowDraggable": "rowDraggable";
    "rowEditable": "rowEditable";
    "height": "height";
    "width": "width";
    "rowHeight": "rowHeight";
    "columnWidth": "columnWidth";
    "emptyGridMessage": "emptyGridMessage";
    "isLoading": "isLoading";
    "emptyFilteredGridMessage": "emptyFilteredGridMessage";
    "columnPinning": "columnPinning";
    "allowFiltering": "allowFiltering";
    "allowAdvancedFiltering": "allowAdvancedFiltering";
    "filterMode": "filterMode";
    "summaryPosition": "summaryPosition";
    "summaryCalculationMode": "summaryCalculationMode";
    "filterStrategy": "filterStrategy";
    "sortStrategy": "sortStrategy";
    "sortingExpressions": "sortingExpressions";
    "hiddenColumnsText": "hiddenColumnsText";
    "pinnedColumnsText": "pinnedColumnsText";
    "showToolbar": "showToolbar";
    "toolbarTitle": "toolbarTitle";
    "exportExcel": "exportExcel";
    "exportCsv": "exportCsv";
    "exportText": "exportText";
    "exportExcelText": "exportExcelText";
    "exportCsvText": "exportCsvText";
    "cellSelection": "cellSelection";
    "expansionStates": "expansionStates";
    "emptyGridTemplate": "emptyGridTemplate";
    "loadingGridTemplate": "loadingGridTemplate";
    "paginationTemplate": "paginationTemplate";
    "primaryKey": "primaryKey";
    "uniqueColumnValuesStrategy": "uniqueColumnValuesStrategy";
}, {
    "filteringExpressionsTreeChange": "filteringExpressionsTreeChange";
    "advancedFilteringExpressionsTreeChange": "advancedFilteringExpressionsTreeChange";
    "pageChange": "pageChange";
    "perPageChange": "perPageChange";
    "onCellClick": "onCellClick";
    "onSelection": "onSelection";
    "onRowSelectionChange": "onRowSelectionChange";
    "onColumnPinning": "onColumnPinning";
    "onCellEditCancel": "onCellEditCancel";
    "onCellEditEnter": "onCellEditEnter";
    "onCellEdit": "onCellEdit";
    "onRowEditEnter": "onRowEditEnter";
    "onRowEdit": "onRowEdit";
    "onRowEditCancel": "onRowEditCancel";
    "onColumnInit": "onColumnInit";
    "onSortingDone": "onSortingDone";
    "onFilteringDone": "onFilteringDone";
    "onPagingDone": "onPagingDone";
    "onRowAdded": "onRowAdded";
    "onRowDeleted": "onRowDeleted";
    "onDataPreLoad": "onDataPreLoad";
    "onColumnResized": "onColumnResized";
    "onContextMenu": "onContextMenu";
    "onDoubleClick": "onDoubleClick";
    "onColumnVisibilityChanged": "onColumnVisibilityChanged";
    "onColumnMovingStart": "onColumnMovingStart";
    "onColumnMoving": "onColumnMoving";
    "onColumnMovingEnd": "onColumnMovingEnd";
    "onGridKeydown": "onGridKeydown";
    "onRowDragStart": "onRowDragStart";
    "onRowDragEnd": "onRowDragEnd";
    "onGridCopy": "onGridCopy";
    "expansionStatesChange": "expansionStatesChange";
    "onRowToggle": "onRowToggle";
    "sortingExpressionsChange": "sortingExpressionsChange";
    "onToolbarExporting": "onToolbarExporting";
    "onRangeSelection": "onRangeSelection";
}, ["rowExpandedIndicatorTemplate", "rowCollapsedIndicatorTemplate", "headerExpandIndicatorTemplate", "headerCollapseIndicatorTemplate", "excelStyleSortingTemplateDirective", "excelStyleMovingTemplateDirective", "excelStyleHidingTemplateDirective", "excelStylePinningTemplateDirective", "excelStyleLoadingValuesTemplateDirective", "rowEditCustom", "rowEditText", "rowEditActions", "columnList", "toolbarCustomContentTemplates", "headSelectorsTemplates", "rowSelectorsTemplates", "dragGhostCustomTemplates", "dragIndicatorIconTemplates", "rowEditTabsCUSTOM"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC1iYXNlLmRpcmVjdGl2ZS5kLnRzIiwic291cmNlcyI6WyJncmlkLWJhc2UuZGlyZWN0aXZlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOENBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2a0ZBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJWaWV3SW5pdCwgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJdGVyYWJsZURpZmZlcnMsIE5nWm9uZSwgT25EZXN0cm95LCBPbkluaXQsIFF1ZXJ5TGlzdCwgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYsIEluamVjdGlvblRva2VuLCBEb0NoZWNrIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgUmVzaXplT2JzZXJ2ZXIgZnJvbSAncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vZGF0YS1vcGVyYXRpb25zL2RhdGEtdXRpbCc7XG5pbXBvcnQgeyBGaWx0ZXJpbmdMb2dpYyB9IGZyb20gJy4uL2RhdGEtb3BlcmF0aW9ucy9maWx0ZXJpbmctZXhwcmVzc2lvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSUdyb3VwQnlSZWNvcmQgfSBmcm9tICcuLi9kYXRhLW9wZXJhdGlvbnMvZ3JvdXBieS1yZWNvcmQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElTb3J0aW5nRXhwcmVzc2lvbiB9IGZyb20gJy4uL2RhdGEtb3BlcmF0aW9ucy9zb3J0aW5nLWV4cHJlc3Npb24uaW50ZXJmYWNlJztcbmltcG9ydCB7IElGb3JPZlN0YXRlLCBJZ3hHcmlkRm9yT2ZEaXJlY3RpdmUgfSBmcm9tICcuLi9kaXJlY3RpdmVzL2Zvci1vZi9mb3Jfb2YuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneE92ZXJsYXlTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvaW5kZXgnO1xuaW1wb3J0IHsgR3JpZEJhc2VBUElTZXJ2aWNlIH0gZnJvbSAnLi9hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hHcmlkQ2VsbENvbXBvbmVudCB9IGZyb20gJy4vY2VsbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSUNvbHVtblZpc2liaWxpdHlDaGFuZ2VkRXZlbnRBcmdzIH0gZnJvbSAnLi9oaWRpbmcvY29sdW1uLWhpZGluZy1pdGVtLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJU3VtbWFyeUV4cHJlc3Npb24gfSBmcm9tICcuL3N1bW1hcmllcy9ncmlkLXN1bW1hcnknO1xuaW1wb3J0IHsgSWd4R3JpZFRvb2xiYXJDb21wb25lbnQgfSBmcm9tICcuL3Rvb2xiYXIvZ3JpZC10b29sYmFyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hSb3dEaXJlY3RpdmUgfSBmcm9tICcuL3Jvdy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSWd4R3JpZEhlYWRlckNvbXBvbmVudCB9IGZyb20gJy4vaGVhZGVycy9ncmlkLWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZSwgSWd4VG9nZ2xlRGlyZWN0aXZlIH0gZnJvbSAnLi4vZGlyZWN0aXZlcy90b2dnbGUvdG9nZ2xlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlIH0gZnJvbSAnLi4vZGF0YS1vcGVyYXRpb25zL2ZpbHRlcmluZy1leHByZXNzaW9ucy10cmVlJztcbmltcG9ydCB7IElGaWx0ZXJpbmdPcGVyYXRpb24gfSBmcm9tICcuLi9kYXRhLW9wZXJhdGlvbnMvZmlsdGVyaW5nLWNvbmRpdGlvbic7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb25TZXJ2aWNlLCBTdGF0ZSB9IGZyb20gJy4uL3NlcnZpY2VzL2luZGV4JztcbmltcG9ydCB7IElneFJvd0VkaXRUYWJTdG9wRGlyZWN0aXZlIH0gZnJvbSAnLi9ncmlkLnJvd0VkaXQuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneEdyaWROYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vZ3JpZC1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgSURpc3BsYXlEZW5zaXR5T3B0aW9ucywgRGlzcGxheURlbnNpdHlCYXNlIH0gZnJvbSAnLi4vY29yZS9kaXNwbGF5RGVuc2l0eSc7XG5pbXBvcnQgeyBJZ3hGaWx0ZXJpbmdTZXJ2aWNlIH0gZnJvbSAnLi9maWx0ZXJpbmcvZ3JpZC1maWx0ZXJpbmcuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hHcmlkRmlsdGVyaW5nQ2VsbENvbXBvbmVudCB9IGZyb20gJy4vZmlsdGVyaW5nL2Jhc2UvZ3JpZC1maWx0ZXJpbmctY2VsbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4R3JpZEhlYWRlckdyb3VwQ29tcG9uZW50IH0gZnJvbSAnLi9oZWFkZXJzL2dyaWQtaGVhZGVyLWdyb3VwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJR3JpZFJlc291cmNlU3RyaW5ncyB9IGZyb20gJy4uL2NvcmUvaTE4bi9ncmlkLXJlc291cmNlcyc7XG5pbXBvcnQgeyBJZ3hHcmlkU3VtbWFyeVNlcnZpY2UgfSBmcm9tICcuL3N1bW1hcmllcy9ncmlkLXN1bW1hcnkuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hTdW1tYXJ5Um93Q29tcG9uZW50IH0gZnJvbSAnLi9zdW1tYXJpZXMvc3VtbWFyeS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7IElneEdyaWRTZWxlY3Rpb25TZXJ2aWNlLCBHcmlkU2VsZWN0aW9uUmFuZ2UsIElneEdyaWRDUlVEU2VydmljZSwgSWd4Um93IH0gZnJvbSAnLi9zZWxlY3Rpb24vc2VsZWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgRHJhZ1Njcm9sbERpcmVjdGlvbiB9IGZyb20gJy4vc2VsZWN0aW9uL2RyYWctc2VsZWN0LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJQ2FjaGVkVmlld0xvYWRlZEV2ZW50QXJncyB9IGZyb20gJy4uL2RpcmVjdGl2ZXMvdGVtcGxhdGUtb3V0bGV0L3RlbXBsYXRlX291dGxldC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSWd4RXhjZWxTdHlsZUxvYWRpbmdWYWx1ZXNUZW1wbGF0ZURpcmVjdGl2ZSB9IGZyb20gJy4vZmlsdGVyaW5nL2V4Y2VsLXN0eWxlL2V4Y2VsLXN0eWxlLXNlYXJjaC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4RXhjZWxTdHlsZVNvcnRpbmdUZW1wbGF0ZURpcmVjdGl2ZSwgSWd4RXhjZWxTdHlsZVBpbm5pbmdUZW1wbGF0ZURpcmVjdGl2ZSwgSWd4RXhjZWxTdHlsZUhpZGluZ1RlbXBsYXRlRGlyZWN0aXZlLCBJZ3hFeGNlbFN0eWxlTW92aW5nVGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuL2ZpbHRlcmluZy9leGNlbC1zdHlsZS9ncmlkLmV4Y2VsLXN0eWxlLWZpbHRlcmluZy5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4R3JpZENvbHVtblJlc2l6ZXJDb21wb25lbnQgfSBmcm9tICcuL3Jlc2l6aW5nL3Jlc2l6ZXIuY29tcG9uZW50JztcbmltcG9ydCB7IElneEdyaWRGaWx0ZXJpbmdSb3dDb21wb25lbnQgfSBmcm9tICcuL2ZpbHRlcmluZy9iYXNlL2dyaWQtZmlsdGVyaW5nLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4Q29sdW1uUmVzaXppbmdTZXJ2aWNlIH0gZnJvbSAnLi9yZXNpemluZy9yZXNpemluZy5zZXJ2aWNlJztcbmltcG9ydCB7IElGaWx0ZXJpbmdTdHJhdGVneSB9IGZyb20gJy4uL2RhdGEtb3BlcmF0aW9ucy9maWx0ZXJpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgR3JpZFNlbGVjdGlvbk1vZGUsIEdyaWRTdW1tYXJ5UG9zaXRpb24sIEdyaWRTdW1tYXJ5Q2FsY3VsYXRpb25Nb2RlLCBGaWx0ZXJNb2RlIH0gZnJvbSAnLi9jb21tb24vZW51bXMnO1xuaW1wb3J0IHsgSUdyaWRDZWxsRXZlbnRBcmdzLCBJUm93U2VsZWN0aW9uRXZlbnRBcmdzLCBJUGluQ29sdW1uRXZlbnRBcmdzLCBJR3JpZEVkaXRFdmVudEFyZ3MsIElQYWdlRXZlbnRBcmdzLCBJUm93RGF0YUV2ZW50QXJncywgSUNvbHVtblJlc2l6ZUV2ZW50QXJncywgSUNvbHVtbk1vdmluZ1N0YXJ0RXZlbnRBcmdzLCBJQ29sdW1uTW92aW5nRXZlbnRBcmdzLCBJQ29sdW1uTW92aW5nRW5kRXZlbnRBcmdzLCBJR3JpZEtleWRvd25FdmVudEFyZ3MsIElSb3dEcmFnU3RhcnRFdmVudEFyZ3MsIElSb3dEcmFnRW5kRXZlbnRBcmdzLCBJR3JpZENsaXBib2FyZEV2ZW50LCBJR3JpZFRvb2xiYXJFeHBvcnRFdmVudEFyZ3MsIElTZWFyY2hJbmZvLCBJQ2VsbFBvc2l0aW9uLCBJUm93VG9nZ2xlRXZlbnRBcmdzIH0gZnJvbSAnLi9jb21tb24vZXZlbnRzJztcbmltcG9ydCB7IEdyaWRUeXBlIH0gZnJvbSAnLi9jb21tb24vZ3JpZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRHJvcFBvc2l0aW9uIH0gZnJvbSAnLi9tb3ZpbmcvbW92aW5nLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4SGVhZFNlbGVjdG9yRGlyZWN0aXZlLCBJZ3hSb3dTZWxlY3RvckRpcmVjdGl2ZSB9IGZyb20gJy4vc2VsZWN0aW9uL3Jvdy1zZWxlY3RvcnMnO1xuaW1wb3J0IHsgSWd4R3JpZFRvb2xiYXJDdXN0b21Db250ZW50RGlyZWN0aXZlIH0gZnJvbSAnLi90b29sYmFyL3Rvb2xiYXIuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneENvbHVtbkNvbXBvbmVudCB9IGZyb20gJy4vY29sdW1ucy9jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7IElHcmlkU29ydGluZ1N0cmF0ZWd5IH0gZnJvbSAnLi4vZGF0YS1vcGVyYXRpb25zL3NvcnRpbmctc3RyYXRlZ3knO1xuZXhwb3J0IGRlY2xhcmUgY29uc3QgSWd4R3JpZFRyYW5zYWN0aW9uOiBJbmplY3Rpb25Ub2tlbjxzdHJpbmc+O1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4R3JpZEJhc2VEaXJlY3RpdmUgZXh0ZW5kcyBEaXNwbGF5RGVuc2l0eUJhc2UgaW1wbGVtZW50cyBPbkluaXQsIERvQ2hlY2ssIE9uRGVzdHJveSwgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJWaWV3SW5pdCB7XG4gICAgc2VsZWN0aW9uU2VydmljZTogSWd4R3JpZFNlbGVjdGlvblNlcnZpY2U7XG4gICAgY3J1ZFNlcnZpY2U6IElneEdyaWRDUlVEU2VydmljZTtcbiAgICBjb2xSZXNpemluZ1NlcnZpY2U6IElneENvbHVtblJlc2l6aW5nU2VydmljZTtcbiAgICBwcm90ZWN0ZWQgZ3JpZEFQSTogR3JpZEJhc2VBUElTZXJ2aWNlPElneEdyaWRCYXNlRGlyZWN0aXZlICYgR3JpZFR5cGU+O1xuICAgIHByb3RlY3RlZCBfdHJhbnNhY3Rpb25zOiBUcmFuc2FjdGlvblNlcnZpY2U8VHJhbnNhY3Rpb24sIFN0YXRlPjtcbiAgICBwcml2YXRlIGVsZW1lbnRSZWY7XG4gICAgcHJpdmF0ZSB6b25lO1xuICAgIGRvY3VtZW50OiBhbnk7XG4gICAgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZjtcbiAgICBwcm90ZWN0ZWQgcmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICBwcm90ZWN0ZWQgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzO1xuICAgIHByb3RlY3RlZCB2aWV3UmVmOiBWaWV3Q29udGFpbmVyUmVmO1xuICAgIG5hdmlnYXRpb246IElneEdyaWROYXZpZ2F0aW9uU2VydmljZTtcbiAgICBmaWx0ZXJpbmdTZXJ2aWNlOiBJZ3hGaWx0ZXJpbmdTZXJ2aWNlO1xuICAgIHByb3RlY3RlZCBvdmVybGF5U2VydmljZTogSWd4T3ZlcmxheVNlcnZpY2U7XG4gICAgc3VtbWFyeVNlcnZpY2U6IElneEdyaWRTdW1tYXJ5U2VydmljZTtcbiAgICBwcm90ZWN0ZWQgX2Rpc3BsYXlEZW5zaXR5T3B0aW9uczogSURpc3BsYXlEZW5zaXR5T3B0aW9ucztcbiAgICBwcml2YXRlIF9zY3JvbGxXaWR0aDtcbiAgICBwcml2YXRlIF9jdXN0b21EcmFnSW5kaWNhdG9ySWNvblRlbXBsYXRlO1xuICAgIHByb3RlY3RlZCBfaW5pdDogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9jZHJSZXF1ZXN0cztcbiAgICBwcm90ZWN0ZWQgX2NkclJlcXVlc3RSZXBhaW50OiBib29sZWFuO1xuICAgIGdldCBzY3JvbGxXaWR0aCgpOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfcmVzb3VyY2VTdHJpbmdzO1xuICAgIHByaXZhdGUgX2VtcHR5R3JpZE1lc3NhZ2U7XG4gICAgcHJpdmF0ZSBfZW1wdHlGaWx0ZXJlZEdyaWRNZXNzYWdlO1xuICAgIHByaXZhdGUgX2lzTG9hZGluZztcbiAgICBwcml2YXRlIF9sb2NhbGU7XG4gICAgX2Rlc3Ryb3llZDogYm9vbGVhbjtcbiAgICBwcml2YXRlIG92ZXJsYXlJRHM7XG4gICAgcHJpdmF0ZSBfZmlsdGVyaW5nU3RyYXRlZ3k7XG4gICAgcHJpdmF0ZSBfc29ydGluZ1N0cmF0ZWd5O1xuICAgIHByaXZhdGUgX2hvc3RXaWR0aDtcbiAgICBwcml2YXRlIF9hZHZhbmNlZEZpbHRlcmluZ092ZXJsYXlJZDtcbiAgICBwcml2YXRlIF9hZHZhbmNlZEZpbHRlcmluZ1Bvc2l0aW9uU2V0dGluZ3M7XG4gICAgcHJpdmF0ZSBfYWR2YW5jZWRGaWx0ZXJpbmdPdmVybGF5U2V0dGluZ3M7XG4gICAgLyoqXG4gICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgcHJvdGVjdGVkIGRlZmF1bHRFeHBhbmRlZFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHByb3RlY3RlZCBkZWZhdWx0Q29sbGFwc2VkVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSByZXNvdXJjZSBzdHJpbmdzLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQnkgZGVmYXVsdCBpdCB1c2VzIEVOIHJlc291cmNlcy5cbiAgICAqL1xuICAgIHNldCByZXNvdXJjZVN0cmluZ3ModmFsdWU6IElHcmlkUmVzb3VyY2VTdHJpbmdzKTtcbiAgICBnZXQgcmVzb3VyY2VTdHJpbmdzKCk6IElHcmlkUmVzb3VyY2VTdHJpbmdzO1xuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB3aGV0aGVyIHRvIGF1dG9nZW5lcmF0ZSB0aGUgY29sdW1ucy5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGZhbHNlLiBXaGVuIHNldCB0byB0cnVlLCBpdCB3aWxsIG92ZXJyaWRlIGFsbCBjb2x1bW5zIGRlY2xhcmVkIHRocm91Z2ggY29kZSBvciBpbiBtYXJrdXAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkIFtkYXRhXT1cIkRhdGFcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGF1dG9HZW5lcmF0ZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgKi9cbiAgICBpZDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyBhIGN1c3RvbSB0ZW1wbGF0ZSB3aGVuIGVtcHR5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCBbaWRdPVwiJ2lneC1ncmlkLTEnXCIgW2RhdGFdPVwiRGF0YVwiIFtlbXB0eUdyaWRUZW1wbGF0ZV09XCJteVRlbXBsYXRlXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBlbXB0eUdyaWRUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgYSBjdXN0b20gdGVtcGxhdGUgd2hlbiBsb2FkaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCBbaWRdPVwiJ2lneC1ncmlkLTEnXCIgW2RhdGFdPVwiRGF0YVwiIFtsb2FkaW5nR3JpZFRlbXBsYXRlXT1cIm15VGVtcGxhdGVcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGxvYWRpbmdHcmlkVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBmaWx0ZXJpbmcgbG9naWMgb2YgdGhlIGBJZ3hHcmlkQ29tcG9uZW50YC5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBkZWZhdWx0IGlzIEFORC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgW2RhdGFdPVwiRGF0YVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiIFtmaWx0ZXJpbmdMb2dpY109XCJmaWx0ZXJpbmdcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBmaWx0ZXJpbmdMb2dpYygpOiBGaWx0ZXJpbmdMb2dpYztcbiAgICBzZXQgZmlsdGVyaW5nTG9naWModmFsdWU6IEZpbHRlcmluZ0xvZ2ljKTtcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIGZpbHRlcmluZyBzdGF0ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwiRGF0YVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiIFsoZmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlKV09XCJtb2RlbC5maWx0ZXJpbmdFeHByZXNzaW9uc1wiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBTdXBwb3J0cyB0d28td2F5IGJpbmRpbmcuXG4gICAgICovXG4gICAgZ2V0IGZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSgpOiBJRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlO1xuICAgIHNldCBmaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUodmFsdWU6IElGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUpO1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgYWZ0ZXIgZmlsdGVyaW5nIGlzIHBlcmZvcm1lZC5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFJldHVybnMgdGhlIGZpbHRlcmluZyBleHByZXNzaW9ucyB0cmVlIG9mIHRoZSBjb2x1bW4gZm9yIHdoaWNoIGZpbHRlcmluZyB3YXMgcGVyZm9ybWVkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJsb2NhbERhdGFcIiBbaGVpZ2h0XT1cIiczMDVweCdcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIlxuICAgICAqICAgICAgICAgICAgICAoZmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlQ2hhbmdlKT1cImZpbHRlcmluZ0V4cHJUcmVlQ2hhbmdlKCRldmVudClcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICovXG4gICAgZmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8SUZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZT47XG4gICAgLyoqXG4gICAgICogRW1pdHRlZCBhZnRlciBhZHZhbmNlZCBmaWx0ZXJpbmcgaXMgcGVyZm9ybWVkLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUmV0dXJucyB0aGUgYWR2YW5jZWQgZmlsdGVyaW5nIGV4cHJlc3Npb25zIHRyZWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cImxvY2FsRGF0YVwiIFtoZWlnaHRdPVwiJzMwNXB4J1wiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiXG4gICAgICogICAgICAgICAgIChhZHZhbmNlZEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZUNoYW5nZSk9XCJhZHZhbmNlZEZpbHRlcmluZ0V4cHJUcmVlQ2hhbmdlKCRldmVudClcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICovXG4gICAgYWR2YW5jZWRGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxJRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlPjtcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIGFkdmFuY2VkIGZpbHRlcmluZyBzdGF0ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgYWR2YW5jZWRGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUgPSB0aGlzLmdyaWQuYWR2YW5jZWRGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWU7XG4gICAgICogdGhpcy5ncmlkLmFkdmFuY2VkRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlID0gbG9naWM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGFkdmFuY2VkRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlKCk6IElGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWU7XG4gICAgc2V0IGFkdmFuY2VkRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlKHZhbHVlOiBJRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlKTtcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIGxvY2FsZS5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIG5vdCBzZXQsIHJldHVybnMgYnJvd3NlcidzIGxhbmd1YWdlLlxuICAgICAqL1xuICAgIGdldCBsb2NhbGUoKTogc3RyaW5nO1xuICAgIHNldCBsb2NhbGUodmFsdWU6IHN0cmluZyk7XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHdoZXRoZXIgdGhlIHBhZ2luZyBmZWF0dXJlIGlzIGVuYWJsZWQuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgZGVmYXVsdCBzdGF0ZSBpcyBkaXNhYmxlZCAoZmFsc2UpLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJEYXRhXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCIgW3BhZ2luZ109XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgcGFnaW5nKCk6IGJvb2xlYW47XG4gICAgc2V0IHBhZ2luZyh2YWx1ZTogYm9vbGVhbik7XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBjdXJyZW50IHBhZ2UgaW5kZXguXG4gICAgKkBleGFtcGxlXG4gICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cIkRhdGFcIiBbcGFnaW5nXT1cInRydWVcIiBbKHBhZ2UpXT1cIm1vZGVsLnBhZ2VcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqIEByZW1hcmtzXG4gICAgICogU3VwcG9ydHMgdHdvLXdheSBiaW5kaW5nLlxuICAgICAqL1xuICAgIGdldCBwYWdlKCk6IG51bWJlcjtcbiAgICBzZXQgcGFnZSh2YWw6IG51bWJlcik7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHBhZ2VDaGFuZ2U6IEV2ZW50RW1pdHRlcjxudW1iZXI+O1xuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgbnVtYmVyIG9mIHZpc2libGUgaXRlbXMgcGVyIHBhZ2UuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyAxNS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwiRGF0YVwiIFtwYWdpbmddPVwidHJ1ZVwiIFsocGVyUGFnZSldPVwibW9kZWwucGVyUGFnZVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHBlclBhZ2UoKTogbnVtYmVyO1xuICAgIHNldCBwZXJQYWdlKHZhbDogbnVtYmVyKTtcbiAgICAvKipcbiAgICAgKkBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcGVyUGFnZUNoYW5nZTogRXZlbnRFbWl0dGVyPG51bWJlcj47XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIGEgY3VzdG9tIGBuZy10ZW1wbGF0ZWAgZm9yIHRoZSBwYWdpbmF0aW9uIFVJIG9mIHRoZSBncmlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbcGFnaW5nXT1cInRydWVcIiBbbXlUZW1wbGF0ZV09XCJteVRlbXBsYXRlXCIgW2hlaWdodF09XCInMzA1cHgnXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwYWdpbmF0aW9uVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHdoZXRoZXIgdGhlIGNvbHVtbiBoaWRpbmcgVUkgaXMgZW5hYmxlZC5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEJ5IGRlZmF1bHQgaXQgaXMgZGlzYWJsZWQgKGZhbHNlKS4gSW4gb3JkZXIgZm9yIHRoZSBVSSB0byB3b3JrLCB5b3UgbmVlZCB0byBlbmFibGUgdGhlIHRvb2xiYXIgYXMgc2hvd24gaW4gdGhlIGV4YW1wbGUgYmVsb3cuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkIFtkYXRhXT1cIkRhdGFcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIiBbc2hvd1Rvb2xiYXJdPVwidHJ1ZVwiIFtjb2x1bW5IaWRpbmddPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGNvbHVtbkhpZGluZygpOiBib29sZWFuO1xuICAgIHNldCBjb2x1bW5IaWRpbmcodmFsdWU6IGJvb2xlYW4pO1xuICAgIGdldCByb3dTZWxlY3RhYmxlKCk6IGJvb2xlYW47XG4gICAgc2V0IHJvd1NlbGVjdGFibGUodmFsOiBib29sZWFuKTtcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgaWYgdGhlIHJvdyBzZWxlY3RvcnMgYXJlIGhpZGRlbi5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqICBCeSBkZWZhdWx0IHJvdyBzZWxlY3RvcnMgYXJlIHNob3duXG4gICAgKi9cbiAgICBnZXQgaGlkZVJvd1NlbGVjdG9ycygpOiBib29sZWFuO1xuICAgIHNldCBoaWRlUm93U2VsZWN0b3JzKHZhbHVlOiBib29sZWFuKTtcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgd2hldGhlciByb3dzIGNhbiBiZSBtb3ZlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW3Jvd0RyYWdnYWJsZV09XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgcm93RHJhZ2dhYmxlKCk6IGJvb2xlYW47XG4gICAgc2V0IHJvd0RyYWdnYWJsZSh2YWw6IGJvb2xlYW4pO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICByb3dEcmFnZ2luZzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAqIEdldHMvU2V0cyB3aGV0aGVyIHRoZSByb3dzIGFyZSBlZGl0YWJsZS5cbiAgICAqIEByZW1hcmtzXG4gICAgKiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byBmYWxzZS5cbiAgICAqIEBleGFtcGxlXG4gICAgKiBgYGBodG1sXG4gICAgKiA8aWd4LWdyaWQgI2dyaWQgW3Nob3dUb29sYmFyXT1cInRydWVcIiBbcm93RWRpdGFibGVdPVwidHJ1ZVwiIFtwcmltYXJ5S2V5XT1cIidQcm9kdWN0SUQnXCIgW2NvbHVtbkhpZGluZ109XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAqIGBgYFxuICAgICovXG4gICAgZ2V0IHJvd0VkaXRhYmxlKCk6IGJvb2xlYW47XG4gICAgc2V0IHJvd0VkaXRhYmxlKHZhbDogYm9vbGVhbik7XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBoZWlnaHQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cIkRhdGFcIiBbaGVpZ2h0XT1cIiczMDVweCdcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKTogc3RyaW5nO1xuICAgIHNldCBoZWlnaHQodmFsdWU6IHN0cmluZyk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBob3N0V2lkdGgoKTogYW55O1xuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgd2lkdGggb2YgdGhlIGdyaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGdyaWRXaWR0aCA9IHRoaXMuZ3JpZC53aWR0aDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKTogc3RyaW5nO1xuICAgIHNldCB3aWR0aCh2YWx1ZTogc3RyaW5nKTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB3aWR0aCBvZiB0aGUgaGVhZGVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIGxldCBncmlkSGVhZGVyV2lkdGggPSB0aGlzLmdyaWQuaGVhZGVyV2lkdGg7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGhlYWRlcldpZHRoKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIHN0eWxpbmcgY2xhc3NlcyBhcHBsaWVkIHRvIGFsbCBldmVuIGBJZ3hHcmlkUm93Q29tcG9uZW50YHMgaW4gdGhlIGdyaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cIkRhdGFcIiBbZXZlblJvd0NTU109XCInaWd4LWdyaWQtLW15LWV2ZW4tY2xhc3MnXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBldmVuUm93Q1NTOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBzdHlsaW5nIGNsYXNzZXMgYXBwbGllZCB0byBhbGwgb2RkIGBJZ3hHcmlkUm93Q29tcG9uZW50YHMgaW4gdGhlIGdyaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cIkRhdGFcIiBbZXZlblJvd0NTU109XCInaWd4LWdyaWQtLW15LW9kZC1jbGFzcydcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9kZFJvd0NTUzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgcm93IGhlaWdodC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwibG9jYWxEYXRhXCIgW3Nob3dUb29sYmFyXT1cInRydWVcIiBbcm93SGVpZ2h0XT1cIjEwMFwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHJvd0hlaWdodCgpOiBhbnk7XG4gICAgc2V0IHJvd0hlaWdodCh2YWx1ZTogYW55KTtcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIGRlZmF1bHQgd2lkdGggb2YgdGhlIGNvbHVtbnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cImxvY2FsRGF0YVwiIFtzaG93VG9vbGJhcl09XCJ0cnVlXCIgW2NvbHVtbldpZHRoXT1cIjEwMFwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGNvbHVtbldpZHRoKCk6IHN0cmluZztcbiAgICBzZXQgY29sdW1uV2lkdGgodmFsdWU6IHN0cmluZyk7XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBwcmltYXJ5IGtleS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwibG9jYWxEYXRhXCIgW3Nob3dUb29sYmFyXT1cInRydWVcIiBbcHJpbWFyeUtleV09XCInUHJvZHVjdElEJ1wiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHJpbWFyeUtleTogYW55O1xuICAgIC8qKlxuICAgICAqIEdldC9TZXRzIHRoZSBtZXNzYWdlIGRpc3BsYXllZCB3aGVuIHRoZXJlIGFyZSBubyByZWNvcmRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJEYXRhXCIgW2VtcHR5R3JpZE1lc3NhZ2VdPVwiJ1RoZSBncmlkIGlzIGVtcHR5J1wiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2V0IGVtcHR5R3JpZE1lc3NhZ2UodmFsdWU6IHN0cmluZyk7XG4gICAgZ2V0IGVtcHR5R3JpZE1lc3NhZ2UoKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB3aGV0aGVyIHRoZSBncmlkIGlzIGdvaW5nIHRvIHNob3cgYSBsb2FkaW5nIGluZGljYXRvci5cbiAgICAgKkBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJEYXRhXCIgW2lzTG9hZGluZ109XCJ0cnVlXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXQgaXNMb2FkaW5nKHZhbHVlOiBib29sZWFuKTtcbiAgICBnZXQgaXNMb2FkaW5nKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHdoZXRoZXIgdGhlIGNvbHVtbnMgc2hvdWxkIGJlIGF1dG8tZ2VuZXJhdGVkIG9uY2UgYWdhaW4gYWZ0ZXIgdGhlIGluaXRpYWxpemF0aW9uIG9mIHRoZSBncmlkXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIHdpbGwgYWxsb3cgdG8gYmluZCB0aGUgZ3JpZCB0byByZW1vdGUgZGF0YSBhbmQgaGF2aW5nIGF1dG8tZ2VuZXJhdGVkIGNvbHVtbnMgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgKiBOb3RlIHRoYXQgYWZ0ZXIgZ2VuZXJhdGluZyB0aGUgY29sdW1ucywgdGhpcyBwcm9wZXJ0eSB3b3VsZCBiZSBkaXNhYmxlZCB0byBhdm9pZCByZS1jcmVhdGluZ1xuICAgICAqIGNvbHVtbnMgZWFjaCB0aW1lIGEgbmV3IGRhdGEgaXMgYXNzaWduZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogIHRoaXMuZ3JpZC5zaG91bGRHZW5lcmF0ZSA9IHRydWU7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2hvdWxkR2VuZXJhdGU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBtZXNzYWdlIGRpc3BsYXllZCB3aGVuIHRoZXJlIGFyZSBubyByZWNvcmRzIGFuZCB0aGUgZ3JpZCBpcyBmaWx0ZXJlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwiRGF0YVwiIFtlbXB0eUdyaWRNZXNzYWdlXT1cIidUaGUgZ3JpZCBpcyBlbXB0eSdcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldCBlbXB0eUZpbHRlcmVkR3JpZE1lc3NhZ2UodmFsdWU6IHN0cmluZyk7XG4gICAgZ2V0IGVtcHR5RmlsdGVyZWRHcmlkTWVzc2FnZSgpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSB0aXRsZSB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGJ1aWx0LWluIGNvbHVtbiBoaWRpbmcgVUkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkIFtzaG93VG9vbGJhcl09XCJ0cnVlXCIgW2NvbHVtbkhpZGluZ109XCJ0cnVlXCIgY29sdW1uSGlkaW5nVGl0bGU9XCJDb2x1bW4gSGlkaW5nXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjb2x1bW5IaWRpbmdUaXRsZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyBpZiB0aGUgYnVpbHQtaW4gY29sdW1uIHBpbm5pbmcgVUkgc2hvdWxkIGJlIHNob3duIGluIHRoZSB0b29sYmFyLlxuICAgICAqIEBleGFtcGxlXG4gICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cImxvY2FsRGF0YVwiIFtjb2x1bW5QaW5uaW5nXT1cIid0cnVlXCIgW2hlaWdodF09XCInMzA1cHgnXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgY29sdW1uUGlubmluZygpOiBib29sZWFuO1xuICAgIHNldCBjb2x1bW5QaW5uaW5nKHZhbHVlOiBib29sZWFuKTtcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIHRpdGxlIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgVUkgb2YgdGhlIGNvbHVtbiBwaW5uaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJsb2NhbERhdGFcIiBbY29sdW1uUGlubmluZ109XCIndHJ1ZVwiIFtjb2x1bW5QaW5uaW5nVGl0bGVdPVwiJ0NvbHVtbiBIaWRpbmcnXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjb2x1bW5QaW5uaW5nVGl0bGU6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgaWYgdGhlIGZpbHRlcmluZyBpcyBlbmFibGVkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJsb2NhbERhdGFcIiBbYWxsb3dGaWx0ZXJpbmddPVwidHJ1ZVwiIFtoZWlnaHRdPVwiJzMwNXB4J1wiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGFsbG93RmlsdGVyaW5nKCk6IGJvb2xlYW47XG4gICAgc2V0IGFsbG93RmlsdGVyaW5nKHZhbHVlOiBib29sZWFuKTtcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGFkdmFuY2VkIGZpbHRlcmluZyBpcyBlbmFibGVkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJsb2NhbERhdGFcIiBbYWxsb3dBZHZhbmNlZEZpbHRlcmluZ109XCJ0cnVlXCIgW3Nob3dUb29sYmFyXT1cInRydWVcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBhbGxvd0FkdmFuY2VkRmlsdGVyaW5nKCk6IGJvb2xlYW47XG4gICAgc2V0IGFsbG93QWR2YW5jZWRGaWx0ZXJpbmcodmFsdWU6IGJvb2xlYW4pO1xuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgZmlsdGVyIG1vZGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cImxvY2FsRGF0YVwiIFtmaWx0ZXJNb2RlXT1cIidxdWlja0ZpbHRlcidcIiBbaGVpZ2h0XT1cIiczMDVweCdcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqIEByZW1hcmtzXG4gICAgICogQnkgZGVmYXVsdCBpdCdzIHNldCB0byBGaWx0ZXJNb2RlLnF1aWNrRmlsdGVyLlxuICAgICAqL1xuICAgIGdldCBmaWx0ZXJNb2RlKCk6IEZpbHRlck1vZGU7XG4gICAgc2V0IGZpbHRlck1vZGUodmFsdWU6IEZpbHRlck1vZGUpO1xuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgc3VtbWFyeSBwb3NpdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwibG9jYWxEYXRhXCIgc3VtbWFyeVBvc2l0aW9uPVwidG9wXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEJ5IGRlZmF1bHQgaXQgaXMgYm90dG9tLlxuICAgICAqL1xuICAgIGdldCBzdW1tYXJ5UG9zaXRpb24oKTogR3JpZFN1bW1hcnlQb3NpdGlvbjtcbiAgICBzZXQgc3VtbWFyeVBvc2l0aW9uKHZhbHVlOiBHcmlkU3VtbWFyeVBvc2l0aW9uKTtcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIHN1bW1hcnkgY2FsY3VsYXRpb24gbW9kZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwibG9jYWxEYXRhXCIgc3VtbWFyeUNhbGN1bGF0aW9uTW9kZT1cInJvb3RMZXZlbE9ubHlcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqIEByZW1hcmtzXG4gICAgICogQnkgZGVmYXVsdCBpdCBpcyByb290QW5kQ2hpbGRMZXZlbHMgd2hpY2ggbWVhbnMgdGhlIHN1bW1hcmllcyBhcmUgY2FsY3VsYXRlZCBmb3IgdGhlIHJvb3QgbGV2ZWwgYW5kIGVhY2ggY2hpbGQgbGV2ZWwuXG4gICAgICovXG4gICAgZ2V0IHN1bW1hcnlDYWxjdWxhdGlvbk1vZGUoKTogR3JpZFN1bW1hcnlDYWxjdWxhdGlvbk1vZGU7XG4gICAgc2V0IHN1bW1hcnlDYWxjdWxhdGlvbk1vZGUodmFsdWU6IEdyaWRTdW1tYXJ5Q2FsY3VsYXRpb25Nb2RlKTtcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIGZpbHRlcmluZyBzdHJhdGVneSBvZiB0aGUgZ3JpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiAgPGlneC1ncmlkICNncmlkIFtkYXRhXT1cImxvY2FsRGF0YVwiIFtmaWx0ZXJTdHJhdGVneV09XCJmaWx0ZXJTdHJhdGVneVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGZpbHRlclN0cmF0ZWd5KCk6IElGaWx0ZXJpbmdTdHJhdGVneTtcbiAgICBzZXQgZmlsdGVyU3RyYXRlZ3koY2xhc3NSZWY6IElGaWx0ZXJpbmdTdHJhdGVneSk7XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBzb3J0aW5nIHN0cmF0ZWd5IG9mIHRoZSBncmlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqICA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwibG9jYWxEYXRhXCIgW3NvcnRTdHJhdGVneV09XCJzb3J0U3RyYXRlZ3lcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBzb3J0U3RyYXRlZ3koKTogSUdyaWRTb3J0aW5nU3RyYXRlZ3k7XG4gICAgc2V0IHNvcnRTdHJhdGVneSh2YWx1ZTogSUdyaWRTb3J0aW5nU3RyYXRlZ3kpO1xuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyBhIHVuaXF1ZSB2YWx1ZXMgc3RyYXRlZ3kgdXNlZCBieSB0aGUgRXhjZWwgU3R5bGUgRmlsdGVyaW5nXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBQcm92aWRlcyBhIGNhbGxiYWNrIGZvciBsb2FkaW5nIHVuaXF1ZSBjb2x1bW4gdmFsdWVzIG9uIGRlbWFuZC5cbiAgICAgKiBJZiB0aGlzIHByb3BlcnR5IGlzIHByb3ZpZGVkLCB0aGUgdW5pcXVlIHZhbHVlcyBpdCBnZW5lcmF0ZXMgd2lsbCBiZSB1c2VkIGJ5IHRoZSBFeGNlbCBTdHlsZSBGaWx0ZXJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkIFtkYXRhXT1cImxvY2FsRGF0YVwiIFtmaWx0ZXJNb2RlXT1cIidleGNlbFN0eWxlRmlsdGVyJ1wiIFt1bmlxdWVDb2x1bW5WYWx1ZXNTdHJhdGVneV09XCJjb2x1bW5WYWx1ZXNTdHJhdGVneVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdW5pcXVlQ29sdW1uVmFsdWVzU3RyYXRlZ3k6IChjb2x1bW46IElneENvbHVtbkNvbXBvbmVudCwgZmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlOiBJRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlLCBkb25lOiAodmFsdWVzOiBhbnlbXSkgPT4gdm9pZCkgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gYElneEdyaWRDZWxsQ29tcG9uZW50YCBpcyBjbGlja2VkLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUmV0dXJucyB0aGUgYElneEdyaWRDZWxsQ29tcG9uZW50YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgKG9uQ2VsbENsaWNrKT1cIm9uQ2VsbENsaWNrKCRldmVudClcIiBbZGF0YV09XCJsb2NhbERhdGFcIiBbaGVpZ2h0XT1cIiczMDVweCdcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9uQ2VsbENsaWNrOiBFdmVudEVtaXR0ZXI8SUdyaWRDZWxsRXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gYElneEdyaWRDZWxsQ29tcG9uZW50YCBpcyBzZWxlY3RlZC5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqICBSZXR1cm5zIHRoZSBgSWd4R3JpZENlbGxDb21wb25lbnRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCAob25TZWxlY3Rpb24pPVwib25DZWxsU2VsZWN0KCRldmVudClcIiBbZGF0YV09XCJsb2NhbERhdGFcIiBbaGVpZ2h0XT1cIiczMDVweCdcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9uU2VsZWN0aW9uOiBFdmVudEVtaXR0ZXI8SUdyaWRDZWxsRXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiAgRW1pdHRlZCB3aGVuIGBJZ3hHcmlkUm93Q29tcG9uZW50YCBpcyBzZWxlY3RlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgKG9uUm93U2VsZWN0aW9uQ2hhbmdlKT1cIm9uQ2VsbENsaWNrQ2hhbmdlKCRldmVudClcIiBbZGF0YV09XCJsb2NhbERhdGFcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9uUm93U2VsZWN0aW9uQ2hhbmdlOiBFdmVudEVtaXR0ZXI8SVJvd1NlbGVjdGlvbkV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIGBJZ3hDb2x1bW5Db21wb25lbnRgIGlzIHBpbm5lZC5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBpbmRleCB0aGF0IHRoZSBjb2x1bW4gaXMgaW5zZXJ0ZWQgYXQgbWF5IGJlIGNoYW5nZWQgdGhyb3VnaCB0aGUgYGluc2VydEF0SW5kZXhgIHByb3BlcnR5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBjb2x1bW5QaW5uaW5nKGV2ZW50KSB7XG4gICAgICogICAgIGlmIChldmVudC5jb2x1bW4uZmllbGQgPT09IFwiTmFtZVwiKSB7XG4gICAgICogICAgICAgZXZlbnQuaW5zZXJ0QXRJbmRleCA9IDA7XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25Db2x1bW5QaW5uaW5nOiBFdmVudEVtaXR0ZXI8SVBpbkNvbHVtbkV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIGVkaXRpbmcgYW5kICoqbm90Kiogc3VibWl0dGluZyB0aGUgdmFsdWUuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiAoZS5nLiBgRXNjYCBrZXkgd2FzIHByZXNzZWQpXG4gICAgICogVGhpcyBldmVudCBpcyBjYW5jZWxhYmxlLlxuICAgICAqQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkMyAob25DZWxsRWRpdENhbmNlbCk9XCJlZGl0Q2FuY2VsKCRldmVudClcIiBbZGF0YV09XCJkYXRhXCIgW3ByaW1hcnlLZXldPVwiJ1Byb2R1Y3RJRCdcIj5cbiAgICAgKiA8L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9uQ2VsbEVkaXRDYW5jZWw6IEV2ZW50RW1pdHRlcjxJR3JpZEVkaXRFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBjZWxsIGVudGVycyBlZGl0IG1vZGUuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGNhbmNlbGFibGUuXG4gICAgICpAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQzIChvbkNlbGxFZGl0RW50ZXIpPVwiZWRpdFN0YXJ0KCRldmVudClcIiBbZGF0YV09XCJkYXRhXCIgW3ByaW1hcnlLZXldPVwiJ1Byb2R1Y3RJRCdcIj5cbiAgICAgKiA8L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9uQ2VsbEVkaXRFbnRlcjogRXZlbnRFbWl0dGVyPElHcmlkRWRpdEV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIGNlbGwgaGFzIGJlZW4gZWRpdGVkLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRXZlbnQgaXMgZmlyZWQgYWZ0ZXIgZWRpdGluZyBpcyBjb21wbGV0ZWQsIHdoZW4gdGhlIGNlbGwgaXMgZXhpdGluZyBlZGl0IG1vZGUuXG4gICAgICogVGhpcyBldmVudCBpcyBjYW5jZWxhYmxlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZDMgKG9uQ2VsbEVkaXQpPVwiZWRpdERvbmUoJGV2ZW50KVwiIFtkYXRhXT1cImRhdGFcIiBbcHJpbWFyeUtleV09XCInUHJvZHVjdElEJ1wiPlxuICAgICAqIDwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25DZWxsRWRpdDogRXZlbnRFbWl0dGVyPElHcmlkRWRpdEV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIGEgcm93IGVudGVycyBlZGl0IG1vZGUuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBFbWl0dGVkIHdoZW4gW3Jvd0VkaXRhYmxlXT1cInRydWVcIi5cbiAgICAgKiBUaGlzIGV2ZW50IGlzIGNhbmNlbGFibGUuXG4gICAgICpAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQzIChvblJvd0VkaXRFbnRlcik9XCJlZGl0U3RhcnQoJGV2ZW50KVwiIFtwcmltYXJ5S2V5XT1cIidQcm9kdWN0SUQnXCIgW3Jvd0VkaXRhYmxlXT1cInRydWVcIj5cbiAgICAgKiA8L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9uUm93RWRpdEVudGVyOiBFdmVudEVtaXR0ZXI8SUdyaWRFZGl0RXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gZXhpdGluZyBlZGl0IG1vZGUgZm9yIGEgcm93LlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRW1pdHRlZCB3aGVuIFtyb3dFZGl0YWJsZV09XCJ0cnVlXCIgJiBgZW5kRWRpdCh0cnVlKWAgaXMgY2FsbGVkLlxuICAgICAqIEVtaXR0ZWQgd2hlbiBjaGFuZ2luZyByb3dzIGR1cmluZyBlZGl0IG1vZGUsIHNlbGVjdGluZyBhbiB1bi1lZGl0YWJsZSBjZWxsIGluIHRoZSBlZGl0ZWQgcm93LFxuICAgICAqIHBlcmZvcm1pbmcgcGFnaW5nIG9wZXJhdGlvbiwgY29sdW1uIHJlc2l6aW5nLCBwaW5uaW5nLCBtb3Zpbmcgb3IgaGl0dGluZyAgYERvbmVgXG4gICAgICogYnV0dG9uIGluc2lkZSBvZiB0aGUgcm93RWRpdGluZ092ZXJsYXksIG9yIGhpdHRpbmcgdGhlIGBFbnRlcmAga2V5IHdoaWxlIGVkaXRpbmcgYSBjZWxsLlxuICAgICAqIFRoaXMgZXZlbnQgaXMgY2FuY2VsYWJsZS5cbiAgICAgKkBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZDMgKG9uUm93RWRpdCk9XCJlZGl0RG9uZSgkZXZlbnQpXCIgW2RhdGFdPVwiZGF0YVwiIFtwcmltYXJ5S2V5XT1cIidQcm9kdWN0SUQnXCIgW3Jvd0VkaXRhYmxlXT1cInRydWVcIj5cbiAgICAgKiA8L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9uUm93RWRpdDogRXZlbnRFbWl0dGVyPElHcmlkRWRpdEV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHJvdyBlZGl0aW5nIGlzIGNhbmNlbGVkLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRW1pdHMgd2hlbiBbcm93RWRpdGFibGVdPVwidHJ1ZVwiICYgYGVuZEVkaXQoZmFsc2UpYCBpcyBjYWxsZWQuXG4gICAgICogRW1pdHRlZCB3aGVuIGNoYW5naW5nIGhpdHRpbmcgYEVzY2Aga2V5IGR1cmluZyBjZWxsIGVkaXRpbmcgYW5kIHdoZW4gY2xpY2sgb24gdGhlIGBDYW5jZWxgIGJ1dHRvblxuICAgICAqIGluIHRoZSByb3cgZWRpdGluZyBvdmVybGF5LlxuICAgICAqIFRoaXMgZXZlbnQgaXMgY2FuY2VsYWJsZS5cbiAgICAgKkBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZDMgKG9uUm93RWRpdENhbmNlbCk9XCJlZGl0Q2FuY2VsKCRldmVudClcIiBbZGF0YV09XCJkYXRhXCIgW3ByaW1hcnlLZXldPVwiJ1Byb2R1Y3RJRCdcIiBbcm93RWRpdGFibGVdPVwidHJ1ZVwiPlxuICAgICAqIDwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25Sb3dFZGl0Q2FuY2VsOiBFdmVudEVtaXR0ZXI8SUdyaWRFZGl0RXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gYSBjb2x1bW4gaXMgaW5pdGlhbGl6ZWQuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBSZXR1cm5zIHRoZSBjb2x1bW4gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJsb2NhbERhdGFcIiBbb25Db2x1bW5Jbml0XT1cImluaXRDb2x1bW5zKCRldmVudClcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9uQ29sdW1uSW5pdDogRXZlbnRFbWl0dGVyPElneENvbHVtbkNvbXBvbmVudD47XG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHNvcnRpbmcgaXMgcGVyZm9ybWVkIHRocm91Z2ggdGhlIFVJLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUmV0dXJucyB0aGUgc29ydGluZyBleHByZXNzaW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJsb2NhbERhdGFcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIiAob25Tb3J0aW5nRG9uZSk9XCJzb3J0aW5nRG9uZSgkZXZlbnQpXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBvblNvcnRpbmdEb25lOiBFdmVudEVtaXR0ZXI8SVNvcnRpbmdFeHByZXNzaW9uIHwgSVNvcnRpbmdFeHByZXNzaW9uW10+O1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBmaWx0ZXJpbmcgaXMgcGVyZm9ybWVkIHRocm91Z2ggdGhlIFVJLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUmV0dXJucyB0aGUgZmlsdGVyaW5nIGV4cHJlc3Npb25zIHRyZWUgb2YgdGhlIGNvbHVtbiBmb3Igd2hpY2ggZmlsdGVyaW5nIHdhcyBwZXJmb3JtZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cImxvY2FsRGF0YVwiIFtoZWlnaHRdPVwiJzMwNXB4J1wiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiIChvbkZpbHRlcmluZ0RvbmUpPVwiZmlsdGVyaW5nRG9uZSgkZXZlbnQpXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBvbkZpbHRlcmluZ0RvbmU6IEV2ZW50RW1pdHRlcjxJRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlPjtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gcGFnaW5nIGlzIHBlcmZvcm1lZC5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IGNvbnNpc3Rpbmcgb2YgdGhlIHByZXZpb3VzIGFuZCBuZXh0IHBhZ2VzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJsb2NhbERhdGFcIiBbaGVpZ2h0XT1cIiczMDVweCdcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIiAob25QYWdpbmdEb25lKT1cInBhZ2luZ0RvbmUoJGV2ZW50KVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25QYWdpbmdEb25lOiBFdmVudEVtaXR0ZXI8SVBhZ2VFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBhIHJvdyBhZGRlZCB0aHJvdWdoIHRoZSBBUEkuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXRhIGZvciB0aGUgbmV3IGBJZ3hHcmlkUm93Q29tcG9uZW50YCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cImxvY2FsRGF0YVwiIChvblJvd0FkZGVkKT1cInJvd0FkZGVkKCRldmVudClcIiBbaGVpZ2h0XT1cIiczMDVweCdcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9uUm93QWRkZWQ6IEV2ZW50RW1pdHRlcjxJUm93RGF0YUV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIGEgcm93IGlzIGRlbGV0ZWQgdGhyb3VnaCBBUEkuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBSZXR1cm5zIGFuIGBJUm93RGF0YUV2ZW50QXJnc2Agb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJsb2NhbERhdGFcIiAob25Sb3dEZWxldGVkKT1cInJvd0RlbGV0ZWQoJGV2ZW50KVwiIFtoZWlnaHRdPVwiJzMwNXB4J1wiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25Sb3dEZWxldGVkOiBFdmVudEVtaXR0ZXI8SVJvd0RhdGFFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBhIG5ldyBjaHVuayBvZiBkYXRhIGlzIGxvYWRlZCBmcm9tIHZpcnR1YWxpemF0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqICA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwibG9jYWxEYXRhXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCIgKG9uRGF0YVByZUxvYWQpPSdoYW5kbGVEYXRhUHJlbG9hZEV2ZW50KCknPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25EYXRhUHJlTG9hZDogRXZlbnRFbWl0dGVyPElGb3JPZlN0YXRlPjtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gY29sdW1uIGlzIHJlc2l6ZWQuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBSZXR1cm5zIHRoZSBgSWd4Q29sdW1uQ29tcG9uZW50YCBvYmplY3QncyBvbGQgYW5kIG5ldyB3aWR0aC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwibG9jYWxEYXRhXCIgKG9uQ29sdW1uUmVzaXplZCk9XCJyZXNpemluZygkZXZlbnQpXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBvbkNvbHVtblJlc2l6ZWQ6IEV2ZW50RW1pdHRlcjxJQ29sdW1uUmVzaXplRXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gYSBjZWxsIGlzIHJpZ2h0IGNsaWNrZWQuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBSZXR1cm5zIHRoZSBgSWd4R3JpZENlbGxDb21wb25lbnRgIG9iamVjdC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkICNncmlkIFtkYXRhXT1cImxvY2FsRGF0YVwiIChvbkNvbnRleHRNZW51KT1cImNvbnRleHRNZW51KCRldmVudClcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9uQ29udGV4dE1lbnU6IEV2ZW50RW1pdHRlcjxJR3JpZENlbGxFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBhIGNlbGwgaXMgZG91YmxlIGNsaWNrZWQuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBSZXR1cm5zIHRoZSBgSWd4R3JpZENlbGxDb21wb25lbnRgIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwibG9jYWxEYXRhXCIgKG9uRG91YmxlQ2xpY2spPVwiZGJsQ2xpY2soJGV2ZW50KVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25Eb3VibGVDbGljazogRXZlbnRFbWl0dGVyPElHcmlkQ2VsbEV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIGNvbHVtbiB2aXNpYmlsaXR5IGlzIGNoYW5nZWQuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBBcmdzOiB7IGNvbHVtbjogYW55LCBuZXdWYWx1ZTogYm9vbGVhbiB9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkIFtjb2x1bW5IaWRpbmddPVwidHJ1ZVwiIFtzaG93VG9vbGJhcl09XCJ0cnVlXCIgKG9uQ29sdW1uVmlzaWJpbGl0eUNoYW5nZWQpPVwidmlzaWJpbGl0eUNoYW5nZWQoJGV2ZW50KVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlZDogRXZlbnRFbWl0dGVyPElDb2x1bW5WaXNpYmlsaXR5Q2hhbmdlZEV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIGNvbHVtbiBtb3Zpbmcgc3RhcnRzLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUmV0dXJucyB0aGUgbW92ZWQgYElneENvbHVtbkNvbXBvbmVudGAgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCBbY29sdW1uSGlkaW5nXT1cInRydWVcIiBbc2hvd1Rvb2xiYXJdPVwidHJ1ZVwiIChvbkNvbHVtbk1vdmluZ1N0YXJ0KT1cIm1vdmluZ1N0YXJ0KCRldmVudClcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9uQ29sdW1uTW92aW5nU3RhcnQ6IEV2ZW50RW1pdHRlcjxJQ29sdW1uTW92aW5nU3RhcnRFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgZHVyaW5nIHRoZSBjb2x1bW4gbW92aW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFJldHVybnMgdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IGBJZ3hDb2x1bW5Db21wb25lbnRgIG9iamVjdHMuIFRoaXMgZXZlbnQgaXMgY2FuY2VsYWJsZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgW2NvbHVtbkhpZGluZ109XCJ0cnVlXCIgW3Nob3dUb29sYmFyXT1cInRydWVcIiAob25Db2x1bW5Nb3ZpbmcpPVwibW92aW5nKCRldmVudClcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9uQ29sdW1uTW92aW5nOiBFdmVudEVtaXR0ZXI8SUNvbHVtbk1vdmluZ0V2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIGNvbHVtbiBtb3ZpbmcgZW5kcy5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFJldHVybnMgdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IGBJZ3hDb2x1bW5Db21wb25lbnRgIG9iamVjdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkIFtjb2x1bW5IaWRpbmddPVwidHJ1ZVwiIFtzaG93VG9vbGJhcl09XCJ0cnVlXCIgKG9uQ29sdW1uTW92aW5nRW5kKT1cIm1vdmluZ0VuZHMoJGV2ZW50KVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25Db2x1bW5Nb3ZpbmdFbmQ6IEV2ZW50RW1pdHRlcjxJQ29sdW1uTW92aW5nRW5kRXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4ga2V5ZG93biBpcyB0cmlnZ2VyZWQgb3ZlciBlbGVtZW50IGluc2lkZSBncmlkJ3MgYm9keS5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb25seSBpZiB0aGUga2V5IGNvbWJpbmF0aW9uIGlzIHN1cHBvcnRlZCBpbiB0aGUgZ3JpZC5cbiAgICAgKiBSZXR1cm4gdGhlIHRhcmdldCB0eXBlLCB0YXJnZXQgb2JqZWN0IGFuZCB0aGUgb3JpZ2luYWwgZXZlbnQuIFRoaXMgZXZlbnQgaXMgY2FuY2VsYWJsZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiAgPGlneC1ncmlkIChvbkdyaWRLZXlkb3duKT1cImN1c3RvbUtleWRvd24oJGV2ZW50KVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25HcmlkS2V5ZG93bjogRXZlbnRFbWl0dGVyPElHcmlkS2V5ZG93bkV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHN0YXJ0IGRyYWdnaW5nIGEgcm93LlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUmV0dXJuIHRoZSBkcmFnZ2VkIHJvdy5cbiAgICAgKi9cbiAgICBvblJvd0RyYWdTdGFydDogRXZlbnRFbWl0dGVyPElSb3dEcmFnU3RhcnRFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBkcm9wcGluZyBhIHJvdy5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFJldHVybiB0aGUgZHJvcHBlZCByb3cuXG4gICAgICovXG4gICAgb25Sb3dEcmFnRW5kOiBFdmVudEVtaXR0ZXI8SVJvd0RyYWdFbmRFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBhIGNvcHkgb3BlcmF0aW9uIGlzIGV4ZWN1dGVkLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogRmlyZWQgb25seSBpZiBjb3B5IGJlaGF2aW9yIGlzIGVuYWJsZWQgdGhyb3VnaCB0aGUgW2BjbGlwYm9hcmRPcHRpb25zYF17QGxpbmsgSWd4R3JpZEJhc2VEaXJlY3RpdmUjY2xpcGJvYXJkT3B0aW9uc30uXG4gICAgICovXG4gICAgb25HcmlkQ29weTogRXZlbnRFbWl0dGVyPElHcmlkQ2xpcGJvYXJkRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBleHBhbnNpb25TdGF0ZXNDaGFuZ2U6IEV2ZW50RW1pdHRlcjxNYXA8YW55LCBib29sZWFuPj47XG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHRoZSBleHBhbmRlZCBzdGF0ZSBvZiBhIHJvdyBnZXRzIGNoYW5nZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIChvblJvd1RvZ2dsZSk9XCJyb3dUb2dnbGUoJGV2ZW50KVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25Sb3dUb2dnbGU6IEV2ZW50RW1pdHRlcjxJUm93VG9nZ2xlRXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHJlc2l6ZUxpbmU6IElneEdyaWRDb2x1bW5SZXNpemVyQ29tcG9uZW50O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgbG9hZGluZ092ZXJsYXk6IEVsZW1lbnRSZWY7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBsb2FkaW5nT3V0bGV0OiBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgY29sdW1uTGlzdDogUXVlcnlMaXN0PElneENvbHVtbkNvbXBvbmVudD47XG4gICAgLyoqXG4gICAgICpAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGV4Y2VsU3R5bGVTb3J0aW5nVGVtcGxhdGVEaXJlY3RpdmU6IElneEV4Y2VsU3R5bGVTb3J0aW5nVGVtcGxhdGVEaXJlY3RpdmU7XG4gICAgLyoqXG4gICAgICpAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGV4Y2VsU3R5bGVNb3ZpbmdUZW1wbGF0ZURpcmVjdGl2ZTogSWd4RXhjZWxTdHlsZU1vdmluZ1RlbXBsYXRlRGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBleGNlbFN0eWxlSGlkaW5nVGVtcGxhdGVEaXJlY3RpdmU6IElneEV4Y2VsU3R5bGVIaWRpbmdUZW1wbGF0ZURpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKkBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgZXhjZWxTdHlsZVBpbm5pbmdUZW1wbGF0ZURpcmVjdGl2ZTogSWd4RXhjZWxTdHlsZVBpbm5pbmdUZW1wbGF0ZURpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKkBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgZXhjZWxTdHlsZUxvYWRpbmdWYWx1ZXNUZW1wbGF0ZURpcmVjdGl2ZTogSWd4RXhjZWxTdHlsZUxvYWRpbmdWYWx1ZXNUZW1wbGF0ZURpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGhlYWRlckdyb3VwczogUXVlcnlMaXN0PElneEdyaWRIZWFkZXJHcm91cENvbXBvbmVudD47XG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGFsbCBgSWd4R3JpZEhlYWRlckdyb3VwQ29tcG9uZW50YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBoZWFkZXJHcm91cHNMaXN0ID0gdGhpcy5ncmlkLmhlYWRlckdyb3Vwc0xpc3Q7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGhlYWRlckdyb3Vwc0xpc3QoKTogSWd4R3JpZEhlYWRlckdyb3VwQ29tcG9uZW50W107XG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGFsbCBgSWd4R3JpZEhlYWRlckNvbXBvbmVudGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgaGVhZGVycyA9IHRoaXMuZ3JpZC5oZWFkZXJDZWxsTGlzdDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgaGVhZGVyQ2VsbExpc3QoKTogSWd4R3JpZEhlYWRlckNvbXBvbmVudFtdO1xuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBhbGwgYElneEdyaWRGaWx0ZXJpbmdDZWxsQ29tcG9uZW50YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBmaWx0ZXJDZWxscyA9IHRoaXMuZ3JpZC5maWx0ZXJDZWxsTGlzdDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgZmlsdGVyQ2VsbExpc3QoKTogSWd4R3JpZEZpbHRlcmluZ0NlbGxDb21wb25lbnRbXTtcbiAgICBwcml2YXRlIF9yb3dMaXN0O1xuICAgIHByb3RlY3RlZCBfc3VtbWFyeVJvd0xpc3Q6IFF1ZXJ5TGlzdDxJZ3hTdW1tYXJ5Um93Q29tcG9uZW50PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHN1bW1hcmllc1Jvd0xpc3QoKTogUXVlcnlMaXN0PGFueT47XG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGBJZ3hHcmlkUm93Q29tcG9uZW50YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCByb3dMaXN0ID0gdGhpcy5ncmlkLnJvd0xpc3Q7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHJvd0xpc3QoKTogUXVlcnlMaXN0PGFueT47XG4gICAgcHJpdmF0ZSBfZGF0YVJvd0xpc3Q7XG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGN1cnJlbnRseSByZW5kZXJlZCBgSWd4R3JpZFJvd0NvbXBvbmVudGAncy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBkYXRhTGlzdCA9IHRoaXMuZ3JpZC5kYXRhUm93TGlzdDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgZGF0YVJvd0xpc3QoKTogUXVlcnlMaXN0PElneFJvd0RpcmVjdGl2ZTxJZ3hHcmlkQmFzZURpcmVjdGl2ZT4+O1xuICAgIC8qKlxuICAgICAqIEEgdGVtcGxhdGUgcmVmZXJlbmNlIGZvciB0aGUgdGVtcGxhdGUgd2hlbiB0aGUgZmlsdGVyZWQgZ3JpZCBpcyBlbXB0eS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IGVtcHR5VGVtcGFsdGUgPSB0aGlzLmdyaWQuZW1wdHlHcmlkVGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZW1wdHlGaWx0ZXJlZEdyaWRUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBBIHRlbXBsYXRlIHJlZmVyZW5jZSBmb3IgdGhlIHRlbXBsYXRlIHdoZW4gdGhlIGdyaWQgaXMgZW1wdHkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBlbXB0eVRlbXBhbHRlID0gdGhpcy5ncmlkLmVtcHR5R3JpZFRlbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGVtcHR5R3JpZERlZmF1bHRUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgbG9hZGluZ0dyaWREZWZhdWx0VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwYXJlbnRWaXJ0RGlyOiBJZ3hHcmlkRm9yT2ZEaXJlY3RpdmU8YW55PjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSB3aGljaCB3aWxsIGJlIHVzZWQgYnkgdGhlIHRvb2xiYXIgdG8gc2hvdyBjdXN0b20gY29udGVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY3VzdG9tQ29udGVudFRlbXBsYXRlID0gdGhpcy5ncmlkLnRvb2xiYXJDdXN0b21Db250ZW50VGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgKi9cbiAgICBnZXQgdG9vbGJhckN1c3RvbUNvbnRlbnRUZW1wbGF0ZSgpOiBJZ3hHcmlkVG9vbGJhckN1c3RvbUNvbnRlbnREaXJlY3RpdmU7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRvb2xiYXJDdXN0b21Db250ZW50VGVtcGxhdGVzOiBRdWVyeUxpc3Q8SWd4R3JpZFRvb2xiYXJDdXN0b21Db250ZW50RGlyZWN0aXZlPjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0IGhlYWRTZWxlY3RvclRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPElneEhlYWRTZWxlY3RvckRpcmVjdGl2ZT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGhlYWRTZWxlY3RvcnNUZW1wbGF0ZXM6IFF1ZXJ5TGlzdDxJZ3hIZWFkU2VsZWN0b3JEaXJlY3RpdmU+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXQgcm93U2VsZWN0b3JUZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxJZ3hSb3dTZWxlY3RvckRpcmVjdGl2ZT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHJvd1NlbGVjdG9yc1RlbXBsYXRlczogUXVlcnlMaXN0PElneFJvd1NlbGVjdG9yRGlyZWN0aXZlPjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZHJhZ0dob3N0Q3VzdG9tVGVtcGxhdGVzOiBRdWVyeUxpc3Q8VGVtcGxhdGVSZWY8YW55Pj47XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB2ZXJ0aWNhbFNjcm9sbENvbnRhaW5lcjogSWd4R3JpZEZvck9mRGlyZWN0aXZlPGFueT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB2ZXJ0aWNhbFNjcm9sbDogSWd4R3JpZEZvck9mRGlyZWN0aXZlPGFueT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzY3I6IEVsZW1lbnRSZWY7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBmb290ZXI6IEVsZW1lbnRSZWY7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBoZWFkZXJDb250YWluZXI6IElneEdyaWRGb3JPZkRpcmVjdGl2ZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgaGVhZGVyU2VsZWN0b3JDb250YWluZXI6IEVsZW1lbnRSZWY7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBoZWFkZXJEcmFnQ29udGFpbmVyOiBFbGVtZW50UmVmO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgaGVhZGVyR3JvdXBDb250YWluZXI6IEVsZW1lbnRSZWY7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBmaWx0ZXJpbmdSb3c6IElneEdyaWRGaWx0ZXJpbmdSb3dDb21wb25lbnQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGVhZFJvdzogRWxlbWVudFJlZjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRib2R5OiBFbGVtZW50UmVmO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgKi9cbiAgICB0Zm9vdDogRWxlbWVudFJlZjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfb3V0bGV0RGlyZWN0aXZlOiBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0IG91dGxldERpcmVjdGl2ZSgpOiBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcm93RWRpdGluZ091dGxldERpcmVjdGl2ZTogSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG1wT3V0bGV0czogUXVlcnlMaXN0PGFueT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCByb3dPdXRsZXREaXJlY3RpdmUoKTogSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHBhcmVudFJvd091dGxldERpcmVjdGl2ZSgpOiBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBkcmFnSW5kaWNhdG9ySWNvbkJhc2U6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHByaXZhdGUgZGVmYXVsdFJvd0VkaXRUZW1wbGF0ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgcm93RWRpdEN1c3RvbTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldCByb3dFZGl0Q29udGFpbmVyKCk6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICByb3dFZGl0VGV4dDogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHJvd0VkaXRBY3Rpb25zOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICogVGhlIGN1c3RvbSB0ZW1wbGF0ZSwgaWYgYW55LCB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nIGEgcm93IGV4cGFuZCBpbmRpY2F0b3IuXG4gICAgKi9cbiAgICByb3dFeHBhbmRlZEluZGljYXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICogVGhlIGN1c3RvbSB0ZW1wbGF0ZSwgaWYgYW55LCB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nIGEgcm93IGNvbGxhcHNlIGluZGljYXRvci5cbiAgICAqL1xuICAgIHJvd0NvbGxhcHNlZEluZGljYXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICogVGhlIGN1c3RvbSB0ZW1wbGF0ZSwgaWYgYW55LCB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nIGEgaGVhZGVyIGV4cGFuZCBpbmRpY2F0b3IuXG4gICAgKi9cbiAgICBoZWFkZXJFeHBhbmRJbmRpY2F0b3JUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAqIFRoZSBjdXN0b20gdGVtcGxhdGUsIGlmIGFueSwgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIHJlbmRlcmluZyBhIGhlYWRlciBjb2xsYXBzZSBpbmRpY2F0b3IuXG4gICAgKi9cbiAgICBoZWFkZXJDb2xsYXBzZUluZGljYXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBkcmFnSW5kaWNhdG9ySWNvblRlbXBsYXRlczogUXVlcnlMaXN0PFRlbXBsYXRlUmVmPGFueT4+O1xuICAgIC8qKlxuICAgICogVGhlIGN1c3RvbSB0ZW1wbGF0ZSwgaWYgYW55LCB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nIHRoZSByb3cgZHJhZyBpbmRpY2F0b3IgaWNvblxuICAgICovXG4gICAgZ2V0IGRyYWdJbmRpY2F0b3JJY29uVGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICBzZXQgZHJhZ0luZGljYXRvckljb25UZW1wbGF0ZSh2YWw6IFRlbXBsYXRlUmVmPGFueT4pO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgcm93SW5FZGl0TW9kZSgpOiBJZ3hSb3dEaXJlY3RpdmU8SWd4R3JpZEJhc2VEaXJlY3RpdmUgJiBHcmlkVHlwZT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXQgZmlyc3RFZGl0YWJsZUNvbHVtbkluZGV4KCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldCBsYXN0RWRpdGFibGVDb2x1bW5JbmRleCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICByb3dFZGl0VGFic0RFRkFVTFQ6IFF1ZXJ5TGlzdDxJZ3hSb3dFZGl0VGFiU3RvcERpcmVjdGl2ZT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICByb3dFZGl0VGFic0NVU1RPTTogUXVlcnlMaXN0PElneFJvd0VkaXRUYWJTdG9wRGlyZWN0aXZlPjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFRPRE86IE5hdiBzZXJ2aWNlIGxvZ2ljIGRvZXNuJ3QgaGFuZGxlIDAgcmVzdWx0cyBmcm9tIHRoaXMgcXVlcnlsaXN0XG4gICAgICovXG4gICAgZ2V0IHJvd0VkaXRUYWJzKCk6IFF1ZXJ5TGlzdDxJZ3hSb3dFZGl0VGFiU3RvcERpcmVjdGl2ZT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICByb3dFZGl0aW5nT3ZlcmxheTogSWd4VG9nZ2xlRGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgdGFiaW5kZXg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldCBob3N0Q2xhc3MoKTogc3RyaW5nO1xuICAgIGdldCBiYW5uZXJDbGFzcygpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBob3N0Um9sZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0IHBpcGVUcmlnZ2VyKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldCBmaWx0ZXJpbmdQaXBlVHJpZ2dlcigpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXQgc3VtbWFyeVBpcGVUcmlnZ2VyKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIHNvcnRpbmcgc3RhdGUuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBTdXBwb3J0cyB0d28td2F5IGRhdGEgYmluZGluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwiRGF0YVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiIFsoc29ydGluZ0V4cHJlc3Npb25zKV09XCJtb2RlbC5zb3J0aW5nRXhwcmVzc2lvbnNcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBzb3J0aW5nRXhwcmVzc2lvbnMoKTogSVNvcnRpbmdFeHByZXNzaW9uW107XG4gICAgc2V0IHNvcnRpbmdFeHByZXNzaW9ucyh2YWx1ZTogSVNvcnRpbmdFeHByZXNzaW9uW10pO1xuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgYmVmb3JlIHNvcnRpbmcgaXMgcGVyZm9ybWVkLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUmV0dXJucyB0aGUgc29ydGluZyBleHByZXNzaW9ucy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwibG9jYWxEYXRhXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCIgKHNvcnRpbmdFeHByZXNzaW9uc0NoYW5nZSk9XCJzb3J0aW5nRXhwckNoYW5nZSgkZXZlbnQpXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAqL1xuICAgIHNvcnRpbmdFeHByZXNzaW9uc0NoYW5nZTogRXZlbnRFbWl0dGVyPElTb3J0aW5nRXhwcmVzc2lvbltdPjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldCBtYXhMZXZlbEhlYWRlckRlcHRoKCk6IGFueTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgaGlkZGVuIGNvbHVtbnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgaGlkZGVuQ29sID0gdGhpcy5ncmlkLmhpZGRlbkNvbHVtbnNDb3VudDtcbiAgICAgKiBgYFxuICAgICAqL1xuICAgIGdldCBoaWRkZW5Db2x1bW5zQ291bnQoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgdGV4dCB0byBiZSBkaXNwbGF5ZWQgaW5zaWRlIHRoZSB0b2dnbGUgYnV0dG9uLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVXNlZCBmb3IgdGhlIGJ1aWx0LWluIGNvbHVtbiBoaWRpbmcgVUkgb2YgdGhlYElneENvbHVtbkNvbXBvbmVudGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkIFtjb2x1bW5IaWRpbmddPVwidHJ1ZVwiIFtzaG93VG9vbGJhcl09XCJ0cnVlXCIgW2hpZGRlbkNvbHVtbnNUZXh0XT1cIidIaWRkZW4gQ29sdW1ucydcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBoaWRkZW5Db2x1bW5zVGV4dCgpOiBzdHJpbmc7XG4gICAgc2V0IGhpZGRlbkNvbHVtbnNUZXh0KHZhbHVlOiBzdHJpbmcpO1xuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgdGV4dCB0byBiZSBkaXNwbGF5ZWQgaW5zaWRlIHRoZSB0b2dnbGUgYnV0dG9uLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVXNlZCBmb3IgdGhlIGJ1aWx0LWluIGNvbHVtbiBwaW5uaW5nIFVJIG9mIHRoZWBJZ3hDb2x1bW5Db21wb25lbnRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCBbcGlubmVkQ29sdW1uc1RleHRdPVwiJ1Bpbm5lZENvbHMgVGV4dFwiIFtkYXRhXT1cImRhdGFcIiBbd2lkdGhdPVwiJzEwMCUnXCIgW2hlaWdodF09XCInNTAwcHgnXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgcGlubmVkQ29sdW1uc1RleHQoKTogc3RyaW5nO1xuICAgIHNldCBwaW5uZWRDb2x1bW5zVGV4dCh2YWx1ZTogc3RyaW5nKTtcbiAgICAvKipcbiAgICAgKiBHZXQgdHJhbnNhY3Rpb25zIHNlcnZpY2UgZm9yIHRoZSBncmlkLlxuICAgICAqL1xuICAgIGdldCB0cmFuc2FjdGlvbnMoKTogVHJhbnNhY3Rpb25TZXJ2aWNlPFRyYW5zYWN0aW9uLCBTdGF0ZT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbHVtbnNXaXRoTm9TZXRXaWR0aHM6IGFueTtcbiAgICBwcml2YXRlIF9zaG93VG9vbGJhcjtcbiAgICBwcml2YXRlIF9leHBvcnRFeGNlbDtcbiAgICBwcml2YXRlIF9leHBvcnRDc3Y7XG4gICAgcHJpdmF0ZSBfdG9vbGJhclRpdGxlO1xuICAgIHByaXZhdGUgX2V4cG9ydFRleHQ7XG4gICAgcHJpdmF0ZSBfZXhwb3J0RXhjZWxUZXh0O1xuICAgIHByaXZhdGUgX2V4cG9ydENzdlRleHQ7XG4gICAgcHJpdmF0ZSBfcm93RWRpdGFibGU7XG4gICAgcHJpdmF0ZSBfY3VycmVudFJvd1N0YXRlO1xuICAgIHByaXZhdGUgX2ZpbHRlcmVkU29ydGVkRGF0YTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGN1cnJlbnRSb3dTdGF0ZSgpOiBhbnk7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBgSWd4VG9vbGJhckNvbXBvbmVudGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZ3JpZFRvb2xiYXIgPSB0aGlzLmdyaWQudG9vbGJhcjtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB0b29sYmFyOiBJZ3hHcmlkVG9vbGJhckNvbXBvbmVudDtcbiAgICBwcml2YXRlIHRvb2xiYXJIdG1sO1xuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB3aGV0aGVyIHRoZSB0b29sYmFyIGlzIHNob3duLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCBbZGF0YV09XCJsb2NhbERhdGFcIiBbc2hvd1Rvb2xiYXJdPVwidHJ1ZVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiID48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBzaG93VG9vbGJhcigpOiBib29sZWFuO1xuICAgIHNldCBzaG93VG9vbGJhcihuZXdWYWx1ZTogYm9vbGVhbik7XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSB0b29sYmFyJ3MgdGl0bGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkIFtkYXRhXT1cImxvY2FsRGF0YVwiIFtzaG93VG9vbGJhcl09XCJ0cnVlXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCIgW3Rvb2xiYXJUaXRsZV09XCInTXkgR3JpZCdcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCB0b29sYmFyVGl0bGUoKTogc3RyaW5nO1xuICAgIHNldCB0b29sYmFyVGl0bGUobmV3VmFsdWU6IHN0cmluZyk7XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHdoZXRoZXIgZXhwb3J0aW5nIHRvIE1TIEV4Y2VsIGlzIGVuYWJsZWQgb3IgZGlzYWJsZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkIFtkYXRhXT1cImxvY2FsRGF0YVwiIFtzaG93VG9vbGJhcl09XCJ0cnVlXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCIgW2V4cG9ydEV4Y2VsXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBleHBvcnRFeGNlbCgpOiBib29sZWFuO1xuICAgIHNldCBleHBvcnRFeGNlbChuZXdWYWx1ZTogYm9vbGVhbik7XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHdoZXRoZXIgdGhlIG9wdGlvbiBmb3IgZXhwb3J0aW5nIHRvIENTViBpcyBlbmFibGVkIG9yIGRpc2FibGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgW2RhdGFdPVwibG9jYWxEYXRhXCIgW3Nob3dUb29sYmFyXT1cInRydWVcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIiBbZXhwb3J0Q3N2XT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBleHBvcnRDc3YoKTogYm9vbGVhbjtcbiAgICBzZXQgZXhwb3J0Q3N2KG5ld1ZhbHVlOiBib29sZWFuKTtcbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIHRleHR1YWwgY29udGVudCBmb3IgdGhlIG1haW4gZXhwb3J0IGJ1dHRvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgW2RhdGFdPVwibG9jYWxEYXRhXCIgW3Nob3dUb29sYmFyXT1cInRydWVcIiBbZXhwb3J0VGV4dF09XCInTXkgRXhwb3J0ZXInXCIgW2V4cG9ydENzdl09XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgZXhwb3J0VGV4dCgpOiBzdHJpbmc7XG4gICAgc2V0IGV4cG9ydFRleHQobmV3VmFsdWU6IHN0cmluZyk7XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSB0ZXh0dWFsIGNvbnRlbnQgZm9yIHRoZSBNUyBFeGNlbCBleHBvcnQgYnV0dG9uLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgW2V4cG9ydEV4Y2VsVGV4dF09XCInTXkgRXhjZWwgRXhwb3J0ZXJcIiBbc2hvd1Rvb2xiYXJdPVwidHJ1ZVwiIFtleHBvcnRUZXh0XT1cIidNeSBFeHBvcnRlcidcIiBbZXhwb3J0Q3N2XT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBleHBvcnRFeGNlbFRleHQoKTogc3RyaW5nO1xuICAgIHNldCBleHBvcnRFeGNlbFRleHQobmV3VmFsdWU6IHN0cmluZyk7XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSB0ZXh0dWFsIGNvbnRlbnQgZm9yIHRoZSBDU1YgZXhwb3J0IGJ1dHRvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgW2V4cG9ydENzdlRleHRdPVwiJ015IENzdiBFeHBvcnRlclwiIFtzaG93VG9vbGJhcl09XCJ0cnVlXCIgW2V4cG9ydFRleHRdPVwiJ015IEV4cG9ydGVyJ1wiIFtleHBvcnRFeGNlbF09XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgZXhwb3J0Q3N2VGV4dCgpOiBzdHJpbmc7XG4gICAgc2V0IGV4cG9ydENzdlRleHQobmV3VmFsdWU6IHN0cmluZyk7XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgdGhlIGNvcHkgYmVoYXZpb3Igb2YgdGhlIGdyaWQuXG4gICAgICovXG4gICAgY2xpcGJvYXJkT3B0aW9uczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlcy9kaXNhYmxlcyB0aGUgY29weSBiZWhhdmlvclxuICAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlZDogYm9vbGVhbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluY2x1ZGUgdGhlIGNvbHVtbnMgaGVhZGVycyBpbiB0aGUgY2xpcGJvYXJkIG91dHB1dC5cbiAgICAgICAgICovXG4gICAgICAgIGNvcHlIZWFkZXJzOiBib29sZWFuO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgdGhlIGNvbHVtbnMgZm9ybWF0dGVycyAoaWYgYW55KSBvbiB0aGUgZGF0YSBpbiB0aGUgY2xpcGJvYXJkIG91dHB1dC5cbiAgICAgICAgICovXG4gICAgICAgIGNvcHlGb3JtYXR0ZXJzOiBib29sZWFuO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNlcGFyYXRvciB1c2VkIGZvciBmb3JtYXR0aW5nIHRoZSBjb3B5IG91dHB1dC4gRGVmYXVsdHMgdG8gYFxcdGAuXG4gICAgICAgICAqL1xuICAgICAgICBzZXBhcmF0b3I6IHN0cmluZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyBjZWxsIHNlbGVjdGlvbiBtb2RlLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQnkgZGVmYXVsdCB0aGUgY2VsbCBzZWxlY3Rpb24gbW9kZSBpcyBtdWx0aXBsZVxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25Nb2RlOiBHcmlkU2VsZWN0aW9uTW9kZVxuICAgICovXG4gICAgZ2V0IGNlbGxTZWxlY3Rpb24oKTogR3JpZFNlbGVjdGlvbk1vZGU7XG4gICAgc2V0IGNlbGxTZWxlY3Rpb24oc2VsZWN0aW9uTW9kZTogR3JpZFNlbGVjdGlvbk1vZGUpO1xuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyByb3cgc2VsZWN0aW9uIG1vZGVcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEJ5IGRlZmF1bHQgdGhlIHJvdyBzZWxlY3Rpb24gbW9kZSBpcyBub25lXG4gICAgICogQHBhcmFtIHNlbGVjdGlvbk1vZGU6IEdyaWRTZWxlY3Rpb25Nb2RlXG4gICAgKi9cbiAgICBnZXQgcm93U2VsZWN0aW9uKCk6IEdyaWRTZWxlY3Rpb25Nb2RlO1xuICAgIHNldCByb3dTZWxlY3Rpb24oc2VsZWN0aW9uTW9kZTogR3JpZFNlbGVjdGlvbk1vZGUpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcm93RWRpdE1lc3NhZ2U6IGFueTtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gYW4gZXhwb3J0IHByb2Nlc3MgaXMgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRvb2xiYXJFeHBvcnRpbmcoZXZlbnQ6IElHcmlkVG9vbGJhckV4cG9ydEV2ZW50QXJncyl7XG4gICAgICogICAgIGNvbnN0IHRvb2xiYXJFeHBvcnRpbmcgPSBldmVudDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25Ub29sYmFyRXhwb3J0aW5nOiBFdmVudEVtaXR0ZXI8SUdyaWRUb29sYmFyRXhwb3J0RXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gbWFraW5nIGEgcmFuZ2Ugc2VsZWN0aW9uLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUmFuZ2Ugc2VsZWN0aW9uIGNhbiBiZSBtYWRlIGVpdGhlciB0aHJvdWdoIGRyYWcgc2VsZWN0aW9uIG9yIHRocm91Z2gga2V5Ym9hcmQgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIG9uUmFuZ2VTZWxlY3Rpb246IEV2ZW50RW1pdHRlcjxHcmlkU2VsZWN0aW9uUmFuZ2U+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcGFnaW5nU3RhdGU6IGFueTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNhbGNXaWR0aDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgY2FsY0hlaWdodDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgdGZvb3RIZWlnaHQ6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNoaXBzR291cGluZ0V4cHJlc3Npb25zOiBhbnlbXTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN1bW1hcmllc0hlaWdodDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgZHJhZ2dlZENvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgZGlzYWJsZVRyYW5zaXRpb25zOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgbGFzdFNlYXJjaEluZm86IElTZWFyY2hJbmZvO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgY29sdW1uV2lkdGhTZXRCeVVzZXI6IGJvb2xlYW47XG4gICAgZGF0YTogYW55W107XG4gICAgZmlsdGVyZWREYXRhOiBhbnlbXTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRlc3Ryb3kkOiBTdWJqZWN0PGFueT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfcGVyUGFnZTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3BhZ2U6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9wYWdpbmc6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfaGlkZVJvd1NlbGVjdG9yczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9yb3dEcmFnOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3BpcGVUcmlnZ2VyOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZmlsdGVyaW5nUGlwZVRyaWdnZXI6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9zdW1tYXJ5UGlwZVRyaWdnZXI6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9jb2x1bW5zOiBJZ3hDb2x1bW5Db21wb25lbnRbXTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9waW5uZWRDb2x1bW5zOiBJZ3hDb2x1bW5Db21wb25lbnRbXTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF91bnBpbm5lZENvbHVtbnM6IElneENvbHVtbkNvbXBvbmVudFtdO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2ZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZTogSUZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9hZHZhbmNlZEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZTogSUZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9zb3J0aW5nRXhwcmVzc2lvbnM6IEFycmF5PElTb3J0aW5nRXhwcmVzc2lvbj47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfbWF4TGV2ZWxIZWFkZXJEZXB0aDogYW55O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2NvbHVtbkhpZGluZzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9jb2x1bW5QaW5uaW5nOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2hhc1Zpc2libGVDb2x1bW5zOiBhbnk7XG4gICAgcHJvdGVjdGVkIF9hbGxvd0ZpbHRlcmluZzogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgX2FsbG93QWR2YW5jZWRGaWx0ZXJpbmc6IGJvb2xlYW47XG4gICAgcHJvdGVjdGVkIF9maWx0ZXJNb2RlOiBGaWx0ZXJNb2RlO1xuICAgIHByb3RlY3RlZCBvYnNlcnZlcjogUmVzaXplT2JzZXJ2ZXI7XG4gICAgcHJvdGVjdGVkIHJlc2l6ZU5vdGlmeTogU3ViamVjdDx1bmtub3duPjtcbiAgICBwcml2YXRlIGNvbHVtbkxpc3REaWZmZXI7XG4gICAgcHJpdmF0ZSBfaGlkZGVuQ29sdW1uc1RleHQ7XG4gICAgcHJpdmF0ZSBfcGlubmVkQ29sdW1uc1RleHQ7XG4gICAgcHJpdmF0ZSBfaGVpZ2h0O1xuICAgIHByaXZhdGUgX3dpZHRoO1xuICAgIHByaXZhdGUgX3Jvd0hlaWdodDtcbiAgICBwcm90ZWN0ZWQgX2Jhc2VGb250U2l6ZTogbnVtYmVyO1xuICAgIHByaXZhdGUgX2hvcml6b250YWxGb3JPZnM7XG4gICAgcHJpdmF0ZSBfbXVsdGlSb3dMYXlvdXRSb3dTaXplO1xuICAgIHByb3RlY3RlZCBfbG9hZGluZ0lkOiBhbnk7XG4gICAgcHJvdGVjdGVkIF9leHBhbnNpb25TdGF0ZXM6IE1hcDxhbnksIGJvb2xlYW4+O1xuICAgIHByb3RlY3RlZCBfZGVmYXVsdEV4cGFuZFN0YXRlOiBib29sZWFuO1xuICAgIHByaXZhdGUgX3RvdGFsV2lkdGg7XG4gICAgcHJpdmF0ZSBfcGlubmVkVmlzaWJsZTtcbiAgICBwcml2YXRlIF91bnBpbm5lZFZpc2libGU7XG4gICAgcHJpdmF0ZSBfcGlubmVkV2lkdGg7XG4gICAgcHJpdmF0ZSBfdW5waW5uZWRXaWR0aDtcbiAgICBwcml2YXRlIF92aXNpYmxlQ29sdW1ucztcbiAgICBwcml2YXRlIF9jb2x1bW5Hcm91cHM7XG4gICAgcHJpdmF0ZSBfYXV0b0dlbmVyYXRlZENvbHM7XG4gICAgcHJvdGVjdGVkIF9oZWFkZXJGZWF0dXJlc1dpZHRoOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfY29sdW1uV2lkdGg7XG4gICAgcHJvdGVjdGVkIF9kZWZhdWx0VGFyZ2V0UmVjb3JkTnVtYmVyOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfc3VtbWFyeVBvc2l0aW9uO1xuICAgIHByaXZhdGUgX3N1bW1hcnlDYWxjdWxhdGlvbk1vZGU7XG4gICAgcHJpdmF0ZSBfY2VsbFNlbGVjdGlvbk1vZGU7XG4gICAgcHJpdmF0ZSBfcm93U2VsZWN0aW9uTW9kZTtcbiAgICBwcml2YXRlIHJvd0VkaXRQb3NpdGlvbmluZ1N0cmF0ZWd5O1xuICAgIHByaXZhdGUgcm93RWRpdFNldHRpbmdzO1xuICAgIHByaXZhdGUgdmVydGljYWxTY3JvbGxIYW5kbGVyO1xuICAgIHByaXZhdGUgaG9yaXpvbnRhbFNjcm9sbEhhbmRsZXI7XG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlzRGV0YWlsUmVjb3JkKHJlYzogYW55KTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgaXNHcm91cEJ5UmVjb3JkKHJlYzogYW55KTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGhhc0RldGFpbHMoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSBvZiB0aGUgZ3JpZCB2aXJ0dWFsaXphdGlvbi5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEluY2x1ZGVzIHRoZSBzdGFydCBpbmRleCBhbmQgaG93IG1hbnkgcmVjb3JkcyBhcmUgcmVuZGVyZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZ3JpZFZpcnRTdGF0ZSA9IHRoaXMuZ3JpZDEudmlydHVhbGl6YXRpb25TdGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgdmlydHVhbGl6YXRpb25TdGF0ZSgpOiBJRm9yT2ZTdGF0ZTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IHZpcnR1YWxpemF0aW9uU3RhdGUoc3RhdGU6IElGb3JPZlN0YXRlKTtcbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgaGlkZU92ZXJsYXlzKCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBrZXlkb3duSGFuZGxlcjtcbiAgICBjb25zdHJ1Y3RvcihzZWxlY3Rpb25TZXJ2aWNlOiBJZ3hHcmlkU2VsZWN0aW9uU2VydmljZSwgY3J1ZFNlcnZpY2U6IElneEdyaWRDUlVEU2VydmljZSwgY29sUmVzaXppbmdTZXJ2aWNlOiBJZ3hDb2x1bW5SZXNpemluZ1NlcnZpY2UsIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZURpcmVjdGl2ZSAmIEdyaWRUeXBlPiwgX3RyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25TZXJ2aWNlPFRyYW5zYWN0aW9uLCBTdGF0ZT4sIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHpvbmU6IE5nWm9uZSwgZG9jdW1lbnQ6IGFueSwgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZiwgcmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLCB2aWV3UmVmOiBWaWV3Q29udGFpbmVyUmVmLCBuYXZpZ2F0aW9uOiBJZ3hHcmlkTmF2aWdhdGlvblNlcnZpY2UsIGZpbHRlcmluZ1NlcnZpY2U6IElneEZpbHRlcmluZ1NlcnZpY2UsIG92ZXJsYXlTZXJ2aWNlOiBJZ3hPdmVybGF5U2VydmljZSwgc3VtbWFyeVNlcnZpY2U6IElneEdyaWRTdW1tYXJ5U2VydmljZSwgX2Rpc3BsYXlEZW5zaXR5T3B0aW9uczogSURpc3BsYXlEZW5zaXR5T3B0aW9ucyk7XG4gICAgX3NldHVwU2VydmljZXMoKTogdm9pZDtcbiAgICBfc2V0dXBMaXN0ZW5lcnMoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgc2V0dXBDb2x1bW5zKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHJlc2V0Q29sdW1uc0NhY2hlcygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICByZXNldEZvck9mQ2FjaGUoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcmVzZXRDb2x1bW5Db2xsZWN0aW9ucygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICByZXNldENhY2hlZFdpZHRocygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICByZXNldENhY2hlcyhyZWNhbGNGZWF0dXJlV2lkdGg/OiBib29sZWFuKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfc2V0dXBSb3dPYnNlcnZlcnMoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgX3pvbmVCZWdvbmVMaXN0ZW5lcnMoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG5vdGlmeUNoYW5nZXMocmVwYWludD86IGJvb2xlYW4pOiB2b2lkO1xuICAgIHByb3RlY3RlZCByZXNldE5vdGlmeUNoYW5nZXMoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgbmdEb0NoZWNrKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0RHJhZ0dob3N0Q3VzdG9tVGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRhdGFMb2FkaW5nKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIHNwZWNpZmllZCBjb2x1bW4ncyB2aXNpYmlsaXR5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZDEudG9nZ2xlQ29sdW1uVmlzaWJpbGl0eSh7XG4gICAgICogICAgICAgY29sdW1uOiB0aGlzLmdyaWQxLmNvbHVtbnNbMF0sXG4gICAgICogICAgICAgbmV3VmFsdWU6IHRydWVcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB0b2dnbGVDb2x1bW5WaXNpYmlsaXR5KGFyZ3M6IElDb2x1bW5WaXNpYmlsaXR5Q2hhbmdlZEV2ZW50QXJncyk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIGEgbGlzdCBvZiBrZXktdmFsdWUgcGFpcnMgW3JvdyBJRCwgZXhwYW5zaW9uIHN0YXRlXS5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEluY2x1ZGVzIG9ubHkgc3RhdGVzIHRoYXQgZGlmZmVyIGZyb20gdGhlIGRlZmF1bHQgb25lLlxuICAgICAqIFN1cHBvcnRzIHR3by13YXkgYmluZGluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwiZGF0YVwiIFsoZXhwYW5zaW9uU3RhdGVzKV09XCJtb2RlbC5leHBhbnNpb25TdGF0ZXNcIj5cbiAgICAgKiA8L2lneC1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBleHBhbnNpb25TdGF0ZXMoKTogTWFwPGFueSwgYm9vbGVhbj47XG4gICAgc2V0IGV4cGFuc2lvblN0YXRlcyh2YWx1ZTogTWFwPGFueSwgYm9vbGVhbj4pO1xuICAgIC8qKlxuICAgICAgKiBFeHBhbmRzIGFsbCByb3dzLlxuICAgICAgKiBAZXhhbXBsZVxuICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAqIHRoaXMuZ3JpZC5leHBhbmRBbGwoKTtcbiAgICAgICogYGBgXG4gICAgICovXG4gICAgZXhwYW5kQWxsKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICAqIENvbGxhcHNlcyBhbGwgcm93cy5cbiAgICAgICogQGV4YW1wbGVcbiAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgKiB0aGlzLmdyaWQuY29sbGFwc2VBbGwoKTtcbiAgICAgICogYGBgXG4gICAgICovXG4gICAgY29sbGFwc2VBbGwoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIHRoZSByb3cgYnkgaXRzIGlkLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSUQgaXMgZWl0aGVyIHRoZSBwcmltYXJ5S2V5IHZhbHVlIG9yIHRoZSBkYXRhIHJlY29yZCBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuZXhwYW5kUm93KHJvd0lEKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gcm93SUQgVGhlIHJvdyBpZCAtIHByaW1hcnlLZXkgdmFsdWUgb3IgdGhlIGRhdGEgcmVjb3JkIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGV4cGFuZFJvdyhyb3dJRDogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgdGhlIHJvdyBieSBpdHMgaWQuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJRCBpcyBlaXRoZXIgdGhlIHByaW1hcnlLZXkgdmFsdWUgb3IgdGhlIGRhdGEgcmVjb3JkIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5jb2xsYXBzZVJvdyhyb3dJRCk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHJvd0lEIFRoZSByb3cgaWQgLSBwcmltYXJ5S2V5IHZhbHVlIG9yIHRoZSBkYXRhIHJlY29yZCBpbnN0YW5jZS5cbiAgICAqL1xuICAgIGNvbGxhcHNlUm93KHJvd0lEOiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIHJvdyBieSBpdHMgaWQuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJRCBpcyBlaXRoZXIgdGhlIHByaW1hcnlLZXkgdmFsdWUgb3IgdGhlIGRhdGEgcmVjb3JkIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC50b2dnbGVSb3cocm93SUQpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSByb3dJRCBUaGUgcm93IGlkIC0gcHJpbWFyeUtleSB2YWx1ZSBvciB0aGUgZGF0YSByZWNvcmQgaW5zdGFuY2UuXG4gICAgKi9cbiAgICB0b2dnbGVSb3cocm93SUQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0RGVmYXVsdEV4cGFuZFN0YXRlKHJlYzogYW55KTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgZWxlbWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBuYXRpdmVFbCA9IHRoaXMuZ3JpZC5uYXRpdmVFbGVtZW50LlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBuYXRpdmVFbGVtZW50KCk6IGFueTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXQgb3V0bGV0KCk6IElneE92ZXJsYXlPdXRsZXREaXJlY3RpdmU7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVmYXVsdCByb3cgaGVpZ2h0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHJvd0hlaWdoID0gdGhpcy5ncmlkLmRlZmF1bHRSb3dIZWlnaHQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGRlZmF1bHRSb3dIZWlnaHQoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0IGRlZmF1bHRTdW1tYXJ5SGVpZ2h0KCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgSWd4R3JpZEhlYWRlckdyb3VwQ29tcG9uZW50YCdzIG1pbmltdW0gYWxsb3dlZCB3aWR0aC5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFVzZWQgaW50ZXJuYWxseSBmb3IgcmVzdHJpY3RpbmcgaGVhZGVyIGdyb3VwIGNvbXBvbmVudCB3aWR0aC5cbiAgICAgKiBUaGUgdmFsdWVzIGJlbG93IGRlcGVuZCBvbiB0aGUgaGVhZGVyIGNlbGwgZGVmYXVsdCByaWdodC9sZWZ0IHBhZGRpbmcgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldCBkZWZhdWx0SGVhZGVyR3JvdXBNaW5XaWR0aCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwYWdpbmF0b3JDbGFzc05hbWUoKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlIGNvbnRhaW5lciBmb3IgdGhlIHBpbm5lZCBgSWd4Q29sdW1uQ29tcG9uZW50YHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgcGlubmVkV2lkdGggPSB0aGlzLmdyaWQuZ2V0UGlubmVkV2lkdGg7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHBpbm5lZFdpZHRoKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBjb250YWluZXIgZm9yIHRoZSB1bnBpbm5lZCBgSWd4Q29sdW1uQ29tcG9uZW50YHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgdW5waW5uZWRXaWR0aCA9IHRoaXMuZ3JpZC5nZXRVbnBpbm5lZFdpZHRoO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCB1bnBpbm5lZFdpZHRoKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlzSG9yaXpvbnRhbFNjcm9sbEhpZGRlbigpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogR2V0cyB0aGUgY29tYmluZWQgd2lkdGggb2YgdGhlIGNvbHVtbnMgdGhhdCBhcmUgc3BlY2lmaWMgdG8gdGhlIGVuYWJsZWQgZ3JpZCBmZWF0dXJlcy4gVGhleSBhcmUgZml4ZWQuXG4gICAgICovXG4gICAgZmVhdHVyZUNvbHVtbnNXaWR0aChleHBhbmRlcj86IEVsZW1lbnRSZWYpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBzdW1tYXJpZXNNYXJnaW4oKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEdldHMgYW4gYXJyYXkgb2YgYElneENvbHVtbkNvbXBvbmVudGBzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGNvbHVtcyA9IHRoaXMuZ3JpZC5jb2x1bW5zLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBjb2x1bW5zKCk6IElneENvbHVtbkNvbXBvbmVudFtdO1xuICAgIC8qKlxuICAgICAqIEdldHMgYW4gYXJyYXkgb2YgdGhlIHBpbm5lZCBgSWd4Q29sdW1uQ29tcG9uZW50YHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgcGlubmVkQ29sdW1ucyA9IHRoaXMuZ3JpZC5waW5uZWRDb2x1bW5zLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBwaW5uZWRDb2x1bW5zKCk6IElneENvbHVtbkNvbXBvbmVudFtdO1xuICAgIC8qKlxuICAgICAqIEdldHMgYW4gYXJyYXkgb2YgdW5waW5uZWQgYElneENvbHVtbkNvbXBvbmVudGBzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHVucGlubmVkQ29sdW1ucyA9IHRoaXMuZ3JpZC51bnBpbm5lZENvbHVtbnMuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHVucGlubmVkQ29sdW1ucygpOiBJZ3hDb2x1bW5Db21wb25lbnRbXTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBgd2lkdGhgIHRvIGJlIHNldCBvbiBgSWd4R3JpZEhlYWRlckdyb3VwQ29tcG9uZW50YC5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJHcm91cFdpZHRoKGNvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50KTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBJZ3hDb2x1bW5Db21wb25lbnRgIGJ5IGZpZWxkIG5hbWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgbXlDb2wgPSB0aGlzLmdyaWQxLmdldENvbHVtbkJ5TmFtZShcIklEXCIpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgKi9cbiAgICBnZXRDb2x1bW5CeU5hbWUobmFtZTogc3RyaW5nKTogSWd4Q29sdW1uQ29tcG9uZW50O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBJZ3hSb3dEaXJlY3RpdmVgIGJ5IGluZGV4LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IG15Um93ID0gdGhpcy5ncmlkMS5nZXRSb3dCeUluZGV4KDEpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICovXG4gICAgZ2V0Um93QnlJbmRleChpbmRleDogbnVtYmVyKTogSWd4Um93RGlyZWN0aXZlPElneEdyaWRCYXNlRGlyZWN0aXZlICYgR3JpZFR5cGU+O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYElneEdyaWRSb3dDb21wb25lbnRgIG9iamVjdCBieSB0aGUgc3BlY2lmaWVkIHByaW1hcnkga2V5IC5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFJlcXVpcmVzIHRoYXQgdGhlIGBwcmltYXJ5S2V5YCBwcm9wZXJ0eSBpcyBzZXQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgbXlSb3cgPSB0aGlzLmdyaWQxLmdldFJvd0J5S2V5KFwiY2VsbDVcIik7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGtleVZhbHVlXG4gICAgKi9cbiAgICBnZXRSb3dCeUtleShrZXlWYWx1ZTogYW55KTogSWd4Um93RGlyZWN0aXZlPElneEdyaWRCYXNlRGlyZWN0aXZlICYgR3JpZFR5cGU+O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdmlzaWJsZSBgSWd4Q29sdW1uQ29tcG9uZW50YHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgdmlzaWJsZUNvbHVtbnMgPSB0aGlzLmdyaWQudmlzaWJsZUNvbHVtbnMuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHZpc2libGVDb2x1bW5zKCk6IElneENvbHVtbkNvbXBvbmVudFtdO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBJZ3hHcmlkQ2VsbENvbXBvbmVudGAgdGhhdCBtYXRjaGVzIHRoZSBjb25kaXRpb25zLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IG15Q2VsbCA9IHRoaXMuZ3JpZDEuZ2V0Q2VsbEJ5Q29sdW1uKDIsXCJVbml0UHJpY2VcIik7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHJvd0luZGV4XG4gICAgICogQHBhcmFtIGNvbHVtbkZpZWxkXG4gICAgKi9cbiAgICBnZXRDZWxsQnlDb2x1bW4ocm93SW5kZXg6IG51bWJlciwgY29sdW1uRmllbGQ6IHN0cmluZyk6IElneEdyaWRDZWxsQ29tcG9uZW50O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYElneEdyaWRDZWxsQ29tcG9uZW50YCBvYmplY3QgYnkgdGhlIHNwZWNpZmllZCBwcmltYXJ5IGtleSBhbmQgY29sdW1uIGZpZWxkLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUmVxdWlyZXMgdGhhdCB0aGUgcHJpbWFyeUtleSBwcm9wZXJ0eSBpcyBzZXQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogZ3JpZC5nZXRDZWxsQnlLZXkoMSwgJ2luZGV4Jyk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHJvd1NlbGVjdG9yIG1hdGNoIGFueSByb3dJRFxuICAgICAqIEBwYXJhbSBjb2x1bW5GaWVsZFxuICAgICovXG4gICAgZ2V0Q2VsbEJ5S2V5KHJvd1NlbGVjdG9yOiBhbnksIGNvbHVtbkZpZWxkOiBzdHJpbmcpOiBJZ3hHcmlkQ2VsbENvbXBvbmVudDtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0b3RhbCBudW1iZXIgb2YgcGFnZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgdG90YWxQYWdlcyA9IHRoaXMuZ3JpZC50b3RhbFBhZ2VzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCB0b3RhbFBhZ2VzKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBHZXRzIGlmIHRoZSBjdXJyZW50IHBhZ2UgaXMgdGhlIGZpcnN0IHBhZ2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZmlyc3RQYWdlID0gdGhpcy5ncmlkLmlzRmlyc3RQYWdlO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBpc0ZpcnN0UGFnZSgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEdvZXMgdG8gdGhlIG5leHQgcGFnZSwgaWYgdGhlIGdyaWQgaXMgbm90IGFscmVhZHkgYXQgdGhlIGxhc3QgcGFnZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQxLm5leHRQYWdlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgbmV4dFBhZ2UoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBHb2VzIHRvIHRoZSBwcmV2aW91cyBwYWdlLCBpZiB0aGUgZ3JpZCBpcyBub3QgYWxyZWFkeSBhdCB0aGUgZmlyc3QgcGFnZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQxLnByZXZpb3VzUGFnZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHByZXZpb3VzUGFnZSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiByZWNvcmRzLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogT25seSBmdW5jdGlvbnMgd2hlbiBwYWdpbmcgaXMgZW5hYmxlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCB0b3RhbFJlY29yZHMgPSB0aGlzLmdyaWQudG90YWxSZWNvcmRzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCB0b3RhbFJlY29yZHMoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGN1cnJlbnQgcGFnZSBpcyB0aGUgbGFzdCBwYWdlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGxhc3RQYWdlID0gdGhpcy5ncmlkLmlzTGFzdFBhZ2U7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGlzTGFzdFBhZ2UoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0b3RhbCB3aWR0aCBvZiB0aGUgYElneEdyaWRDb21wb25lbnRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyaWRXaWR0aCA9IHRoaXMuZ3JpZC50b3RhbFdpZHRoO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCB0b3RhbFdpZHRoKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0IHNob3dSb3dTZWxlY3RvcnMoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0IHNob3dEcmFnSWNvbnMoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9tb3ZlQ29sdW1ucyhmcm9tOiBJZ3hDb2x1bW5Db21wb25lbnQsIHRvOiBJZ3hDb2x1bW5Db21wb25lbnQsIHBvczogRHJvcFBvc2l0aW9uKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9yZXNldENvbHVtbkxpc3QobGlzdD86IGFueSk6IGFueVtdO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3Jlb3JkZXJDb2x1bW5zKGZyb206IElneENvbHVtbkNvbXBvbmVudCwgdG86IElneENvbHVtbkNvbXBvbmVudCwgcG9zaXRpb246IERyb3BQb3NpdGlvbiwgY29sdW1uQ29sbGVjdGlvbjogYW55W10pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX21vdmVDaGlsZENvbHVtbnMocGFyZW50OiBJZ3hDb2x1bW5Db21wb25lbnQsIGZyb206IElneENvbHVtbkNvbXBvbmVudCwgdG86IElneENvbHVtbkNvbXBvbmVudCwgcG9zOiBEcm9wUG9zaXRpb24pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgY29sdW1uIHRvIHRoZSBzcGVjaWZpZWQgZHJvcCB0YXJnZXQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogZ3JpZC5tb3ZlQ29sdW1uKGNvbXBOYW1lLCBwZXJzRGV0YWlscyk7XG4gICAgICogYGBgXG4gICAgICAqL1xuICAgIG1vdmVDb2x1bW4oY29sdW1uOiBJZ3hDb2x1bW5Db21wb25lbnQsIGRyb3BUYXJnZXQ6IElneENvbHVtbkNvbXBvbmVudCwgcG9zPzogRHJvcFBvc2l0aW9uKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBHb2VzIHRvIHRoZSBkZXNpcmVkIHBhZ2UgaW5kZXguXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkMS5wYWdpbmF0ZSgxKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgKi9cbiAgICBwYWdpbmF0ZSh2YWw6IG51bWJlcik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTWFudWFsbHkgbWFya3MgdGhlIGBJZ3hHcmlkQ29tcG9uZW50YCBmb3IgY2hhbmdlIGRldGVjdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQxLm1hcmtGb3JDaGVjaygpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG1hcmtGb3JDaGVjaygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYElneEdyaWRSb3dDb21wb25lbnRgIGFuZCBhZGRzIHRoZSBkYXRhIHJlY29yZCB0byB0aGUgZW5kIG9mIHRoZSBkYXRhIHNvdXJjZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQxLmFkZFJvdyhyZWNvcmQpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgKi9cbiAgICBhZGRSb3coZGF0YTogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBgSWd4R3JpZFJvd0NvbXBvbmVudGAgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGRhdGEgcmVjb3JkIGJ5IHByaW1hcnkga2V5LlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUmVxdWlyZXMgdGhhdCB0aGUgYHByaW1hcnlLZXlgIHByb3BlcnR5IGlzIHNldC5cbiAgICAgKiBUaGUgbWV0aG9kIGFjY2VwdCByb3dTZWxlY3RvciBhcyBhIHBhcmFtZXRlciwgd2hpY2ggaXMgdGhlIHJvd0lELlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZDEuZGVsZXRlUm93KDApO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSByb3dTZWxlY3RvclxuICAgICovXG4gICAgZGVsZXRlUm93KHJvd1NlbGVjdG9yOiBhbnkpOiB2b2lkO1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgZGVsZXRlUm93QnlJZChyb3dJZDogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRlbGV0ZVJvd0Zyb21EYXRhKHJvd0lEOiBhbnksIGluZGV4OiBudW1iZXIpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGBJZ3hHcmlkUm93Q29tcG9uZW50YCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgZGF0YSByZWNvcmQgYnkgcHJpbWFyeSBrZXkuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBSZXF1aXJlcyB0aGF0IHRoZSBgcHJpbWFyeUtleWAgcHJvcGVydHkgaXMgc2V0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZFdpdGhQSy51cGRhdGVDZWxsKCdVcGRhdGVkJywgMSwgJ1Byb2R1Y3ROYW1lJyk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHZhbHVlIHRoZSBuZXcgdmFsdWUgd2hpY2ggaXMgdG8gYmUgc2V0LlxuICAgICAqIEBwYXJhbSByb3dTZWxlY3RvciBjb3JyZXNwb25kcyB0byByb3dJRC5cbiAgICAgKiBAcGFyYW0gY29sdW1uIGNvcnJlc3BvbmRzIHRvIGNvbHVtbiBmaWVsZC5cbiAgICAqL1xuICAgIHVwZGF0ZUNlbGwodmFsdWU6IGFueSwgcm93U2VsZWN0b3I6IGFueSwgY29sdW1uOiBzdHJpbmcpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGBJZ3hHcmlkUm93Q29tcG9uZW50YFxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIHJvdyBpcyBzcGVjaWZpZWQgYnlcbiAgICAgKiByb3dTZWxlY3RvciBwYXJhbWV0ZXIgYW5kIHRoZSBkYXRhIHNvdXJjZSByZWNvcmQgd2l0aCB0aGUgcGFzc2VkIHZhbHVlLlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYXBwbHkgcmVxdWVzdGVkIHVwZGF0ZSBvbmx5IGlmIHByaW1hcnkga2V5IGlzIHNwZWNpZmllZCBpbiB0aGUgZ3JpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBncmlkLnVwZGF0ZVJvdyh7XG4gICAgICogICAgICAgUHJvZHVjdElEOiAxLCBQcm9kdWN0TmFtZTogJ1NwZWFybWludCcsIEluU3RvY2s6IHRydWUsIFVuaXRzSW5TdG9jazogMSwgT3JkZXJEYXRlOiBuZXcgRGF0ZSgnMjAwNS0wMy0yMScpXG4gICAgICogICB9LCAxKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gcm93U2VsZWN0b3IgY29ycmVzcG9uZCB0byByb3dJRFxuICAgICovXG4gICAgdXBkYXRlUm93KHZhbHVlOiBhbnksIHJvd1NlbGVjdG9yOiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFNvcnQgYSBzaW5nbGUgYElneENvbHVtbkNvbXBvbmVudGAuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBTb3J0IHRoZSBgSWd4R3JpZENvbXBvbmVudGAncyBgSWd4Q29sdW1uQ29tcG9uZW50YCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYXJyYXkgb2Ygc29ydGluZyBleHByZXNzaW9ucy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuc29ydCh7IGZpZWxkTmFtZTogbmFtZSwgZGlyOiBTb3J0aW5nRGlyZWN0aW9uLkFzYywgaWdub3JlQ2FzZTogZmFsc2UgfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc29ydChleHByZXNzaW9uOiBJU29ydGluZ0V4cHJlc3Npb24gfCBBcnJheTxJU29ydGluZ0V4cHJlc3Npb24+KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBGaWx0ZXJzIGEgc2luZ2xlIGBJZ3hDb2x1bW5Db21wb25lbnRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBmaWx0ZXIodGVybSkge1xuICAgICAqICAgICAgdGhpcy5ncmlkLmZpbHRlcihcIlByb2R1Y3ROYW1lXCIsIHRlcm0sIElneFN0cmluZ0ZpbHRlcmluZ09wZXJhbmQuaW5zdGFuY2UoKS5jb25kaXRpb24oXCJjb250YWluc1wiKSk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIGNvbmRpdGlvbk9yRXhwcmVzc2lvblRyZWVcbiAgICAgKiBAcGFyYW0gaWdub3JlQ2FzZVxuICAgICovXG4gICAgZmlsdGVyKG5hbWU6IHN0cmluZywgdmFsdWU6IGFueSwgY29uZGl0aW9uT3JFeHByZXNzaW9uVHJlZT86IElGaWx0ZXJpbmdPcGVyYXRpb24gfCBJRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlLCBpZ25vcmVDYXNlPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRmlsdGVycyBhbGwgdGhlIGBJZ3hDb2x1bW5Db21wb25lbnRgIGluIHRoZSBgSWd4R3JpZENvbXBvbmVudGAgd2l0aCB0aGUgc2FtZSBjb25kaXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogZ3JpZC5maWx0ZXJHbG9iYWwoJ3NvbWUnLCBJZ3hTdHJpbmdGaWx0ZXJpbmdPcGVyYW5kLmluc3RhbmNlKCkuY29uZGl0aW9uKCdjb250YWlucycpKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gY29uZGl0aW9uXG4gICAgICogQHBhcmFtIGlnbm9yZUNhc2VcbiAgICAqL1xuICAgIGZpbHRlckdsb2JhbCh2YWx1ZTogYW55LCBjb25kaXRpb246IGFueSwgaWdub3JlQ2FzZT86IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBzdW1tYXJpZXMgZm9yIHRoZSBzcGVjaWZpZWQgY29sdW1uIGFuZCBhcHBsaWVzIHlvdXIgY3VzdG9tU3VtbWFyeS5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHlvdSBkbyBub3QgcHJvdmlkZSB0aGUgY3VzdG9tU3VtbWFyeSwgdGhlbiB0aGUgZGVmYXVsdCBzdW1tYXJ5IGZvciB0aGUgY29sdW1uIGRhdGEgdHlwZSB3aWxsIGJlIGFwcGxpZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogZ3JpZC5lbmFibGVTdW1tYXJpZXMoW3sgZmllbGROYW1lOiAnUHJvZHVjdE5hbWUnIH0sIHsgZmllbGROYW1lOiAnSUQnIH1dKTtcbiAgICAgKiBgYGBcbiAgICAgKiBFbmFibGUgc3VtbWFyaWVzIGZvciB0aGUgbGlzdGVkIGNvbHVtbnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogZ3JpZC5lbmFibGVTdW1tYXJpZXMoJ1Byb2R1Y3ROYW1lJyk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHJlc3RcbiAgICAqL1xuICAgIGVuYWJsZVN1bW1hcmllcyguLi5yZXN0OiBhbnlbXSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRGlzYWJsZSBzdW1tYXJpZXMgZm9yIHRoZSBzcGVjaWZpZWQgY29sdW1uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGdyaWQuZGlzYWJsZVN1bW1hcmllcygnUHJvZHVjdE5hbWUnKTtcbiAgICAgKiBgYGBcbiAgICAgKkByZW1hcmtzXG4gICAgICogRGlzYWJsZSBzdW1tYXJpZXMgZm9yIHRoZSBsaXN0ZWQgY29sdW1ucy5cbiAgICAgKkBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGdyaWQuZGlzYWJsZVN1bW1hcmllcyhbeyBmaWVsZE5hbWU6ICdQcm9kdWN0TmFtZScgfV0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGRpc2FibGVTdW1tYXJpZXMoLi4ucmVzdDogYW55W10pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIElmIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFycyB0aGUgZmlsdGVyaW5nIHN0YXRlIG9mIHRoZSBjb3JyZXNwb25kaW5nIGBJZ3hDb2x1bW5Db21wb25lbnRgLlxuICAgICAqQHJlbWFya3NcbiAgICAgT3RoZXJ3aXNlIGNsZWFycyB0aGUgZmlsdGVyaW5nIHN0YXRlIG9mIGFsbCBgSWd4Q29sdW1uQ29tcG9uZW50YHMuXG4gICAgICpAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuY2xlYXJGaWx0ZXIoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICovXG4gICAgY2xlYXJGaWx0ZXIobmFtZT86IHN0cmluZyk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogSWYgbmFtZSBpcyBwcm92aWRlZCwgY2xlYXJzIHRoZSBzb3J0aW5nIHN0YXRlIG9mIHRoZSBjb3JyZXNwb25kaW5nIGBJZ3hDb2x1bW5Db21wb25lbnRgLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogb3RoZXJ3aXNlIGNsZWFycyB0aGUgc29ydGluZyBzdGF0ZSBvZiBhbGwgYElneENvbHVtbkNvbXBvbmVudGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLmNsZWFyU29ydCgpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgKi9cbiAgICBjbGVhclNvcnQobmFtZT86IHN0cmluZyk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICByZWZyZXNoR3JpZFN0YXRlKGFyZ3M/OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFBpbnMgYSBjb2x1bW4gYnkgZmllbGQgbmFtZS5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgb3BlcmF0aW9uIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLnBpbkNvbHVtbihcIklEXCIpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBjb2x1bW5OYW1lXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgKi9cbiAgICBwaW5Db2x1bW4oY29sdW1uTmFtZTogc3RyaW5nIHwgSWd4Q29sdW1uQ29tcG9uZW50LCBpbmRleD86IGFueSk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVW5waW5zIGEgY29sdW1uIGJ5IGZpZWxkIG5hbWUuIFJldHVybnMgd2hldGhlciB0aGUgb3BlcmF0aW9uIGlzIHN1Y2Nlc3NmdWwuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLnBpbkNvbHVtbihcIklEXCIpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBjb2x1bW5OYW1lXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgKi9cbiAgICB1bnBpbkNvbHVtbihjb2x1bW5OYW1lOiBzdHJpbmcgfCBJZ3hDb2x1bW5Db21wb25lbnQsIGluZGV4PzogYW55KTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgZ3JpZCB3aWR0aC9oZWlnaHQgZGltZW5zaW9ucy5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFNob3VsZCBiZSBydW4gd2hlbiBjaGFuZ2luZyBET00gZWxlbWVudHMgZGltZW50aW9ucyBtYW51YWxseSB0aGF0IGFmZmVjdCB0aGUgZ3JpZCdzIHNpemUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLnJlZmxvdygpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHJlZmxvdygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBuZXh0IG9jY3VycmVuY2Ugb2YgYSBnaXZlbiBzdHJpbmcgaW4gdGhlIGdyaWQgYW5kIHNjcm9sbHMgdG8gdGhlIGNlbGwgaWYgaXQgaXNuJ3QgdmlzaWJsZS5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFJldHVybnMgaG93IG1hbnkgdGltZXMgdGhlIGdyaWQgY29udGFpbnMgdGhlIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuZmluZE5leHQoXCJmaW5hbmNpYWxcIik7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHRleHQgdGhlIHN0cmluZyB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIGNhc2VTZW5zaXRpdmUgb3B0aW9uYWxseSwgaWYgdGhlIHNlYXJjaCBzaG91bGQgYmUgY2FzZSBzZW5zaXRpdmUgKGRlZmF1bHRzIHRvIGZhbHNlKS5cbiAgICAgKiBAcGFyYW0gZXhhY3RNYXRjaCBvcHRpb25hbGx5LCBpZiB0aGUgdGV4dCBzaG91bGQgbWF0Y2ggdGhlIGVudGlyZSB2YWx1ZSAgKGRlZmF1bHRzIHRvIGZhbHNlKS5cbiAgICAqL1xuICAgIGZpbmROZXh0KHRleHQ6IHN0cmluZywgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW4sIGV4YWN0TWF0Y2g/OiBib29sZWFuKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBwcmV2aW91cyBvY2N1cnJlbmNlIG9mIGEgZ2l2ZW4gc3RyaW5nIGluIHRoZSBncmlkIGFuZCBzY3JvbGxzIHRvIHRoZSBjZWxsIGlmIGl0IGlzbid0IHZpc2libGUuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBSZXR1cm5zIGhvdyBtYW55IHRpbWVzIHRoZSBncmlkIGNvbnRhaW5zIHRoZSBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLmZpbmRQcmV2KFwiZmluYW5jaWFsXCIpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB0ZXh0IHRoZSBzdHJpbmcgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSBjYXNlU2Vuc2l0aXZlIG9wdGlvbmFsbHksIGlmIHRoZSBzZWFyY2ggc2hvdWxkIGJlIGNhc2Ugc2Vuc2l0aXZlIChkZWZhdWx0cyB0byBmYWxzZSkuXG4gICAgICogQHBhcmFtIGV4YWN0TWF0Y2ggb3B0aW9uYWxseSwgaWYgdGhlIHRleHQgc2hvdWxkIG1hdGNoIHRoZSBlbnRpcmUgdmFsdWUgKGRlZmF1bHRzIHRvIGZhbHNlKS5cbiAgICAqL1xuICAgIGZpbmRQcmV2KHRleHQ6IHN0cmluZywgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW4sIGV4YWN0TWF0Y2g/OiBib29sZWFuKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFJlYXBwbGllcyB0aGUgZXhpc3Rpbmcgc2VhcmNoLlxuICAgICAqIEByZW1hcmtzXG4gICAgICogUmV0dXJucyBob3cgbWFueSB0aW1lcyB0aGUgZ3JpZCBjb250YWlucyB0aGUgbGFzdCBzZWFyY2guXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLnJlZnJlc2hTZWFyY2goKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gdXBkYXRlQWN0aXZlSW5mb1xuICAgICovXG4gICAgcmVmcmVzaFNlYXJjaCh1cGRhdGVBY3RpdmVJbmZvPzogYm9vbGVhbik6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgaGlnaGxpZ2h0cyBpbiB0aGUgY2VsbC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuY2xlYXJTZWFyY2goKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjbGVhclNlYXJjaCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGBJZ3hHcmlkQ29tcG9uZW50YCBoYXMgc29ydGFibGUgY29sdW1ucy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBzb3J0YWJsZUdyaWQgPSB0aGlzLmdyaWQuaGFzU29ydGFibGVDb2x1bW5zO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBoYXNTb3J0YWJsZUNvbHVtbnMoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBgSWd4R3JpZENvbXBvbmVudGAgaGFzIGVkaXRhYmxlIGNvbHVtbnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZWRpdGFibGVHcmlkID0gdGhpcy5ncmlkLmhhc0VkaXRhYmxlQ29sdW1ucztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgaGFzRWRpdGFibGVDb2x1bW5zKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgYElneEdyaWRDb21wb25lbnRgIGhhcyBmaXRlcmFibGUgY29sdW1ucy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBmaWx0ZXJhYmxlR3JpZCA9IHRoaXMuZ3JpZC5oYXNGaWx0ZXJhYmxlQ29sdW1ucztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgaGFzRmlsdGVyYWJsZUNvbHVtbnMoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBgSWd4R3JpZENvbXBvbmVudGAgaGFzIHN1bW1hcml6ZWQgY29sdW1ucy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBzdW1tYXJpemVkR3JpZCA9IHRoaXMuZ3JpZC5oYXNTdW1tYXJpemVkQ29sdW1ucztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgaGFzU3VtbWFyaXplZENvbHVtbnMoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldCByb290U3VtbWFyaWVzRW5hYmxlZCgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0IGhhc1Zpc2libGVDb2x1bW5zKCk6IGJvb2xlYW47XG4gICAgc2V0IGhhc1Zpc2libGVDb2x1bW5zKHZhbHVlOiBib29sZWFuKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBgSWd4R3JpZENvbXBvbmVudGAgaGFzIG1vdmVhYmxlIGNvbHVtbnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgbW92YWJsZUdyaWQgPSB0aGlzLmdyaWQuaGFzTW92YWJsZUNvbHVtbnM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGhhc01vdmFibGVDb2x1bW5zKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgYElneEdyaWRDb21wb25lbnRgIGhhcyBjb2x1bW4gZ3JvdXBzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyb3VwR3JpZCA9IHRoaXMuZ3JpZC5oYXNDb2x1bW5Hcm91cHM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGhhc0NvbHVtbkdyb3VwcygpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGBJZ3hHcmlkQ29tcG9uZW50YCBoYXMgY29sdW1uIGxheW91dHMgZm9yIG11bHRpLXJvdyBsYXlvdXQgZGVmaW5pdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBsYXlvdXRHcmlkID0gdGhpcy5ncmlkLmhhc0NvbHVtbkxheW91dHM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGhhc0NvbHVtbkxheW91dHMoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBzZWxlY3RlZCBgSWd4R3JpZENlbGxDb21wb25lbnRgcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBzZWxlY3RlZENlbGxzID0gdGhpcy5ncmlkLnNlbGVjdGVkQ2VsbHM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkQ2VsbHMoKTogSWd4R3JpZENlbGxDb21wb25lbnRbXSB8IGFueVtdO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0IG11bHRpUm93TGF5b3V0Um93U2l6ZSgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXQgcm93QmFzZWRIZWlnaHQoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0IGlzUGVyY2VudFdpZHRoKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXQgaXNQZXJjZW50SGVpZ2h0KCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFNldHMgY29sdW1ucyBkZWZhdWx0V2lkdGggcHJvcGVydHlcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2Rlcml2ZVBvc3NpYmxlV2lkdGgoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldCBkZWZhdWx0VGFyZ2V0Qm9keUhlaWdodCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBUaGUgcm93SGVpZ2h0IGlucHV0IGlzIGJvdW5kIHRvIG1pbi1oZWlnaHQgY3NzIHByb3Agb2Ygcm93cyB0aGF0IGFkZHMgYSAxcHggYm9yZGVyIGluIGFsbCBjYXNlc1xuICAgICAqL1xuICAgIGdldCByZW5kZXJlZFJvd0hlaWdodCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjYWxjR3JpZEhlYWRSb3coKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogU2V0cyBUQk9EWSBoZWlnaHQgaS5lLiB0aGlzLmNhbGNIZWlnaHRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY2FsY3VsYXRlR3JpZEhlaWdodCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0R3JvdXBBcmVhSGVpZ2h0KCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldFRvb2xiYXJIZWlnaHQoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0UGFnaW5nSGVpZ2h0KCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldEZpbHRlckNlbGxIZWlnaHQoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2NhbGN1bGF0ZUdyaWRCb2R5SGVpZ2h0KCk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgY2hlY2tDb250YWluZXJTaXplQ2hhbmdlKCk6IGJvb2xlYW47XG4gICAgcHJvdGVjdGVkIF9zaG91bGRBdXRvU2l6ZShyZW5kZXJlZEhlaWdodDogYW55KTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldCBvdXRlcldpZHRoKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEdldHMgdGhlIHZpc2libGUgY29udGVudCBoZWlnaHQgdGhhdCBpbmNsdWRlcyBoZWFkZXIgKyB0Ym9keSArIGZvb3Rlci5cbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlQ29udGVudEhlaWdodCgpOiBhbnk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXRQb3NzaWJsZUNvbHVtbldpZHRoKGJhc2VXaWR0aD86IG51bWJlcik6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogU2V0cyBncmlkIHdpZHRoIGkuZS4gdGhpcy5jYWxjV2lkdGhcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY2FsY3VsYXRlR3JpZFdpZHRoKCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBnZXRDb2x1bW5XaWR0aFN1bTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGhhc1ZlcnRpY2FsU3JvbGwoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXREYXRhQmFzZWRCb2R5SGVpZ2h0KCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG9uQ29sdW1uc0NoYW5nZWQoY2hhbmdlOiBRdWVyeUxpc3Q8SWd4Q29sdW1uQ29tcG9uZW50Pik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjYWxjdWxhdGVHcmlkU2l6ZXMocmVjYWxjRmVhdHVyZVdpZHRoPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgcHJpdmF0ZSBfYXBwbHlXaWR0aEhvc3RCaW5kaW5nO1xuICAgIC8qKlxuICAgICAqIEdldHMgY2FsY3VsYXRlZCB3aWR0aCBvZiB0aGUgcGlubmVkIGFyZWEuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgcGlubmVkV2lkdGggPSB0aGlzLmdyaWQuZ2V0UGlubmVkV2lkdGgoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gdGFrZUhpZGRlbiBJZiB3ZSBzaG91bGQgdGFrZSBpbnRvIGFjY291bnQgdGhlIGhpZGRlbiBjb2x1bW5zIGluIHRoZSBwaW5uZWQgYXJlYS5cbiAgICAqL1xuICAgIGdldFBpbm5lZFdpZHRoKHRha2VIaWRkZW4/OiBib29sZWFuKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBHZXRzIGNhbGN1bGF0ZWQgd2lkdGggb2YgdGhlIHVucGlubmVkIGFyZWFcbiAgICAgKiBAcGFyYW0gdGFrZUhpZGRlbiBJZiB3ZSBzaG91bGQgdGFrZSBpbnRvIGFjY291bnQgdGhlIGhpZGRlbiBjb2x1bW5zIGluIHRoZSBwaW5uZWQgYXJlYS5cbiAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRVbnBpbm5lZFdpZHRoKHRha2VIaWRkZW4/OiBib29sZWFuKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3N1bW1hcmllcyhmaWVsZE5hbWU6IHN0cmluZywgaGFzU3VtbWFyeTogYm9vbGVhbiwgc3VtbWFyeU9wZXJhbmQ/OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX211bHRpcGxlU3VtbWFyaWVzKGV4cHJlc3Npb25zOiBJU3VtbWFyeUV4cHJlc3Npb25bXSwgaGFzU3VtbWFyeTogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZGlzYWJsZU11bHRpcGxlU3VtbWFyaWVzKGV4cHJlc3Npb25zOiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcmVzb2x2ZURhdGFUeXBlcyhyZWM6IGFueSk6IERhdGFUeXBlO1xuICAgIHByaXZhdGUgZ2V0U2Nyb2xsV2lkdGg7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBhdXRvZ2VuZXJhdGVDb2x1bW5zKCk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIGdlbmVyYXRlRGF0YUZpZWxkcyhkYXRhOiBhbnlbXSk6IHN0cmluZ1tdO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbmx5VG9wTGV2ZWwoYXJyOiBhbnkpOiBhbnk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBpbml0Q29sdW1ucyhjb2xsZWN0aW9uOiBRdWVyeUxpc3Q8SWd4Q29sdW1uQ29tcG9uZW50PiwgY2I/OiBGdW5jdGlvbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZWluaXRQaW5TdGF0ZXMoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgaXNDb2x1bW5Hcm91cGVkKGZpZWxkTmFtZTogc3RyaW5nKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgb25IZWFkZXJTZWxlY3RvckNsaWNrKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0IGhlYWRTZWxlY3RvckJhc2VBcmlhTGFiZWwoKTogXCJEZXNlbGVjdCBhbGwgZmlsdGVyZWRcIiB8IFwiU2VsZWN0IGFsbCBmaWx0ZXJlZFwiIHwgXCJEZXNlbGVjdCBhbGxcIiB8IFwiU2VsZWN0IGFsbFwiO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXQgdG90YWxSb3dzQ291bnRBZnRlckZpbHRlcigpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudGx5IHRyYW5zZm9ybWVkIHBhZ2VkL2ZpbHRlcmVkL3NvcnRlZC9ncm91cGVkIGRhdGEsIGRpc3BsYXllZCBpbiB0aGUgZ3JpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAgICAgIGNvbnN0IGRhdGFWaWV3ID0gdGhpcy5ncmlkLmRhdGFWaWV3O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBkYXRhVmlldygpOiBhbnlbXTtcbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBzZWxlY3Rpb24gc3RhdGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggc2VsZWN0ZWQgcm93cycgSURzIChwcmltYXJ5S2V5IG9yIHJvd0RhdGEpXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHNlbGVjdGVkUm93cyA9IHRoaXMuZ3JpZC5zZWxlY3RlZFJvd3MoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZWxlY3RlZFJvd3MoKTogYW55W107XG4gICAgLyoqXG4gICAgICogU2VsZWN0IHNwZWNpZmllZCByb3dzIGJ5IElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5zZWxlY3RSb3dzKFsxLDIsNV0sIHRydWUpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSByb3dJRHNcbiAgICAgKiBAcGFyYW0gY2xlYXJDdXJyZW50U2VsZWN0aW9uIGlmIHRydWUgY2xlYXJzIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICovXG4gICAgc2VsZWN0Um93cyhyb3dJRHM6IGFueVtdLCBjbGVhckN1cnJlbnRTZWxlY3Rpb24/OiBib29sZWFuKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdCBzcGVjaWZpZWQgcm93cyBieSBJRC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuZGVzZWxlY3RSb3dzKFsxLDIsNV0pO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSByb3dJRHNcbiAgICAqL1xuICAgIGRlc2VsZWN0Um93cyhyb3dJRHM6IGFueVtdKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGFsbCByb3dzXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBCeSBkZWZhdWx0IGlmIGZpbHRlcmluZyBpcyBpbiBwbGFjZSwgc2VsZWN0QWxsUm93cygpIGFuZCBkZXNlbGVjdEFsbFJvd3MoKSBzZWxlY3QvZGVzZWxlY3QgYWxsIGZpbHRlcmVkIHJvd3MuXG4gICAgICogSWYgeW91IHNldCB0aGUgcGFyYW1ldGVyIG9ubHlGaWx0ZXJEYXRhIHRvIGZhbHNlIHRoYXQgd2lsbCBzZWxlY3QgYWxsIHJvd3MgaW4gdGhlIGdyaWQgZXhlcHQgZGVsZXRlZCByb3dzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5zZWxlY3RBbGxSb3dzKCk7XG4gICAgICogdGhpcy5ncmlkLnNlbGVjdEFsbFJvd3MoZmFsc2UpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBvbmx5RmlsdGVyRGF0YVxuICAgICAqL1xuICAgIHNlbGVjdEFsbFJvd3Mob25seUZpbHRlckRhdGE/OiBib29sZWFuKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdHMgYWxsIHJvd3NcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEJ5IGRlZmF1bHQgaWYgZmlsdGVyaW5nIGlzIGluIHBsYWNlLCBzZWxlY3RBbGxSb3dzKCkgYW5kIGRlc2VsZWN0QWxsUm93cygpIHNlbGVjdC9kZXNlbGVjdCBhbGwgZmlsdGVyZWQgcm93cy5cbiAgICAgKiBJZiB5b3Ugc2V0IHRoZSBwYXJhbWV0ZXIgb25seUZpbHRlckRhdGEgdG8gZmFsc2UgdGhhdCB3aWxsIHNlbGVjdCBhbGwgcm93cyBpbiB0aGUgZ3JpZCBleGVwdCBkZWxldGVkIHJvd3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLmRlc2VsZWN0QWxsUm93cygpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBvbmx5RmlsdGVyRGF0YVxuICAgICAqL1xuICAgIGRlc2VsZWN0QWxsUm93cyhvbmx5RmlsdGVyRGF0YT86IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgY2xlYXJDZWxsU2VsZWN0aW9uKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRyYWdTY3JvbGwoZGlyOiBEcmFnU2Nyb2xsRGlyZWN0aW9uKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgaXNEZWZpbmVkKGFyZzogYW55KTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHNlbGVjdFJhbmdlKGFyZzogR3JpZFNlbGVjdGlvblJhbmdlIHwgR3JpZFNlbGVjdGlvblJhbmdlW10gfCBudWxsIHwgdW5kZWZpbmVkKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29sdW1uVG9WaXNpYmxlSW5kZXgoZmllbGQ6IHN0cmluZyB8IG51bWJlcik6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2V0U2VsZWN0aW9uKHJhbmdlOiBHcmlkU2VsZWN0aW9uUmFuZ2UpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0U2VsZWN0ZWRSYW5nZXMoKTogR3JpZFNlbGVjdGlvblJhbmdlW107XG4gICAgcHJvdGVjdGVkIGV4dHJhY3REYXRhRnJvbVNlbGVjdGlvbihzb3VyY2U6IGFueVtdLCBmb3JtYXR0ZXJzPzogYm9vbGVhbiwgaGVhZGVycz86IGJvb2xlYW4pOiBhbnlbXTtcbiAgICBwcm90ZWN0ZWQgZ2V0U2VsZWN0YWJsZUNvbHVtbnNBdChpbmRleDogYW55KTogSWd4Q29sdW1uQ29tcG9uZW50W107XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBjdXJyZW50IGNlbGwgc2VsZWN0aW9uIGluIHRoZSBmb3JtIG9mIGBbeyBjb2x1bW4uZmllbGQ6IGNlbGwudmFsdWUgfSwgLi4uXWAuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiBgZm9ybWF0dGVyc2AgaXMgZW5hYmxlZCwgdGhlIGNlbGwgdmFsdWUgd2lsbCBiZSBmb3JtYXR0ZWQgYnkgaXRzIHJlc3BlY3RpdmUgY29sdW1uIGZvcm1hdHRlciAoaWYgYW55KS5cbiAgICAgKiBJZiBgaGVhZGVyc2AgaXMgZW5hYmxlZCwgaXQgd2lsbCB1c2UgdGhlIGNvbHVtbiBoZWFkZXIgKGlmIGFueSkgaW5zdGVhZCBvZiB0aGUgY29sdW1uIGZpZWxkLlxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkRGF0YShmb3JtYXR0ZXJzPzogYm9vbGVhbiwgaGVhZGVycz86IGJvb2xlYW4pOiBhbnlbXTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2Nyb2xsSGFuZGxlcjogKGV2ZW50OiBhbnkpID0+IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb3B5SGFuZGxlcklFKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvcHlIYW5kbGVyKGV2ZW50OiBhbnksIGllMTE/OiBib29sZWFuKTogdm9pZDtcbiAgICAvKipOYXZpZ2F0ZXMgdG8gYSBwb3N1dGlvbiBpbiB0aGUgZ3JpZCBiYXNlZCBvbiBwcm92aWRlZCBgcm93aW5kZXhgIGFuZCBgdmlzaWJsZUNvbHVtbkluZGV4YC5cbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEFsc28gY2FuIGV4ZWN1dGUgYSBjdXN0b20gbG9naWMgb3ZlciB0aGUgdGFyZ2V0IGVsZW1lbnQsXG4gICAgICogdGhyb3VnaCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB7IHRhcmdldFR5cGU6IEdyaWRLZXlkb3duVGFyZ2V0VHlwZSwgdGFyZ2V0OiBPYmplY3QgfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqICB0aGlzLmdyaWQubmF2aWdhdGVUbygxMCwgMywgKGFyZ3MpID0+IHsgYXJncy50YXJnZXQubmF0aXZlRWxlbWVudC5mb2N1cygpOyB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBuYXZpZ2F0ZVRvKHJvd0luZGV4OiBudW1iZXIsIHZpc2libGVDb2xJbmRleD86IG51bWJlciwgY2I/OiBGdW5jdGlvbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIGBJQ2VsbFBvc2l0aW9uYCB3aGljaCBkZWZpbmVzIHRoZSBuZXh0IGNlbGwsXG4gICAgKiBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24sIHRoYXQgbWF0Y2ggc3BlY2lmaWMgY3JpdGVyaWEuXG4gICAgKiBAcmVtYXJrc1xuICAgICogWW91IGNhbiBwYXNzIGNhbGxiYWNrIGZ1bmN0aW9uIGFzIGEgdGhpcmQgcGFyYW1ldGVyIG9mIGBnZXRQcmV2aW91c0NlbGxgIG1ldGhvZC5cbiAgICAqIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBhY2NlcHRzIElneENvbHVtbkNvbXBvbmVudCBhcyBhIHBhcmFtXG4gICAgKiBAZXhhbXBsZVxuICAgICogYGBgdHlwZXNjcmlwdFxuICAgICogIGNvbnN0IG5leHRFZGl0YWJsZUNlbGxQb3NpdGlvbiA9IHRoaXMuZ3JpZC5nZXROZXh0Q2VsbCgwLCAzLCAoY29sdW1uKSA9PiBjb2x1bW4uZWRpdGFibGUpO1xuICAgICogYGBgXG4gICAgKi9cbiAgICBnZXROZXh0Q2VsbChjdXJyUm93SW5kZXg6IG51bWJlciwgY3VyVmlzaWJsZUNvbEluZGV4OiBudW1iZXIsIGNhbGxiYWNrPzogKElneENvbHVtbkNvbXBvbmVudDogYW55KSA9PiBib29sZWFuKTogSUNlbGxQb3NpdGlvbjtcbiAgICAvKipcbiAgICAqIFJldHVybnMgYElDZWxsUG9zaXRpb25gIHdoaWNoIGRlZmluZXMgdGhlIHByZXZpb3VzIGNlbGwsXG4gICAgKiBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24sIHRoYXQgbWF0Y2ggc3BlY2lmaWMgY3JpdGVyaWEuXG4gICAgKiBAcmVtYXJrc1xuICAgICogWW91IGNhbiBwYXNzIGNhbGxiYWNrIGZ1bmN0aW9uIGFzIGEgdGhpcmQgcGFyYW1ldGVyIG9mIGBnZXRQcmV2aW91c0NlbGxgIG1ldGhvZC5cbiAgICAqIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBhY2NlcHRzIElneENvbHVtbkNvbXBvbmVudCBhcyBhIHBhcmFtXG4gICAgKiBAZXhhbXBsZVxuICAgICogYGBgdHlwZXNjcmlwdFxuICAgICogIGNvbnN0IHByZXZpb3VzRWRpdGFibGVDZWxsUG9zaXRpb24gPSB0aGlzLmdyaWQuZ2V0UHJldmlvdXNDZWxsKDAsIDMsIChjb2x1bW4pID0+IGNvbHVtbi5lZGl0YWJsZSk7XG4gICAgKiBgYGBcbiAgICAqL1xuICAgIGdldFByZXZpb3VzQ2VsbChjdXJyUm93SW5kZXg6IG51bWJlciwgY3VyVmlzaWJsZUNvbEluZGV4OiBudW1iZXIsIGNhbGxiYWNrPzogKElneENvbHVtbkNvbXBvbmVudDogYW55KSA9PiBib29sZWFuKTogSUNlbGxQb3NpdGlvbjtcbiAgICBwcml2YXRlIGV4ZWN1dGVDYWxsYmFjaztcbiAgICBwcml2YXRlIGdldFByZXZEYXRhUm93SW5kZXg7XG4gICAgcHJpdmF0ZSBnZXROZXh0RGF0YVJvd0luZGV4O1xuICAgIHByaXZhdGUgaXNWYWxpZFBvc2l0aW9uO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgd2hlZWxIYW5kbGVyOiAoaXNTY3JvbGw/OiBib29sZWFuKSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgdHJhY2tDb2x1bW5DaGFuZ2VzKGluZGV4OiBhbnksIGNvbDogYW55KTogYW55O1xuICAgIHByaXZhdGUgZmluZDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGZpbHRlcmVkIHNvcnRlZCBkYXRhLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGZpbHRlcmVkU29ydGVkRGF0YSA9IHRoaXMuZ3JpZDEuZmlsdGVyZWRTb3J0ZWREYXRhO1xuICAgICAqIGBgYFxuICAgICovXG4gICAgZ2V0IGZpbHRlcmVkU29ydGVkRGF0YSgpOiBhbnlbXTtcbiAgICBzZXQgZmlsdGVyZWRTb3J0ZWREYXRhKHZhbHVlOiBhbnlbXSk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBpbml0UGlubmluZygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc2Nyb2xsVG8ocm93OiBhbnkgfCBudW1iZXIsIGNvbHVtbjogYW55IHwgbnVtYmVyLCBpbkNvbGxlY3Rpb24/OiBhbnlbXSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzY3JvbGxUb0hvcml6b250YWxseShjb2x1bW46IGFueSB8IG51bWJlcik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzY3JvbGxEaXJlY3RpdmUoZGlyZWN0aXZlOiBJZ3hHcmlkRm9yT2ZEaXJlY3RpdmU8YW55PiwgZ29hbDogbnVtYmVyKTogdm9pZDtcbiAgICBwcml2YXRlIHJlYnVpbGRNYXRjaENhY2hlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBpc0V4cGFuZGVkR3JvdXAoX2dyb3VwOiBJR3JvdXBCeVJlY29yZCk6IGJvb2xlYW47XG4gICAgcHJvdGVjdGVkIGNoYW5nZVJvd0VkaXRpbmdPdmVybGF5U3RhdGVPblNjcm9sbChyb3c6IElneFJvd0RpcmVjdGl2ZTxJZ3hHcmlkQmFzZURpcmVjdGl2ZSAmIEdyaWRUeXBlPik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogU2hvdWxkIGJlIGNhbGxlZCB3aGVuIGRhdGEgYW5kL29yIGlzTG9hZGluZyBpbnB1dCBjaGFuZ2VzIHNvIHRoYXQgdGhlIG92ZXJsYXkgY2FuIGJlXG4gICAgICogaGlkZGVuL3Nob3duIGJhc2VkIG9uIHRoZSBjdXJyZW50IHZhbHVlIG9mIHNob3VsZE92ZXJsYXlMb2FkaW5nXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGV2YWx1YXRlTG9hZGluZ1N0YXRlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG9wZW5Sb3dPdmVybGF5KGlkOiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgY2xvc2VSb3dFZGl0aW5nT3ZlcmxheSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgKi9cbiAgICB0b2dnbGVSb3dFZGl0aW5nT3ZlcmxheShzaG93OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcmVwb3NpdGlvblJvd0VkaXRpbmdPdmVybGF5KHJvdzogSWd4Um93RGlyZWN0aXZlPElneEdyaWRCYXNlRGlyZWN0aXZlICYgR3JpZFR5cGU+KTogdm9pZDtcbiAgICBwcml2YXRlIGNvbmZpZ3VyZVJvd0VkaXRpbmdPdmVybGF5O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgcm93Q2hhbmdlc0NvdW50KCk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgd3JpdGVUb0RhdGEocm93SW5kZXg6IG51bWJlciwgdmFsdWU6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBlbmRSb3dUcmFuc2FjdGlvbihjb21taXQ6IGJvb2xlYW4sIHJvdzogSWd4Um93KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ3JpZE91dGxldEtleWJvYXJkSGFuZGxlcihldmVudDogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBGaW5pc2hlcyB0aGUgcm93IHRyYW5zYWN0aW9ucyBvbiB0aGUgY3VycmVudCByb3cuXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiBgY29tbWl0ID09PSB0cnVlYCwgcGFzc2VzIHRoZW0gZnJvbSB0aGUgcGVuZGluZyBzdGF0ZSB0byB0aGUgZGF0YSAob3IgdHJhbnNhY3Rpb24gc2VydmljZSlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8YnV0dG9uIGlneEJ1dHRvbiAoY2xpY2spPVwiZ3JpZC5lbmRFZGl0KHRydWUpXCI+Q29tbWl0IFJvdzwvYnV0dG9uPlxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBjb21taXRcbiAgICAgKi9cbiAgICBlbmRFZGl0KGNvbW1pdD86IGJvb2xlYW4sIGV2ZW50PzogRXZlbnQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJvd0VkaXRpbmdXaGVlbEhhbmRsZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXQgZGF0YVdpdGhBZGRlZEluVHJhbnNhY3Rpb25Sb3dzKCk6IGFueTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGRhdGFMZW5ndGgoKTogYW55O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgaGFzSG9yaXpvbnRhbFNjcm9sbCgpOiBib29sZWFuO1xuICAgIHByb3RlY3RlZCBfcmVzdG9yZVZpcnRTdGF0ZShyb3c6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRFeHBvcnRFeGNlbCgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0RXhwb3J0Q3N2KCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXQgc2hvdWxkT3ZlcmxheUxvYWRpbmcoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgaXNTdW1tYXJ5Um93KHJvd0RhdGE6IGFueSk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXQgaXNNdWx0aVJvd1NlbGVjdGlvbkVuYWJsZWQoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldCBpc1Jvd1NlbGVjdGFibGUoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldCBpc0NlbGxTZWxlY3RhYmxlKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHZpZXdEZXRhY2hIYW5kbGVyKGFyZ3M6IElDYWNoZWRWaWV3TG9hZGVkRXZlbnRBcmdzKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2FjaGVkVmlld0xvYWRlZChhcmdzOiBJQ2FjaGVkVmlld0xvYWRlZEV2ZW50QXJncyk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIGFkdmFuY2VkIGZpbHRlcmluZyBkaWFsb2cuXG4gICAgICovXG4gICAgb3BlbkFkdmFuY2VkRmlsdGVyaW5nRGlhbG9nKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBhZHZhbmNlZCBmaWx0ZXJpbmcgZGlhbG9nLlxuICAgICAqIEBwYXJhbSBhcHBseUNoYW5nZXMgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNoYW5nZXMgc2hvdWxkIGJlIGFwcGxpZWRcbiAgICAgKi9cbiAgICBjbG9zZUFkdmFuY2VkRmlsdGVyaW5nRGlhbG9nKGFwcGx5Q2hhbmdlczogYm9vbGVhbik6IHZvaWQ7XG59XG4iXX0=