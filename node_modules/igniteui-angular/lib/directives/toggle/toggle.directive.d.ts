import { ChangeDetectorRef, ElementRef, EventEmitter, OnDestroy, OnInit } from '@angular/core';
import { IgxNavigationService, IToggleView } from '../../core/navigation';
import { IgxOverlayService } from '../../services/overlay/overlay';
import { OverlaySettings } from '../../services';
import { CancelableEventArgs, CancelableBrowserEventArgs, IBaseEventArgs } from '../../core/utils';
import * as ɵngcc0 from '@angular/core';
export declare class IgxToggleDirective implements IToggleView, OnInit, OnDestroy {
    private elementRef;
    private cdr;
    protected overlayService: IgxOverlayService;
    private navigationService;
    protected _overlayId: string;
    private destroy$;
    private _overlaySubFilter;
    private _overlayOpenedSub;
    private _overlayClosingSub;
    private _overlayClosedSub;
    private _overlayAppendedSub;
    /**
     * Emits an event after the toggle container is opened.
     *
     * ```typescript
     * onToggleOpened(event) {
     *    alert("Toggle opened!");
     * }
     * ```
     *
     * ```html
     * <div
     *   igxToggle
     *   (onOpened)='onToggleOpened($event)'>
     * </div>
     * ```
     */
    onOpened: EventEmitter<any>;
    /**
     * Emits an event before the toggle container is opened.
     *
     * ```typescript
     * onToggleOpening(event) {
     *  alert("Toggle opening!");
     * }
     * ```
     *
     * ```html
     * <div
     *   igxToggle
     *   (onOpening)='onToggleOpening($event)'>
     * </div>
     * ```
     */
    onOpening: EventEmitter<CancelableEventArgs & IBaseEventArgs>;
    /**
     * Emits an event after the toggle container is closed.
     *
     * ```typescript
     * onToggleClosed(event) {
     *  alert("Toggle closed!");
     * }
     * ```
     *
     * ```html
     * <div
     *   igxToggle
     *   (onClosed)='onToggleClosed($event)'>
     * </div>
     * ```
     */
    onClosed: EventEmitter<any>;
    /**
     * Emits an event before the toggle container is closed.
     *
     * ```typescript
     * onToggleClosing(event) {
     *  alert("Toggle closing!");
     * }
     * ```
     *
     * ```html
     * <div
     *  igxToggle
     *  (onClosing)='onToggleClosing($event)'>
     * </div>
     * ```
     */
    onClosing: EventEmitter<CancelableBrowserEventArgs & IBaseEventArgs>;
    private _collapsed;
    /**
     * @hidden
     */
    get collapsed(): boolean;
    /**
     * Identifier which is registered into `IgxNavigationService`
     *
     * ```typescript
     * let myToggleId = this.toggle.id;
     * ```
     */
    id: string;
    /**
     * @hidden
     */
    get element(): HTMLElement;
    /**
     * @hidden
     */
    get hiddenClass(): boolean;
    /**
     * @hidden
     */
    get defaultClass(): boolean;
    /**
     * @hidden
     */
    constructor(elementRef: ElementRef, cdr: ChangeDetectorRef, overlayService: IgxOverlayService, navigationService: IgxNavigationService);
    /**
     * Emits an event after the toggle element is appended to the overlay container.
     *
     * ```typescript
     * onAppended() {
     *  alert("Content appended!");
     * }
     * ```
     *
     * ```html
     * <div
     *   igxToggle
     *   (onAppended)='onToggleAppended()'>
     * </div>
     * ```
     */
    onAppended: EventEmitter<any>;
    /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     */
    open(overlaySettings?: OverlaySettings): void;
    /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     */
    close(): void;
    /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     */
    toggle(overlaySettings?: OverlaySettings): void;
    /** @hidden @internal */
    get isClosing(): false | import("@angular/animations").AnimationPlayer;
    /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     */
    reposition(): void;
    /**
     * Offsets the content along the corresponding axis by the provided amount
     */
    setOffset(deltaX: number, deltaY: number): void;
    /**
     * @hidden
     */
    ngOnInit(): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    private overlayClosed;
    private unsubscribe;
    private clearSubscription;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxToggleDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxToggleDirective, "[igxToggle]", ["toggle"], {
    "id": "id";
}, {
    "onOpened": "onOpened";
    "onOpening": "onOpening";
    "onClosed": "onClosed";
    "onClosing": "onClosing";
    "onAppended": "onAppended";
}, never>;
}
export declare class IgxToggleActionDirective implements OnInit {
    private element;
    private navigationService;
    protected _overlayDefaults: OverlaySettings;
    /**
     * Provide settings that control the toggle overlay positioning, interaction and scroll behavior.
     * ```typescript
     * const settings: OverlaySettings = {
     *      closeOnOutsideClick: false,
     *      modal: false
     *  }
     * ```
     * ---
     * ```html
     * <!--set-->
     * <div igxToggleAction [overlaySettings]="settings"></div>
     * ```
     */
    overlaySettings: OverlaySettings;
    /**
     * Determines where the toggle element overlay should be attached.
     *
     * ```html
     * <!--set-->
     * <div igxToggleAction [igxToggleOutlet]="outlet"></div>
     * ```
     * Where `outlet` in an instance of `IgxOverlayOutletDirective` or an `ElementRef`
     */
    outlet: IgxOverlayOutletDirective | ElementRef;
    /**
     * @hidden
     */
    set target(target: any);
    /**
     * @hidden
     */
    get target(): any;
    protected _target: IToggleView | string;
    constructor(element: ElementRef, navigationService: IgxNavigationService);
    /**
     * @hidden
     */
    ngOnInit(): void;
    /**
     * @hidden
     */
    onClick(): void;
    /**
     * Updates provided overlay settings
     * @param settings settings to update
     * @returns returns updated copy of provided overlay settings
     */
    protected updateOverlaySettings(settings: OverlaySettings): OverlaySettings;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxToggleActionDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxToggleActionDirective, "[igxToggleAction]", ["toggle-action"], {
    "target": "igxToggleAction";
    "overlaySettings": "overlaySettings";
    "outlet": "igxToggleOutlet";
}, {}, never>;
}
/**
 * Mark an element as an igxOverlay outlet container.
 * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:
 * ```html
 * <div igxOverlayOutlet #outlet="overlay-outlet"></div>
 * ```
 */
export declare class IgxOverlayOutletDirective {
    element: ElementRef;
    constructor(element: ElementRef);
    /** @hidden */
    get nativeElement(): any;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxOverlayOutletDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxOverlayOutletDirective, "[igxOverlayOutlet]", ["overlay-outlet"], {}, {}, never>;
}
/**
 * @hidden
 */
export declare class IgxToggleModule {
    static ɵmod: ɵngcc0.ɵɵNgModuleDefWithMeta<IgxToggleModule, [typeof IgxToggleDirective, typeof IgxToggleActionDirective, typeof IgxOverlayOutletDirective], never, [typeof IgxToggleDirective, typeof IgxToggleActionDirective, typeof IgxOverlayOutletDirective]>;
    static ɵinj: ɵngcc0.ɵɵInjectorDef<IgxToggleModule>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLmRpcmVjdGl2ZS5kLnRzIiwic291cmNlcyI6WyJ0b2dnbGUuZGlyZWN0aXZlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQUtBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEtBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzREE7Ozs7Ozs7Ozs7Ozs7OztBQWFBOzs7Ozs7O0FBS0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4TmF2aWdhdGlvblNlcnZpY2UsIElUb2dnbGVWaWV3IH0gZnJvbSAnLi4vLi4vY29yZS9uYXZpZ2F0aW9uJztcbmltcG9ydCB7IElneE92ZXJsYXlTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvb3ZlcmxheS9vdmVybGF5JztcbmltcG9ydCB7IE92ZXJsYXlTZXR0aW5ncyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzJztcbmltcG9ydCB7IENhbmNlbGFibGVFdmVudEFyZ3MsIENhbmNlbGFibGVCcm93c2VyRXZlbnRBcmdzLCBJQmFzZUV2ZW50QXJncyB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4VG9nZ2xlRGlyZWN0aXZlIGltcGxlbWVudHMgSVRvZ2dsZVZpZXcsIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIGVsZW1lbnRSZWY7XG4gICAgcHJpdmF0ZSBjZHI7XG4gICAgcHJvdGVjdGVkIG92ZXJsYXlTZXJ2aWNlOiBJZ3hPdmVybGF5U2VydmljZTtcbiAgICBwcml2YXRlIG5hdmlnYXRpb25TZXJ2aWNlO1xuICAgIHByb3RlY3RlZCBfb3ZlcmxheUlkOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBkZXN0cm95JDtcbiAgICBwcml2YXRlIF9vdmVybGF5U3ViRmlsdGVyO1xuICAgIHByaXZhdGUgX292ZXJsYXlPcGVuZWRTdWI7XG4gICAgcHJpdmF0ZSBfb3ZlcmxheUNsb3NpbmdTdWI7XG4gICAgcHJpdmF0ZSBfb3ZlcmxheUNsb3NlZFN1YjtcbiAgICBwcml2YXRlIF9vdmVybGF5QXBwZW5kZWRTdWI7XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYWZ0ZXIgdGhlIHRvZ2dsZSBjb250YWluZXIgaXMgb3BlbmVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uVG9nZ2xlT3BlbmVkKGV2ZW50KSB7XG4gICAgICogICAgYWxlcnQoXCJUb2dnbGUgb3BlbmVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICAgaWd4VG9nZ2xlXG4gICAgICogICAob25PcGVuZWQpPSdvblRvZ2dsZU9wZW5lZCgkZXZlbnQpJz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBvbk9wZW5lZDogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYmVmb3JlIHRoZSB0b2dnbGUgY29udGFpbmVyIGlzIG9wZW5lZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBvblRvZ2dsZU9wZW5pbmcoZXZlbnQpIHtcbiAgICAgKiAgYWxlcnQoXCJUb2dnbGUgb3BlbmluZyFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgIGlneFRvZ2dsZVxuICAgICAqICAgKG9uT3BlbmluZyk9J29uVG9nZ2xlT3BlbmluZygkZXZlbnQpJz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBvbk9wZW5pbmc6IEV2ZW50RW1pdHRlcjxDYW5jZWxhYmxlRXZlbnRBcmdzICYgSUJhc2VFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFmdGVyIHRoZSB0b2dnbGUgY29udGFpbmVyIGlzIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBvblRvZ2dsZUNsb3NlZChldmVudCkge1xuICAgICAqICBhbGVydChcIlRvZ2dsZSBjbG9zZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2XG4gICAgICogICBpZ3hUb2dnbGVcbiAgICAgKiAgIChvbkNsb3NlZCk9J29uVG9nZ2xlQ2xvc2VkKCRldmVudCknPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9uQ2xvc2VkOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBiZWZvcmUgdGhlIHRvZ2dsZSBjb250YWluZXIgaXMgY2xvc2VkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uVG9nZ2xlQ2xvc2luZyhldmVudCkge1xuICAgICAqICBhbGVydChcIlRvZ2dsZSBjbG9zaW5nIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICBpZ3hUb2dnbGVcbiAgICAgKiAgKG9uQ2xvc2luZyk9J29uVG9nZ2xlQ2xvc2luZygkZXZlbnQpJz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBvbkNsb3Npbmc6IEV2ZW50RW1pdHRlcjxDYW5jZWxhYmxlQnJvd3NlckV2ZW50QXJncyAmIElCYXNlRXZlbnRBcmdzPjtcbiAgICBwcml2YXRlIF9jb2xsYXBzZWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBjb2xsYXBzZWQoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBJZGVudGlmaWVyIHdoaWNoIGlzIHJlZ2lzdGVyZWQgaW50byBgSWd4TmF2aWdhdGlvblNlcnZpY2VgXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IG15VG9nZ2xlSWQgPSB0aGlzLnRvZ2dsZS5pZDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBpZDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZWxlbWVudCgpOiBIVE1MRWxlbWVudDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGhpZGRlbkNsYXNzKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBkZWZhdWx0Q2xhc3MoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZiwgb3ZlcmxheVNlcnZpY2U6IElneE92ZXJsYXlTZXJ2aWNlLCBuYXZpZ2F0aW9uU2VydmljZTogSWd4TmF2aWdhdGlvblNlcnZpY2UpO1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFmdGVyIHRoZSB0b2dnbGUgZWxlbWVudCBpcyBhcHBlbmRlZCB0byB0aGUgb3ZlcmxheSBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogb25BcHBlbmRlZCgpIHtcbiAgICAgKiAgYWxlcnQoXCJDb250ZW50IGFwcGVuZGVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICAgaWd4VG9nZ2xlXG4gICAgICogICAob25BcHBlbmRlZCk9J29uVG9nZ2xlQXBwZW5kZWQoKSc+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgb25BcHBlbmRlZDogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIHRvZ2dsZS5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm15VG9nZ2xlLm9wZW4oKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBvcGVuKG92ZXJsYXlTZXR0aW5ncz86IE92ZXJsYXlTZXR0aW5ncyk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0b2dnbGUuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS5jbG9zZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNsb3NlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogT3BlbnMgb3IgY2xvc2VzIHRoZSB0b2dnbGUsIGRlcGVuZGluZyBvbiBpdHMgY3VycmVudCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm15VG9nZ2xlLnRvZ2dsZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHRvZ2dsZShvdmVybGF5U2V0dGluZ3M/OiBPdmVybGF5U2V0dGluZ3MpOiB2b2lkO1xuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIGdldCBpc0Nsb3NpbmcoKTogZmFsc2UgfCBpbXBvcnQoXCJAYW5ndWxhci9hbmltYXRpb25zXCIpLkFuaW1hdGlvblBsYXllcjtcbiAgICAvKipcbiAgICAgKiBSZXBvc2l0aW9ucyB0aGUgdG9nZ2xlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm15VG9nZ2xlLnJlcG9zaXRpb24oKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICByZXBvc2l0aW9uKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogT2Zmc2V0cyB0aGUgY29udGVudCBhbG9uZyB0aGUgY29ycmVzcG9uZGluZyBheGlzIGJ5IHRoZSBwcm92aWRlZCBhbW91bnRcbiAgICAgKi9cbiAgICBzZXRPZmZzZXQoZGVsdGFYOiBudW1iZXIsIGRlbHRhWTogbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICBwcml2YXRlIG92ZXJsYXlDbG9zZWQ7XG4gICAgcHJpdmF0ZSB1bnN1YnNjcmliZTtcbiAgICBwcml2YXRlIGNsZWFyU3Vic2NyaXB0aW9uO1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4VG9nZ2xlQWN0aW9uRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0IHtcbiAgICBwcml2YXRlIGVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBuYXZpZ2F0aW9uU2VydmljZTtcbiAgICBwcm90ZWN0ZWQgX292ZXJsYXlEZWZhdWx0czogT3ZlcmxheVNldHRpbmdzO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgc2V0dGluZ3MgdGhhdCBjb250cm9sIHRoZSB0b2dnbGUgb3ZlcmxheSBwb3NpdGlvbmluZywgaW50ZXJhY3Rpb24gYW5kIHNjcm9sbCBiZWhhdmlvci5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3Qgc2V0dGluZ3M6IE92ZXJsYXlTZXR0aW5ncyA9IHtcbiAgICAgKiAgICAgIGNsb3NlT25PdXRzaWRlQ2xpY2s6IGZhbHNlLFxuICAgICAqICAgICAgbW9kYWw6IGZhbHNlXG4gICAgICogIH1cbiAgICAgKiBgYGBcbiAgICAgKiAtLS1cbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxkaXYgaWd4VG9nZ2xlQWN0aW9uIFtvdmVybGF5U2V0dGluZ3NdPVwic2V0dGluZ3NcIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBvdmVybGF5U2V0dGluZ3M6IE92ZXJsYXlTZXR0aW5ncztcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXJlIHRoZSB0b2dnbGUgZWxlbWVudCBvdmVybGF5IHNob3VsZCBiZSBhdHRhY2hlZC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGRpdiBpZ3hUb2dnbGVBY3Rpb24gW2lneFRvZ2dsZU91dGxldF09XCJvdXRsZXRcIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBXaGVyZSBgb3V0bGV0YCBpbiBhbiBpbnN0YW5jZSBvZiBgSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZWAgb3IgYW4gYEVsZW1lbnRSZWZgXG4gICAgICovXG4gICAgb3V0bGV0OiBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlIHwgRWxlbWVudFJlZjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2V0IHRhcmdldCh0YXJnZXQ6IGFueSk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCB0YXJnZXQoKTogYW55O1xuICAgIHByb3RlY3RlZCBfdGFyZ2V0OiBJVG9nZ2xlVmlldyB8IHN0cmluZztcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50UmVmLCBuYXZpZ2F0aW9uU2VydmljZTogSWd4TmF2aWdhdGlvblNlcnZpY2UpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkNsaWNrKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBwcm92aWRlZCBvdmVybGF5IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHNldHRpbmdzIHNldHRpbmdzIHRvIHVwZGF0ZVxuICAgICAqIEByZXR1cm5zIHJldHVybnMgdXBkYXRlZCBjb3B5IG9mIHByb3ZpZGVkIG92ZXJsYXkgc2V0dGluZ3NcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdXBkYXRlT3ZlcmxheVNldHRpbmdzKHNldHRpbmdzOiBPdmVybGF5U2V0dGluZ3MpOiBPdmVybGF5U2V0dGluZ3M7XG59XG4vKipcbiAqIE1hcmsgYW4gZWxlbWVudCBhcyBhbiBpZ3hPdmVybGF5IG91dGxldCBjb250YWluZXIuXG4gKiBEaXJlY3RpdmUgaW5zdGFuY2UgaXMgZXhwb3J0ZWQgYXMgYG92ZXJsYXktb3V0bGV0YCB0byBiZSBhc3NpZ25lZCB0byB0ZW1wbGF0ZXMgdmFyaWFibGVzOlxuICogYGBgaHRtbFxuICogPGRpdiBpZ3hPdmVybGF5T3V0bGV0ICNvdXRsZXQ9XCJvdmVybGF5LW91dGxldFwiPjwvZGl2PlxuICogYGBgXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneE92ZXJsYXlPdXRsZXREaXJlY3RpdmUge1xuICAgIGVsZW1lbnQ6IEVsZW1lbnRSZWY7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudFJlZik7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBnZXQgbmF0aXZlRWxlbWVudCgpOiBhbnk7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4VG9nZ2xlTW9kdWxlIHtcbn1cbiJdfQ==