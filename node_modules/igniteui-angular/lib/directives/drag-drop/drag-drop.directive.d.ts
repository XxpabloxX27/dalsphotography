import { ElementRef, EventEmitter, NgZone, OnDestroy, OnInit, Renderer2, ChangeDetectorRef, ViewContainerRef, AfterContentInit, TemplateRef, QueryList } from '@angular/core';
import { Subject } from 'rxjs';
import { IgxDragHandleDirective } from './drag-handle.directive';
import { IBaseEventArgs } from '../../core/utils';
import { IDropStrategy } from './drag-drop.strategy';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './drag-handle.directive';
export declare enum RestrictDrag {
    VERTICALLY = 0,
    HORIZONTALLY = 1,
    NONE = 2
}
export interface IgxDragCustomEventDetails {
    startX: number;
    startY: number;
    pageX: number;
    pageY: number;
    owner: IgxDragDirective;
    originalEvent: any;
}
export interface IDropBaseEventArgs extends IBaseEventArgs {
    /**
 * Reference to the original event that caused the draggable element to enter the igxDrop element.
 * Can be PointerEvent, TouchEvent or MouseEvent.
 */
    originalEvent: any;
    /** The owner igxDrop directive that triggered this event. */
    owner: IgxDropDirective;
    /** The igxDrag directive instanced on an element that entered the area of the igxDrop element */
    drag: IgxDragDirective;
    /** The data contained for the draggable element in igxDrag directive. */
    dragData: any;
    /** The initial position of the pointer on X axis when the dragged element began moving */
    startX: number;
    /** The initial position of the pointer on Y axis when the dragged element began moving */
    startY: number;
    /**
     * The current position of the pointer on X axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     */
    pageX: number;
    /**
     * The current position of the pointer on Y axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     */
    pageY: number;
    /**
     * The current position of the pointer on X axis relative to the container that initializes the igxDrop.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     */
    offsetX: number;
    /**
     * The current position of the pointer on Y axis relative to the container that initializes the igxDrop.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     */
    offsetY: number;
}
export interface IDropDroppedEventArgs extends IDropBaseEventArgs {
    /** Specifies if the default drop logic related to the event should be canceled. */
    cancel: boolean;
}
export interface IDragBaseEventArgs extends IBaseEventArgs {
    /**
     * Reference to the original event that caused the interaction with the element.
     * Can be PointerEvent, TouchEvent or MouseEvent.
     */
    originalEvent: PointerEvent | MouseEvent | TouchEvent;
    /** The owner igxDrag directive that triggered this event. */
    owner: IgxDragDirective;
    /** The initial position of the pointer on X axis when the dragged element began moving */
    startX: number;
    /** The initial position of the pointer on Y axis when the dragged element began moving */
    startY: number;
    /**
     * The current position of the pointer on X axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     */
    pageX: number;
    /**
 * The current position of the pointer on Y axis when the event was triggered.
 * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
 */
    pageY: number;
}
export interface IDragStartEventArgs extends IDragBaseEventArgs {
    /** Set if the the dragging should be canceled. */
    cancel: boolean;
}
export interface IDragMoveEventArgs extends IDragStartEventArgs {
    /** The new pageX position of the pointer that the igxDrag will use. It can be overridden to limit dragged element X movement. */
    nextPageX: number;
    /** The new pageX position of the pointer that the igxDrag will use. It can be overridden to limit dragged element Y movement. */
    nextPageY: number;
}
export interface IDragGhostBaseEventArgs extends IBaseEventArgs {
    /** The owner igxDrag directive that triggered this event. */
    owner: IgxDragDirective;
    /** Instance to the ghost element that is created when dragging starts. */
    ghostElement: any;
    /** Set if the ghost creation/destruction should be canceled. */
    cancel: boolean;
}
export interface IDragCustomTransitionArgs {
    duration?: number;
    timingFunction?: string;
    delay?: number;
}
export declare class IgxDragLocation {
    private _pageX;
    private _pageY;
    pageX: number;
    pageY: number;
    constructor(_pageX: any, _pageY: any);
}
export declare class IgxDragDirective implements AfterContentInit, OnDestroy {
    cdr: ChangeDetectorRef;
    element: ElementRef;
    viewContainer: ViewContainerRef;
    zone: NgZone;
    renderer: Renderer2;
    protected ghostContext: any;
    /**
     * - Save data inside the `igxDrag` directive. This can be set when instancing `igxDrag` on an element.
     * ```html
     * <div [igxDrag]="{ source: myElement }"></div>
     * ```
     * @memberof IgxDragDirective
     */
    data: any;
    /**
     * An @Input property that indicates when the drag should start.
     * By default the drag starts after the draggable element is moved by 5px.
     * ```html
     * <div igxDrag [dragTolerance]="100">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    dragTolerance: number;
    /**
     * An @Input property that provide a way for igxDrag and igxDrop to be linked through channels.
     * It accepts single value or an array of values and evaluates then using strict equality.
     * ```html
     * <div igxDrag [dragChannel]="'odd'">
     *         <span>95</span>
     * </div>
     * <div igxDrop [dropChannel]="['odd', 'irrational']">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    dragChannel: number | string | number[] | string[];
    /**
     * An @Input property that specifies if the base element should not be moved and a ghost element should be rendered that represents it.
     * By default it is set to `true`.
     * If it is set to `false` when dragging the base element is moved instead and no ghost elements are rendered.
     * ```html
     * <div igxDrag [ghost]="false">
     *      <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    ghost: boolean;
    /**
     * Sets a custom class that will be added to the `ghostElement` element.
     * ```html
     * <div igxDrag [ghostClass]="'ghostElement'">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    ghostClass: string;
    /**
     * @deprecated Please use custom base styling instead.
     * An @Input property that hides the draggable element.
     * By default it's set to false.
     * ```html
     * <div igxDrag [dragTolerance]="100" [hideBaseOnDrag]="'true'">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    hideBaseOnDrag: boolean;
    /**
     * @deprecated Please use provided transition functions in future.
     * An @Input property that enables/disables the draggable element animation
     * when the element is released.
     * By default it's set to false.
     * ```html
     * <div igxDrag [animateOnRelease]="'true'">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    animateOnRelease: boolean;
    /**
     * An @Input property that specifies a template for the ghost element created when dragging starts and `ghost` is true.
     * By default a clone of the base element the igxDrag is instanced is created.
     * ```html
     * <div igxDrag [ghostTemplate]="customGhost">
     *         <span>Drag Me!</span>
     * </div>
     * <ng-template #customGhost>
     *      <div class="customGhostStyle">
     *          <span>I am being dragged!</span>
     *      </div>
     * </ng-template>
     * ```
     * @memberof IgxDragDirective
     */
    ghostTemplate: TemplateRef<any>;
    /**
     * An @Input property that sets the element to which the dragged element will be appended.
     * By default it's set to null and the dragged element is appended to the body.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostHost]="hostDiv">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    ghostHost: any;
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetX]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    set ghostOffsetX(value: any);
    get ghostOffsetX(): any;
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetY]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    set ghostOffsetY(value: any);
    get ghostOffsetY(): any;
    /**
     * Event triggered when the draggable element drag starts.
     * ```html
     * <div igxDrag (dragStart)="onDragStart()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragStart(){
     *      alert("The drag has stared!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    dragStart: EventEmitter<IDragStartEventArgs>;
    /**
     * Event triggered when the draggable element has been moved.
     * ```html
     * <div igxDrag  (dragMove)="onDragMove()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragMove(){
     *      alert("The element has moved!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    dragMove: EventEmitter<IDragMoveEventArgs>;
    /**
     * Event triggered when the draggable element is released.
     * ```html
     * <div igxDrag (dragEnd)="onDragEnd()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragEnd(){
     *      alert("The drag has ended!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    dragEnd: EventEmitter<IDragBaseEventArgs>;
    /**
     * Event triggered when the draggable element is clicked.
     * ```html
     * <div igxDrag (dragClick)="onDragClick()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragClick(){
     *      alert("The element has been clicked!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    dragClick: EventEmitter<IDragBaseEventArgs>;
    /**
     * Event triggered when the drag ghost element is created.
     * ```html
     * <div igxDrag (ghostCreate)="ghostCreated()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public ghostCreated(){
     *      alert("The ghost has been created!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    ghostCreate: EventEmitter<IDragGhostBaseEventArgs>;
    /**
     * Event triggered when the drag ghost element is created.
     * ```html
     * <div igxDrag (ghostDestroy)="ghostDestroyed()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public ghostDestroyed(){
     *      alert("The ghost has been destroyed!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    ghostDestroy: EventEmitter<IDragGhostBaseEventArgs>;
    /**
     * Event triggered after the draggable element is released and after its animation has finished.
     * ```html
     * <div igxDrag (transitioned)="onMoveEnd()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onMoveEnd(){
     *      alert("The move has ended!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    transitioned: EventEmitter<IDragBaseEventArgs>;
    /**
     * @hidden
     */
    dragHandles: QueryList<IgxDragHandleDirective>;
    /**
     * @hidden
     */
    _visibility: string;
    /**
     * @hidden
     */
    baseClass: boolean;
    /**
     * @hidden
     */
    selectDisabled: boolean;
    /**
     * @deprecated Please use native angular ways of hiding it using custom to the base element styling for future versions.
     * Sets the visibility of the draggable element.
     * ```typescript
     * @ViewChild("myDrag" ,{read: IgxDragDirective})
     * public myDrag: IgxDragDirective;
     * ngAfterViewInit(){
     *     this.myDrag.visible = false;
     * }
     * ```
     */
    set visible(bVisible: boolean);
    /**
     * Returns the visibility state of the draggable element.
     * ```typescript
     * @ViewChild("myDrag" ,{read: IgxDragDirective})
     * public myDrag: IgxDragDirective;
     * ngAfterViewInit(){
     *     let dragVisibility = this.myDrag.visible;
     * }
     * ```
     */
    get visible(): boolean;
    /**
     * Gets the current location of the element relative to the page.
     */
    get location(): IgxDragLocation;
    /**
     * Gets the original location of the element before dragging started.
     */
    get originLocation(): IgxDragLocation;
    /**
     * @hidden
     */
    get pointerEventsEnabled(): boolean;
    /**
     * @hidden
     */
    get touchEventsEnabled(): boolean;
    /**
     * @hidden
     */
    get pageX(): number;
    /**
     * @hidden
     */
    get pageY(): number;
    protected get baseLeft(): number;
    protected get baseTop(): number;
    protected get baseOriginLeft(): number;
    protected get baseOriginTop(): number;
    protected set ghostLeft(pageX: number);
    protected get ghostLeft(): number;
    protected set ghostTop(pageY: number);
    protected get ghostTop(): number;
    /**
     * @hidden
     */
    defaultReturnDuration: string;
    /**
     * @hidden
     */
    ghostElement: any;
    /**
     * @hidden
     */
    animInProgress: boolean;
    protected _startX: number;
    protected _startY: number;
    protected _lastX: number;
    protected _lastY: number;
    protected _dragStarted: boolean;
    /** Drag ghost related properties */
    protected _defaultOffsetX: any;
    protected _defaultOffsetY: any;
    protected _offsetX: any;
    protected _offsetY: any;
    protected _ghostStartX: any;
    protected _ghostStartY: any;
    protected _ghostHostX: number;
    protected _ghostHostY: number;
    protected _pointerDownId: any;
    protected _clicked: boolean;
    protected _lastDropArea: any;
    protected _destroy: Subject<boolean>;
    protected _removeOnDestroy: boolean;
    constructor(cdr: ChangeDetectorRef, element: ElementRef, viewContainer: ViewContainerRef, zone: NgZone, renderer: Renderer2);
    /**
     * @hidden
     */
    ngAfterContentInit(): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    /**
     * Sets desired location of the base element or ghost element if rended relative to the document.
     * @param newLocation New location that should be applied. It is advised to get new location using getBoundingClientRects() + scroll.
     */
    setLocation(newLocation: IgxDragLocation): void;
    /**
     * Animates the base or ghost element depending on the `ghost` input to its initial location.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * If the base element has changed its DOM position its initial location will be changed accordingly.
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionToOrigin(customAnimArgs?: IDragCustomTransitionArgs, startLocation?: IgxDragLocation): void;
    /**
     * Animates the base or ghost element to a specific target location or other element using transition.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * It is recommended to use 'getBoundingClientRects() + pageScroll' when determining desired location.
     * @param target Target that the base or ghost will transition to. It can be either location in the page or another HTML element.
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionTo(target: IgxDragLocation | ElementRef, customAnimArgs?: IDragCustomTransitionArgs, startLocation?: IgxDragLocation): void;
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param event PointerDown event captured
     */
    onPointerDown(event: any): void;
    /**
     * @hidden
     * Perform drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned it. Then this method is bound to it.
     * @param event PointerMove event captured
     */
    onPointerMove(event: any): void;
    /**
     * @hidden
     * Perform drag end logic when releasing the ghostElement and dispatching drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned to it. Then this method is bound to it.
     * @param event PointerUp event captured
     */
    onPointerUp(event: any): void;
    /**
     * @hidden
     * Execute this method whe the pointer capture has been lost.
     * This means that during dragging the user has performed other action like right clicking and then clicking somewhere else.
     * This method will ensure that the drag state is being reset in this case as if the user released the dragged element.
     * @param event Event captured
     */
    onPointerLost(event: any): void;
    /**
     * @hidden
     * Create ghost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @param pageX Latest pointer position on the X axis relative to the page.
     * @param pageY Latest pointer position on the Y axis relative to the page.
     * @param node The Node object to be cloned.
     */
    protected createGhost(pageX: any, pageY: any, node?: any): void;
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     */
    protected dispatchDragEvents(pageX: number, pageY: number, originalEvent: any): void;
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in @dispatchDragEvents method.
     */
    protected dispatchDropEvent(pageX: number, pageY: number, originalEvent: any): void;
    /**
     * @hidden
     */
    onTransitionEnd(event: any): void;
    /**
     * @hidden
     */
    protected getElementsAtPoint(pageX: number, pageY: number): any;
    /**
     * @hidden
     */
    protected dispatchEvent(target: any, eventName: string, eventArgs: IgxDragCustomEventDetails): void;
    protected getTransformX(elem: any): number;
    protected getTransformY(elem: any): number;
    /** Method setting transformation to the base draggable element. */
    protected setTransformXY(x: number, y: number): void;
    protected getWindowScrollTop(): number;
    protected getWindowScrollLeft(): number;
    protected ghostHostOffsetLeft(ghostHost: any): number;
    protected ghostHostOffsetTop(ghostHost: any): number;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxDragDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxDragDirective, "[igxDrag]", ["drag"], {
    "dragTolerance": "dragTolerance";
    "ghost": "ghost";
    "ghostClass": "ghostClass";
    "hideBaseOnDrag": "hideBaseOnDrag";
    "animateOnRelease": "animateOnRelease";
    "ghostOffsetX": "ghostOffsetX";
    "ghostOffsetY": "ghostOffsetY";
    "data": "igxDrag";
    "dragChannel": "dragChannel";
    "ghostTemplate": "ghostTemplate";
    "ghostHost": "ghostHost";
}, {
    "dragStart": "dragStart";
    "dragMove": "dragMove";
    "dragEnd": "dragEnd";
    "dragClick": "dragClick";
    "ghostCreate": "ghostCreate";
    "ghostDestroy": "ghostDestroy";
    "transitioned": "transitioned";
}, ["dragHandles"]>;
}
export declare class IgxDropDirective implements OnInit, OnDestroy {
    element: ElementRef;
    private _renderer;
    private _zone;
    /**
     * - Save data inside the `igxDrop` directive. This can be set when instancing `igxDrop` on an element.
     * ```html
     * <div [igxDrop]="{ source: myElement }"></div>
     * ```
     * @memberof IgxDropDirective
     */
    data: any;
    /**
     * An @Input property that provide a way for igxDrag and igxDrop to be linked through channels.
     * It accepts single value or an array of values and evaluates then using strict equality.
     * ```html
     * <div igxDrag [dragChannel]="'odd'">
     *         <span>95</span>
     * </div>
     * <div igxDrop [dropChannel]="['odd', 'irrational']">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * @memberof IgxDropDirective
     */
    dropChannel: number | string | number[] | string[];
    /**
     * An @Input property that specifies a drop strategy type that will be executed when an `IgxDrag` element is released inside
     *  the current drop area. The provided strategies are:
     *  - IgxDefaultDropStrategy - This is the default base strategy and it doesn't perform any actions.
     *  - IgxAppendDropStrategy - Appends the dropped element to last position as a direct child to the `igxDrop`.
     *  - IgxPrependDropStrategy - Prepends the dropped element to first position as a direct child to the `igxDrop`.
     *  - IgxInsertDropStrategy - If the dropped element is released above a child element of the `igxDrop`, it will be inserted
     *      at that position. Otherwise the dropped element will be appended if released outside any child of the `igxDrop`.
     * ```html
     * <div igxDrag>
     *      <span>DragMe</span>
     * </div>
     * <div igxDrop [dropStrategy]="myDropStrategy">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * ```typescript
     * import { IgxAppendDropStrategy } from 'igniteui-angular';
     *
     * export class App {
     *      public myDropStrategy = IgxAppendDropStrategy;
     * }
     * ```
     * @memberof IgxDropDirective
     */
    set dropStrategy(classRef: any);
    get dropStrategy(): any;
    /** Event triggered when dragged element enters the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragEnter(){
     *     alert("A draggable element has entered the chip area!");
     * }
     * ```
     * @memberof IgxDropDirective
     */
    enter: EventEmitter<IDropBaseEventArgs>;
    /** Event triggered when dragged element enters the area of the element.
 * ```html
 * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
 * </div>
 * ```
 * ```typescript
 * public dragEnter(){
 *     alert("A draggable element has entered the chip area!");
 * }
 * ```
 * @memberof IgxDropDirective
 */
    over: EventEmitter<IDropBaseEventArgs>;
    /** Event triggered when dragged element leaves the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (leave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragLeave(){
     *     alert("A draggable element has left the chip area!");
     * }
     * ```
     * @memberof IgxDropDirective
     */
    leave: EventEmitter<IDropBaseEventArgs>;
    /** Event triggered when dragged element is dropped in the area of the element.
     * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
     * To cancel the default logic the `cancel` property of the event needs to be set to true.
     * ```html
     * <div class="cageArea" igxDrop (dropped)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragDrop(){
     *     alert("A draggable element has been dropped in the chip area!");
     * }
     * ```
     * @memberof IgxDropDirective
     */
    dropped: EventEmitter<IDropDroppedEventArgs>;
    /**
     * @hidden
     */
    droppable: boolean;
    /**
     * @hidden
     */
    dragover: boolean;
    /**
     * @hidden
     */
    protected _destroy: Subject<boolean>;
    protected _dropStrategy: IDropStrategy;
    constructor(element: ElementRef, _renderer: Renderer2, _zone: NgZone);
    /**
     * @hidden
     */
    ngOnInit(): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    onDragOver(event: any): void;
    /**
     * @hidden
     */
    onDragEnter(event: CustomEvent<IgxDragCustomEventDetails>): void;
    /**
     * @hidden
     */
    onDragLeave(event: any): void;
    /**
     * @hidden
     */
    onDragDrop(event: any): void;
    protected getWindowScrollTop(): number;
    protected getWindowScrollLeft(): number;
    protected isDragLinked(drag: IgxDragDirective): boolean;
    protected getInsertIndexAt(draggedDir: IgxDragDirective, elementsAtPoint: any[]): number;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxDropDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxDropDirective, "[igxDrop]", ["drop"], {
    "dropStrategy": "dropStrategy";
    "data": "igxDrop";
    "dropChannel": "dropChannel";
}, {
    "enter": "enter";
    "over": "over";
    "leave": "leave";
    "dropped": "dropped";
}, never>;
}
/**
 * @hidden
 */
export declare class IgxDragDropModule {
    static ɵmod: ɵngcc0.ɵɵNgModuleDefWithMeta<IgxDragDropModule, [typeof IgxDragDirective, typeof IgxDropDirective, typeof ɵngcc1.IgxDragHandleDirective], never, [typeof IgxDragDirective, typeof IgxDropDirective, typeof ɵngcc1.IgxDragHandleDirective]>;
    static ɵinj: ɵngcc0.ɵɵInjectorDef<IgxDragDropModule>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZy1kcm9wLmRpcmVjdGl2ZS5kLnRzIiwic291cmNlcyI6WyJkcmFnLWRyb3AuZGlyZWN0aXZlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7QUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNmlCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzSkE7Ozs7Ozs7QUFLQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgTmdab25lLCBPbkRlc3Ryb3ksIE9uSW5pdCwgUmVuZGVyZXIyLCBDaGFuZ2VEZXRlY3RvclJlZiwgVmlld0NvbnRhaW5lclJlZiwgQWZ0ZXJDb250ZW50SW5pdCwgVGVtcGxhdGVSZWYsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSWd4RHJhZ0hhbmRsZURpcmVjdGl2ZSB9IGZyb20gJy4vZHJhZy1oYW5kbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IElCYXNlRXZlbnRBcmdzIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBJRHJvcFN0cmF0ZWd5IH0gZnJvbSAnLi9kcmFnLWRyb3Auc3RyYXRlZ3knO1xuZXhwb3J0IGRlY2xhcmUgZW51bSBSZXN0cmljdERyYWcge1xuICAgIFZFUlRJQ0FMTFkgPSAwLFxuICAgIEhPUklaT05UQUxMWSA9IDEsXG4gICAgTk9ORSA9IDJcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscyB7XG4gICAgc3RhcnRYOiBudW1iZXI7XG4gICAgc3RhcnRZOiBudW1iZXI7XG4gICAgcGFnZVg6IG51bWJlcjtcbiAgICBwYWdlWTogbnVtYmVyO1xuICAgIG93bmVyOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgIG9yaWdpbmFsRXZlbnQ6IGFueTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSURyb3BCYXNlRXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIC8qKlxuICogUmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCBldmVudCB0aGF0IGNhdXNlZCB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgdG8gZW50ZXIgdGhlIGlneERyb3AgZWxlbWVudC5cbiAqIENhbiBiZSBQb2ludGVyRXZlbnQsIFRvdWNoRXZlbnQgb3IgTW91c2VFdmVudC5cbiAqL1xuICAgIG9yaWdpbmFsRXZlbnQ6IGFueTtcbiAgICAvKiogVGhlIG93bmVyIGlneERyb3AgZGlyZWN0aXZlIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuICovXG4gICAgb3duZXI6IElneERyb3BEaXJlY3RpdmU7XG4gICAgLyoqIFRoZSBpZ3hEcmFnIGRpcmVjdGl2ZSBpbnN0YW5jZWQgb24gYW4gZWxlbWVudCB0aGF0IGVudGVyZWQgdGhlIGFyZWEgb2YgdGhlIGlneERyb3AgZWxlbWVudCAqL1xuICAgIGRyYWc6IElneERyYWdEaXJlY3RpdmU7XG4gICAgLyoqIFRoZSBkYXRhIGNvbnRhaW5lZCBmb3IgdGhlIGRyYWdnYWJsZSBlbGVtZW50IGluIGlneERyYWcgZGlyZWN0aXZlLiAqL1xuICAgIGRyYWdEYXRhOiBhbnk7XG4gICAgLyoqIFRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFggYXhpcyB3aGVuIHRoZSBkcmFnZ2VkIGVsZW1lbnQgYmVnYW4gbW92aW5nICovXG4gICAgc3RhcnRYOiBudW1iZXI7XG4gICAgLyoqIFRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFkgYXhpcyB3aGVuIHRoZSBkcmFnZ2VkIGVsZW1lbnQgYmVnYW4gbW92aW5nICovXG4gICAgc3RhcnRZOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWCBheGlzIHdoZW4gdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQuXG4gICAgICogTm90ZTogVGhlIGJyb3dzZXIgbWlnaHQgdHJpZ2dlciB0aGUgZXZlbnQgd2l0aCBzb21lIGRlbGF5IGFuZCBwb2ludGVyIHdvdWxkIGJlIGFscmVhZHkgaW5zaWRlIHRoZSBpZ3hEcm9wLlxuICAgICAqL1xuICAgIHBhZ2VYOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWSBheGlzIHdoZW4gdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQuXG4gICAgICogTm90ZTogVGhlIGJyb3dzZXIgbWlnaHQgdHJpZ2dlciB0aGUgZXZlbnQgd2l0aCBzb21lIGRlbGF5IGFuZCBwb2ludGVyIHdvdWxkIGJlIGFscmVhZHkgaW5zaWRlIHRoZSBpZ3hEcm9wLlxuICAgICAqL1xuICAgIHBhZ2VZOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWCBheGlzIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgdGhhdCBpbml0aWFsaXplcyB0aGUgaWd4RHJvcC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgb2Zmc2V0WDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFkgYXhpcyByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIGlneERyb3AuXG4gICAgICogTm90ZTogVGhlIGJyb3dzZXIgbWlnaHQgdHJpZ2dlciB0aGUgZXZlbnQgd2l0aCBzb21lIGRlbGF5IGFuZCBwb2ludGVyIHdvdWxkIGJlIGFscmVhZHkgaW5zaWRlIHRoZSBpZ3hEcm9wLlxuICAgICAqL1xuICAgIG9mZnNldFk6IG51bWJlcjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSURyb3BEcm9wcGVkRXZlbnRBcmdzIGV4dGVuZHMgSURyb3BCYXNlRXZlbnRBcmdzIHtcbiAgICAvKiogU3BlY2lmaWVzIGlmIHRoZSBkZWZhdWx0IGRyb3AgbG9naWMgcmVsYXRlZCB0byB0aGUgZXZlbnQgc2hvdWxkIGJlIGNhbmNlbGVkLiAqL1xuICAgIGNhbmNlbDogYm9vbGVhbjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSURyYWdCYXNlRXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgZXZlbnQgdGhhdCBjYXVzZWQgdGhlIGludGVyYWN0aW9uIHdpdGggdGhlIGVsZW1lbnQuXG4gICAgICogQ2FuIGJlIFBvaW50ZXJFdmVudCwgVG91Y2hFdmVudCBvciBNb3VzZUV2ZW50LlxuICAgICAqL1xuICAgIG9yaWdpbmFsRXZlbnQ6IFBvaW50ZXJFdmVudCB8IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50O1xuICAgIC8qKiBUaGUgb3duZXIgaWd4RHJhZyBkaXJlY3RpdmUgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudC4gKi9cbiAgICBvd25lcjogSWd4RHJhZ0RpcmVjdGl2ZTtcbiAgICAvKiogVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWCBheGlzIHdoZW4gdGhlIGRyYWdnZWQgZWxlbWVudCBiZWdhbiBtb3ZpbmcgKi9cbiAgICBzdGFydFg6IG51bWJlcjtcbiAgICAvKiogVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWSBheGlzIHdoZW4gdGhlIGRyYWdnZWQgZWxlbWVudCBiZWdhbiBtb3ZpbmcgKi9cbiAgICBzdGFydFk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBYIGF4aXMgd2hlbiB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgcGFnZVg6IG51bWJlcjtcbiAgICAvKipcbiAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFkgYXhpcyB3aGVuIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICogTm90ZTogVGhlIGJyb3dzZXIgbWlnaHQgdHJpZ2dlciB0aGUgZXZlbnQgd2l0aCBzb21lIGRlbGF5IGFuZCBwb2ludGVyIHdvdWxkIGJlIGFscmVhZHkgaW5zaWRlIHRoZSBpZ3hEcm9wLlxuICovXG4gICAgcGFnZVk6IG51bWJlcjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSURyYWdTdGFydEV2ZW50QXJncyBleHRlbmRzIElEcmFnQmFzZUV2ZW50QXJncyB7XG4gICAgLyoqIFNldCBpZiB0aGUgdGhlIGRyYWdnaW5nIHNob3VsZCBiZSBjYW5jZWxlZC4gKi9cbiAgICBjYW5jZWw6IGJvb2xlYW47XG59XG5leHBvcnQgaW50ZXJmYWNlIElEcmFnTW92ZUV2ZW50QXJncyBleHRlbmRzIElEcmFnU3RhcnRFdmVudEFyZ3Mge1xuICAgIC8qKiBUaGUgbmV3IHBhZ2VYIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIHRoYXQgdGhlIGlneERyYWcgd2lsbCB1c2UuIEl0IGNhbiBiZSBvdmVycmlkZGVuIHRvIGxpbWl0IGRyYWdnZWQgZWxlbWVudCBYIG1vdmVtZW50LiAqL1xuICAgIG5leHRQYWdlWDogbnVtYmVyO1xuICAgIC8qKiBUaGUgbmV3IHBhZ2VYIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIHRoYXQgdGhlIGlneERyYWcgd2lsbCB1c2UuIEl0IGNhbiBiZSBvdmVycmlkZGVuIHRvIGxpbWl0IGRyYWdnZWQgZWxlbWVudCBZIG1vdmVtZW50LiAqL1xuICAgIG5leHRQYWdlWTogbnVtYmVyO1xufVxuZXhwb3J0IGludGVyZmFjZSBJRHJhZ0dob3N0QmFzZUV2ZW50QXJncyBleHRlbmRzIElCYXNlRXZlbnRBcmdzIHtcbiAgICAvKiogVGhlIG93bmVyIGlneERyYWcgZGlyZWN0aXZlIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuICovXG4gICAgb3duZXI6IElneERyYWdEaXJlY3RpdmU7XG4gICAgLyoqIEluc3RhbmNlIHRvIHRoZSBnaG9zdCBlbGVtZW50IHRoYXQgaXMgY3JlYXRlZCB3aGVuIGRyYWdnaW5nIHN0YXJ0cy4gKi9cbiAgICBnaG9zdEVsZW1lbnQ6IGFueTtcbiAgICAvKiogU2V0IGlmIHRoZSBnaG9zdCBjcmVhdGlvbi9kZXN0cnVjdGlvbiBzaG91bGQgYmUgY2FuY2VsZWQuICovXG4gICAgY2FuY2VsOiBib29sZWFuO1xufVxuZXhwb3J0IGludGVyZmFjZSBJRHJhZ0N1c3RvbVRyYW5zaXRpb25BcmdzIHtcbiAgICBkdXJhdGlvbj86IG51bWJlcjtcbiAgICB0aW1pbmdGdW5jdGlvbj86IHN0cmluZztcbiAgICBkZWxheT86IG51bWJlcjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneERyYWdMb2NhdGlvbiB7XG4gICAgcHJpdmF0ZSBfcGFnZVg7XG4gICAgcHJpdmF0ZSBfcGFnZVk7XG4gICAgcGFnZVg6IG51bWJlcjtcbiAgICBwYWdlWTogbnVtYmVyO1xuICAgIGNvbnN0cnVjdG9yKF9wYWdlWDogYW55LCBfcGFnZVk6IGFueSk7XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBJZ3hEcmFnRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcbiAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmO1xuICAgIGVsZW1lbnQ6IEVsZW1lbnRSZWY7XG4gICAgdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZjtcbiAgICB6b25lOiBOZ1pvbmU7XG4gICAgcmVuZGVyZXI6IFJlbmRlcmVyMjtcbiAgICBwcm90ZWN0ZWQgZ2hvc3RDb250ZXh0OiBhbnk7XG4gICAgLyoqXG4gICAgICogLSBTYXZlIGRhdGEgaW5zaWRlIHRoZSBgaWd4RHJhZ2AgZGlyZWN0aXZlLiBUaGlzIGNhbiBiZSBzZXQgd2hlbiBpbnN0YW5jaW5nIGBpZ3hEcmFnYCBvbiBhbiBlbGVtZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IFtpZ3hEcmFnXT1cInsgc291cmNlOiBteUVsZW1lbnQgfVwiPjwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgZGF0YTogYW55O1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IGluZGljYXRlcyB3aGVuIHRoZSBkcmFnIHNob3VsZCBzdGFydC5cbiAgICAgKiBCeSBkZWZhdWx0IHRoZSBkcmFnIHN0YXJ0cyBhZnRlciB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgbW92ZWQgYnkgNXB4LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2RyYWdUb2xlcmFuY2VdPVwiMTAwXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIGRyYWdUb2xlcmFuY2U6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBwcm92aWRlIGEgd2F5IGZvciBpZ3hEcmFnIGFuZCBpZ3hEcm9wIHRvIGJlIGxpbmtlZCB0aHJvdWdoIGNoYW5uZWxzLlxuICAgICAqIEl0IGFjY2VwdHMgc2luZ2xlIHZhbHVlIG9yIGFuIGFycmF5IG9mIHZhbHVlcyBhbmQgZXZhbHVhdGVzIHRoZW4gdXNpbmcgc3RyaWN0IGVxdWFsaXR5LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2RyYWdDaGFubmVsXT1cIidvZGQnXCI+XG4gICAgICogICAgICAgICA8c3Bhbj45NTwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyb3AgW2Ryb3BDaGFubmVsXT1cIlsnb2RkJywgJ2lycmF0aW9uYWwnXVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+TnVtYmVycyBkcm9wIGFyZWEhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgZHJhZ0NoYW5uZWw6IG51bWJlciB8IHN0cmluZyB8IG51bWJlcltdIHwgc3RyaW5nW107XG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc3BlY2lmaWVzIGlmIHRoZSBiYXNlIGVsZW1lbnQgc2hvdWxkIG5vdCBiZSBtb3ZlZCBhbmQgYSBnaG9zdCBlbGVtZW50IHNob3VsZCBiZSByZW5kZXJlZCB0aGF0IHJlcHJlc2VudHMgaXQuXG4gICAgICogQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gYHRydWVgLlxuICAgICAqIElmIGl0IGlzIHNldCB0byBgZmFsc2VgIHdoZW4gZHJhZ2dpbmcgdGhlIGJhc2UgZWxlbWVudCBpcyBtb3ZlZCBpbnN0ZWFkIGFuZCBubyBnaG9zdCBlbGVtZW50cyBhcmUgcmVuZGVyZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZ2hvc3RdPVwiZmFsc2VcIj5cbiAgICAgKiAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgZ2hvc3Q6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0cyBhIGN1c3RvbSBjbGFzcyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGBnaG9zdEVsZW1lbnRgIGVsZW1lbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZ2hvc3RDbGFzc109XCInZ2hvc3RFbGVtZW50J1wiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBnaG9zdENsYXNzOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBjdXN0b20gYmFzZSBzdHlsaW5nIGluc3RlYWQuXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgaGlkZXMgdGhlIGRyYWdnYWJsZSBlbGVtZW50LlxuICAgICAqIEJ5IGRlZmF1bHQgaXQncyBzZXQgdG8gZmFsc2UuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZHJhZ1RvbGVyYW5jZV09XCIxMDBcIiBbaGlkZUJhc2VPbkRyYWddPVwiJ3RydWUnXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIGhpZGVCYXNlT25EcmFnOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgcHJvdmlkZWQgdHJhbnNpdGlvbiBmdW5jdGlvbnMgaW4gZnV0dXJlLlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IGVuYWJsZXMvZGlzYWJsZXMgdGhlIGRyYWdnYWJsZSBlbGVtZW50IGFuaW1hdGlvblxuICAgICAqIHdoZW4gdGhlIGVsZW1lbnQgaXMgcmVsZWFzZWQuXG4gICAgICogQnkgZGVmYXVsdCBpdCdzIHNldCB0byBmYWxzZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFthbmltYXRlT25SZWxlYXNlXT1cIid0cnVlJ1wiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBhbmltYXRlT25SZWxlYXNlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNwZWNpZmllcyBhIHRlbXBsYXRlIGZvciB0aGUgZ2hvc3QgZWxlbWVudCBjcmVhdGVkIHdoZW4gZHJhZ2dpbmcgc3RhcnRzIGFuZCBgZ2hvc3RgIGlzIHRydWUuXG4gICAgICogQnkgZGVmYXVsdCBhIGNsb25lIG9mIHRoZSBiYXNlIGVsZW1lbnQgdGhlIGlneERyYWcgaXMgaW5zdGFuY2VkIGlzIGNyZWF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZ2hvc3RUZW1wbGF0ZV09XCJjdXN0b21HaG9zdFwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogPG5nLXRlbXBsYXRlICNjdXN0b21HaG9zdD5cbiAgICAgKiAgICAgIDxkaXYgY2xhc3M9XCJjdXN0b21HaG9zdFN0eWxlXCI+XG4gICAgICogICAgICAgICAgPHNwYW4+SSBhbSBiZWluZyBkcmFnZ2VkITwvc3Bhbj5cbiAgICAgKiAgICAgIDwvZGl2PlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBnaG9zdFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGRyYWdnZWQgZWxlbWVudCB3aWxsIGJlIGFwcGVuZGVkLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQncyBzZXQgdG8gbnVsbCBhbmQgdGhlIGRyYWdnZWQgZWxlbWVudCBpcyBhcHBlbmRlZCB0byB0aGUgYm9keS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiAjaG9zdERpdj48L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyYWcgW2dob3N0SG9zdF09XCJob3N0RGl2XCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIGdob3N0SG9zdDogYW55O1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNwZWNpZmllcyB0aGUgb2Zmc2V0IG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIG1vdXNlIGluIHBpeGVscy5cbiAgICAgKiBCeSBkZWZhdWx0IGl0J3MgdGFraW5nIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiB0byB0aGUgbW91c2Ugd2hlbiB0aGUgZHJhZyBzdGFydGVkIGFuZCBrZWVwcyBpdCB0aGUgc2FtZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiAjaG9zdERpdj48L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyYWcgW2dob3N0T2Zmc2V0WF09XCIwXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIHNldCBnaG9zdE9mZnNldFgodmFsdWU6IGFueSk7XG4gICAgZ2V0IGdob3N0T2Zmc2V0WCgpOiBhbnk7XG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc3BlY2lmaWVzIHRoZSBvZmZzZXQgb2YgdGhlIGRyYWdnZWQgZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgbW91c2UgaW4gcGl4ZWxzLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQncyB0YWtpbmcgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIHRvIHRoZSBtb3VzZSB3aGVuIHRoZSBkcmFnIHN0YXJ0ZWQgYW5kIGtlZXBzIGl0IHRoZSBzYW1lLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2ICNob3N0RGl2PjwvZGl2PlxuICAgICAqIDxkaXYgaWd4RHJhZyBbZ2hvc3RPZmZzZXRZXT1cIjBcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgc2V0IGdob3N0T2Zmc2V0WSh2YWx1ZTogYW55KTtcbiAgICBnZXQgZ2hvc3RPZmZzZXRZKCk6IGFueTtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgZHJhZyBzdGFydHMuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyAoZHJhZ1N0YXJ0KT1cIm9uRHJhZ1N0YXJ0KClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25EcmFnU3RhcnQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGRyYWcgaGFzIHN0YXJlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgZHJhZ1N0YXJ0OiBFdmVudEVtaXR0ZXI8SURyYWdTdGFydEV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gdGhlIGRyYWdnYWJsZSBlbGVtZW50IGhhcyBiZWVuIG1vdmVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgIChkcmFnTW92ZSk9XCJvbkRyYWdNb3ZlKClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25EcmFnTW92ZSgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZWxlbWVudCBoYXMgbW92ZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIGRyYWdNb3ZlOiBFdmVudEVtaXR0ZXI8SURyYWdNb3ZlRXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgcmVsZWFzZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyAoZHJhZ0VuZCk9XCJvbkRyYWdFbmQoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBvbkRyYWdFbmQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGRyYWcgaGFzIGVuZGVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBkcmFnRW5kOiBFdmVudEVtaXR0ZXI8SURyYWdCYXNlRXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIChkcmFnQ2xpY2spPVwib25EcmFnQ2xpY2soKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBvbkRyYWdDbGljaygpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZWxlbWVudCBoYXMgYmVlbiBjbGlja2VkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBkcmFnQ2xpY2s6IEV2ZW50RW1pdHRlcjxJRHJhZ0Jhc2VFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnIGdob3N0IGVsZW1lbnQgaXMgY3JlYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIChnaG9zdENyZWF0ZSk9XCJnaG9zdENyZWF0ZWQoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBnaG9zdENyZWF0ZWQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGdob3N0IGhhcyBiZWVuIGNyZWF0ZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIGdob3N0Q3JlYXRlOiBFdmVudEVtaXR0ZXI8SURyYWdHaG9zdEJhc2VFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnIGdob3N0IGVsZW1lbnQgaXMgY3JlYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIChnaG9zdERlc3Ryb3kpPVwiZ2hvc3REZXN0cm95ZWQoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBnaG9zdERlc3Ryb3llZCgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZ2hvc3QgaGFzIGJlZW4gZGVzdHJveWVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBnaG9zdERlc3Ryb3k6IEV2ZW50RW1pdHRlcjxJRHJhZ0dob3N0QmFzZUV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIGFmdGVyIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBpcyByZWxlYXNlZCBhbmQgYWZ0ZXIgaXRzIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyAodHJhbnNpdGlvbmVkKT1cIm9uTW92ZUVuZCgpXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIG9uTW92ZUVuZCgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgbW92ZSBoYXMgZW5kZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIHRyYW5zaXRpb25lZDogRXZlbnRFbWl0dGVyPElEcmFnQmFzZUV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGRyYWdIYW5kbGVzOiBRdWVyeUxpc3Q8SWd4RHJhZ0hhbmRsZURpcmVjdGl2ZT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIF92aXNpYmlsaXR5OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGJhc2VDbGFzczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2VsZWN0RGlzYWJsZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBuYXRpdmUgYW5ndWxhciB3YXlzIG9mIGhpZGluZyBpdCB1c2luZyBjdXN0b20gdG8gdGhlIGJhc2UgZWxlbWVudCBzdHlsaW5nIGZvciBmdXR1cmUgdmVyc2lvbnMuXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJteURyYWdcIiAse3JlYWQ6IElneERyYWdEaXJlY3RpdmV9KVxuICAgICAqIHB1YmxpYyBteURyYWc6IElneERyYWdEaXJlY3RpdmU7XG4gICAgICogbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgIHRoaXMubXlEcmFnLnZpc2libGUgPSBmYWxzZTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2V0IHZpc2libGUoYlZpc2libGU6IGJvb2xlYW4pO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZpc2liaWxpdHkgc3RhdGUgb2YgdGhlIGRyYWdnYWJsZSBlbGVtZW50LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwibXlEcmFnXCIgLHtyZWFkOiBJZ3hEcmFnRGlyZWN0aXZlfSlcbiAgICAgKiBwdWJsaWMgbXlEcmFnOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgICAqIG5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgICBsZXQgZHJhZ1Zpc2liaWxpdHkgPSB0aGlzLm15RHJhZy52aXNpYmxlO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgdmlzaWJsZSgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgbG9jYXRpb24gb2YgdGhlIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIHBhZ2UuXG4gICAgICovXG4gICAgZ2V0IGxvY2F0aW9uKCk6IElneERyYWdMb2NhdGlvbjtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBvZiB0aGUgZWxlbWVudCBiZWZvcmUgZHJhZ2dpbmcgc3RhcnRlZC5cbiAgICAgKi9cbiAgICBnZXQgb3JpZ2luTG9jYXRpb24oKTogSWd4RHJhZ0xvY2F0aW9uO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgcG9pbnRlckV2ZW50c0VuYWJsZWQoKTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHRvdWNoRXZlbnRzRW5hYmxlZCgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgcGFnZVgoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgcGFnZVkoKTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBnZXQgYmFzZUxlZnQoKTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBnZXQgYmFzZVRvcCgpOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIGdldCBiYXNlT3JpZ2luTGVmdCgpOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIGdldCBiYXNlT3JpZ2luVG9wKCk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgc2V0IGdob3N0TGVmdChwYWdlWDogbnVtYmVyKTtcbiAgICBwcm90ZWN0ZWQgZ2V0IGdob3N0TGVmdCgpOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIHNldCBnaG9zdFRvcChwYWdlWTogbnVtYmVyKTtcbiAgICBwcm90ZWN0ZWQgZ2V0IGdob3N0VG9wKCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZGVmYXVsdFJldHVybkR1cmF0aW9uOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdob3N0RWxlbWVudDogYW55O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBhbmltSW5Qcm9ncmVzczogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgX3N0YXJ0WDogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBfc3RhcnRZOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIF9sYXN0WDogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBfbGFzdFk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgX2RyYWdTdGFydGVkOiBib29sZWFuO1xuICAgIC8qKiBEcmFnIGdob3N0IHJlbGF0ZWQgcHJvcGVydGllcyAqL1xuICAgIHByb3RlY3RlZCBfZGVmYXVsdE9mZnNldFg6IGFueTtcbiAgICBwcm90ZWN0ZWQgX2RlZmF1bHRPZmZzZXRZOiBhbnk7XG4gICAgcHJvdGVjdGVkIF9vZmZzZXRYOiBhbnk7XG4gICAgcHJvdGVjdGVkIF9vZmZzZXRZOiBhbnk7XG4gICAgcHJvdGVjdGVkIF9naG9zdFN0YXJ0WDogYW55O1xuICAgIHByb3RlY3RlZCBfZ2hvc3RTdGFydFk6IGFueTtcbiAgICBwcm90ZWN0ZWQgX2dob3N0SG9zdFg6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgX2dob3N0SG9zdFk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgX3BvaW50ZXJEb3duSWQ6IGFueTtcbiAgICBwcm90ZWN0ZWQgX2NsaWNrZWQ6IGJvb2xlYW47XG4gICAgcHJvdGVjdGVkIF9sYXN0RHJvcEFyZWE6IGFueTtcbiAgICBwcm90ZWN0ZWQgX2Rlc3Ryb3k6IFN1YmplY3Q8Ym9vbGVhbj47XG4gICAgcHJvdGVjdGVkIF9yZW1vdmVPbkRlc3Ryb3k6IGJvb2xlYW47XG4gICAgY29uc3RydWN0b3IoY2RyOiBDaGFuZ2VEZXRlY3RvclJlZiwgZWxlbWVudDogRWxlbWVudFJlZiwgdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZiwgem9uZTogTmdab25lLCByZW5kZXJlcjogUmVuZGVyZXIyKTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogU2V0cyBkZXNpcmVkIGxvY2F0aW9uIG9mIHRoZSBiYXNlIGVsZW1lbnQgb3IgZ2hvc3QgZWxlbWVudCBpZiByZW5kZWQgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSBuZXdMb2NhdGlvbiBOZXcgbG9jYXRpb24gdGhhdCBzaG91bGQgYmUgYXBwbGllZC4gSXQgaXMgYWR2aXNlZCB0byBnZXQgbmV3IGxvY2F0aW9uIHVzaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdHMoKSArIHNjcm9sbC5cbiAgICAgKi9cbiAgICBzZXRMb2NhdGlvbihuZXdMb2NhdGlvbjogSWd4RHJhZ0xvY2F0aW9uKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBBbmltYXRlcyB0aGUgYmFzZSBvciBnaG9zdCBlbGVtZW50IGRlcGVuZGluZyBvbiB0aGUgYGdob3N0YCBpbnB1dCB0byBpdHMgaW5pdGlhbCBsb2NhdGlvbi5cbiAgICAgKiBJZiBgZ2hvc3RgIGlzIHRydWUgYnV0IHRoZXJlIGlzIG5vdCBnaG9zdCByZW5kZXJlZCwgaXQgd2lsbCBiZSBjcmVhdGVkIGFuZCBhbmltYXRlZC5cbiAgICAgKiBJZiB0aGUgYmFzZSBlbGVtZW50IGhhcyBjaGFuZ2VkIGl0cyBET00gcG9zaXRpb24gaXRzIGluaXRpYWwgbG9jYXRpb24gd2lsbCBiZSBjaGFuZ2VkIGFjY29yZGluZ2x5LlxuICAgICAqIEBwYXJhbSBjdXN0b21BbmltQXJncyBDdXN0b20gdHJhbnNpdGlvbiBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHdoZW4gcGVyZm9ybWluZyB0aGUgdHJhbnNpdGlvbi5cbiAgICAgKiBAcGFyYW0gc3RhcnRMb2NhdGlvbiBTdGFydCBsb2NhdGlvbiBmcm9tIHdoZXJlIHRoZSB0cmFuc2l0aW9uIHNob3VsZCBzdGFydC5cbiAgICAgKi9cbiAgICB0cmFuc2l0aW9uVG9PcmlnaW4oY3VzdG9tQW5pbUFyZ3M/OiBJRHJhZ0N1c3RvbVRyYW5zaXRpb25BcmdzLCBzdGFydExvY2F0aW9uPzogSWd4RHJhZ0xvY2F0aW9uKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBBbmltYXRlcyB0aGUgYmFzZSBvciBnaG9zdCBlbGVtZW50IHRvIGEgc3BlY2lmaWMgdGFyZ2V0IGxvY2F0aW9uIG9yIG90aGVyIGVsZW1lbnQgdXNpbmcgdHJhbnNpdGlvbi5cbiAgICAgKiBJZiBgZ2hvc3RgIGlzIHRydWUgYnV0IHRoZXJlIGlzIG5vdCBnaG9zdCByZW5kZXJlZCwgaXQgd2lsbCBiZSBjcmVhdGVkIGFuZCBhbmltYXRlZC5cbiAgICAgKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgJ2dldEJvdW5kaW5nQ2xpZW50UmVjdHMoKSArIHBhZ2VTY3JvbGwnIHdoZW4gZGV0ZXJtaW5pbmcgZGVzaXJlZCBsb2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRhcmdldCB0aGF0IHRoZSBiYXNlIG9yIGdob3N0IHdpbGwgdHJhbnNpdGlvbiB0by4gSXQgY2FuIGJlIGVpdGhlciBsb2NhdGlvbiBpbiB0aGUgcGFnZSBvciBhbm90aGVyIEhUTUwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gY3VzdG9tQW5pbUFyZ3MgQ3VzdG9tIHRyYW5zaXRpb24gcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgYXBwbGllZCB3aGVuIHBlcmZvcm1pbmcgdGhlIHRyYW5zaXRpb24uXG4gICAgICogQHBhcmFtIHN0YXJ0TG9jYXRpb24gU3RhcnQgbG9jYXRpb24gZnJvbSB3aGVyZSB0aGUgdHJhbnNpdGlvbiBzaG91bGQgc3RhcnQuXG4gICAgICovXG4gICAgdHJhbnNpdGlvblRvKHRhcmdldDogSWd4RHJhZ0xvY2F0aW9uIHwgRWxlbWVudFJlZiwgY3VzdG9tQW5pbUFyZ3M/OiBJRHJhZ0N1c3RvbVRyYW5zaXRpb25BcmdzLCBzdGFydExvY2F0aW9uPzogSWd4RHJhZ0xvY2F0aW9uKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogTWV0aG9kIGJvdW5kIHRvIHRoZSBQb2ludGVyRG93biBldmVudCBvZiB0aGUgYmFzZSBlbGVtZW50IGlneERyYWcgaXMgaW5pdGlhbGl6ZWQuXG4gICAgICogQHBhcmFtIGV2ZW50IFBvaW50ZXJEb3duIGV2ZW50IGNhcHR1cmVkXG4gICAgICovXG4gICAgb25Qb2ludGVyRG93bihldmVudDogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogUGVyZm9ybSBkcmFnIG1vdmUgbG9naWMgd2hlbiBkcmFnZ2luZyBhbmQgZGlzcGF0Y2hpbmcgZXZlbnRzIGlmIHRoZXJlIGlzIGlneERyb3AgdW5kZXIgdGhlIHBvaW50ZXIuXG4gICAgICogVGhpcyBtZXRob2QgaXMgYm91bmQgYXQgZmlyc3QgYXQgdGhlIGJhc2UgZWxlbWVudC5cbiAgICAgKiBJZiBkcmFnZ2luZyBzdGFydHMgYW5kIGFmdGVyIHRoZSBnaG9zdEVsZW1lbnQgaXMgcmVuZGVyZWQgdGhlIHBvaW50ZXJJZCBpcyByZWFzc2lnbmVkIGl0LiBUaGVuIHRoaXMgbWV0aG9kIGlzIGJvdW5kIHRvIGl0LlxuICAgICAqIEBwYXJhbSBldmVudCBQb2ludGVyTW92ZSBldmVudCBjYXB0dXJlZFxuICAgICAqL1xuICAgIG9uUG9pbnRlck1vdmUoZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFBlcmZvcm0gZHJhZyBlbmQgbG9naWMgd2hlbiByZWxlYXNpbmcgdGhlIGdob3N0RWxlbWVudCBhbmQgZGlzcGF0Y2hpbmcgZHJvcCBldmVudCBpZiBpZ3hEcm9wIGlzIHVuZGVyIHRoZSBwb2ludGVyLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGJvdW5kIGF0IGZpcnN0IGF0IHRoZSBiYXNlIGVsZW1lbnQuXG4gICAgICogSWYgZHJhZ2dpbmcgc3RhcnRzIGFuZCBhZnRlciB0aGUgZ2hvc3RFbGVtZW50IGlzIHJlbmRlcmVkIHRoZSBwb2ludGVySWQgaXMgcmVhc3NpZ25lZCB0byBpdC4gVGhlbiB0aGlzIG1ldGhvZCBpcyBib3VuZCB0byBpdC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgUG9pbnRlclVwIGV2ZW50IGNhcHR1cmVkXG4gICAgICovXG4gICAgb25Qb2ludGVyVXAoZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEV4ZWN1dGUgdGhpcyBtZXRob2Qgd2hlIHRoZSBwb2ludGVyIGNhcHR1cmUgaGFzIGJlZW4gbG9zdC5cbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgZHVyaW5nIGRyYWdnaW5nIHRoZSB1c2VyIGhhcyBwZXJmb3JtZWQgb3RoZXIgYWN0aW9uIGxpa2UgcmlnaHQgY2xpY2tpbmcgYW5kIHRoZW4gY2xpY2tpbmcgc29tZXdoZXJlIGVsc2UuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBlbnN1cmUgdGhhdCB0aGUgZHJhZyBzdGF0ZSBpcyBiZWluZyByZXNldCBpbiB0aGlzIGNhc2UgYXMgaWYgdGhlIHVzZXIgcmVsZWFzZWQgdGhlIGRyYWdnZWQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgRXZlbnQgY2FwdHVyZWRcbiAgICAgKi9cbiAgICBvblBvaW50ZXJMb3N0KGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBDcmVhdGUgZ2hvc3QgZWxlbWVudCAtIGlmIGEgTm9kZSBvYmplY3QgaXMgcHJvdmlkZWQgaXQgY3JlYXRlcyBhIGNsb25lIG9mIHRoYXQgbm9kZSxcbiAgICAgKiBvdGhlcndpc2UgaXQgY2xvbmVzIHRoZSBob3N0IGVsZW1lbnQuXG4gICAgICogQmluZCBhbGwgbmVlZGVkIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0gcGFnZVggTGF0ZXN0IHBvaW50ZXIgcG9zaXRpb24gb24gdGhlIFggYXhpcyByZWxhdGl2ZSB0byB0aGUgcGFnZS5cbiAgICAgKiBAcGFyYW0gcGFnZVkgTGF0ZXN0IHBvaW50ZXIgcG9zaXRpb24gb24gdGhlIFkgYXhpcyByZWxhdGl2ZSB0byB0aGUgcGFnZS5cbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgTm9kZSBvYmplY3QgdG8gYmUgY2xvbmVkLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjcmVhdGVHaG9zdChwYWdlWDogYW55LCBwYWdlWTogYW55LCBub2RlPzogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRGlzcGF0Y2ggY3VzdG9tIGlneERyYWdFbnRlci9pZ3hEcmFnTGVhdmUgZXZlbnRzIGJhc2VkIG9uIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbiBhbmQgaWYgZHJvcCBhcmVhIGlzIHVuZGVyLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkaXNwYXRjaERyYWdFdmVudHMocGFnZVg6IG51bWJlciwgcGFnZVk6IG51bWJlciwgb3JpZ2luYWxFdmVudDogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRGlzcGF0Y2ggY3VzdG9tIGlneERyb3AgZXZlbnQgYmFzZWQgb24gY3VycmVudCBwb2ludGVyIHBvc2l0aW9uIGlmIHRoZXJlIGlzIGxhc3QgcmVjb3JkZXIgZHJvcCBhcmVhIHVuZGVyIHRoZSBwb2ludGVyLlxuICAgICAqIExhc3QgcmVjb3JkZXIgZHJvcCBhcmVhIGlzIHVwZGF0ZWQgaW4gQGRpc3BhdGNoRHJhZ0V2ZW50cyBtZXRob2QuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRpc3BhdGNoRHJvcEV2ZW50KHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIsIG9yaWdpbmFsRXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uVHJhbnNpdGlvbkVuZChldmVudDogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldEVsZW1lbnRzQXRQb2ludChwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyKTogYW55O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZGlzcGF0Y2hFdmVudCh0YXJnZXQ6IGFueSwgZXZlbnROYW1lOiBzdHJpbmcsIGV2ZW50QXJnczogSWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscyk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIGdldFRyYW5zZm9ybVgoZWxlbTogYW55KTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBnZXRUcmFuc2Zvcm1ZKGVsZW06IGFueSk6IG51bWJlcjtcbiAgICAvKiogTWV0aG9kIHNldHRpbmcgdHJhbnNmb3JtYXRpb24gdG8gdGhlIGJhc2UgZHJhZ2dhYmxlIGVsZW1lbnQuICovXG4gICAgcHJvdGVjdGVkIHNldFRyYW5zZm9ybVhZKHg6IG51bWJlciwgeTogbnVtYmVyKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgZ2V0V2luZG93U2Nyb2xsVG9wKCk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgZ2V0V2luZG93U2Nyb2xsTGVmdCgpOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIGdob3N0SG9zdE9mZnNldExlZnQoZ2hvc3RIb3N0OiBhbnkpOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIGdob3N0SG9zdE9mZnNldFRvcChnaG9zdEhvc3Q6IGFueSk6IG51bWJlcjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneERyb3BEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgZWxlbWVudDogRWxlbWVudFJlZjtcbiAgICBwcml2YXRlIF9yZW5kZXJlcjtcbiAgICBwcml2YXRlIF96b25lO1xuICAgIC8qKlxuICAgICAqIC0gU2F2ZSBkYXRhIGluc2lkZSB0aGUgYGlneERyb3BgIGRpcmVjdGl2ZS4gVGhpcyBjYW4gYmUgc2V0IHdoZW4gaW5zdGFuY2luZyBgaWd4RHJvcGAgb24gYW4gZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBbaWd4RHJvcF09XCJ7IHNvdXJjZTogbXlFbGVtZW50IH1cIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJvcERpcmVjdGl2ZVxuICAgICAqL1xuICAgIGRhdGE6IGFueTtcbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBwcm92aWRlIGEgd2F5IGZvciBpZ3hEcmFnIGFuZCBpZ3hEcm9wIHRvIGJlIGxpbmtlZCB0aHJvdWdoIGNoYW5uZWxzLlxuICAgICAqIEl0IGFjY2VwdHMgc2luZ2xlIHZhbHVlIG9yIGFuIGFycmF5IG9mIHZhbHVlcyBhbmQgZXZhbHVhdGVzIHRoZW4gdXNpbmcgc3RyaWN0IGVxdWFsaXR5LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2RyYWdDaGFubmVsXT1cIidvZGQnXCI+XG4gICAgICogICAgICAgICA8c3Bhbj45NTwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyb3AgW2Ryb3BDaGFubmVsXT1cIlsnb2RkJywgJ2lycmF0aW9uYWwnXVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+TnVtYmVycyBkcm9wIGFyZWEhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcm9wRGlyZWN0aXZlXG4gICAgICovXG4gICAgZHJvcENoYW5uZWw6IG51bWJlciB8IHN0cmluZyB8IG51bWJlcltdIHwgc3RyaW5nW107XG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc3BlY2lmaWVzIGEgZHJvcCBzdHJhdGVneSB0eXBlIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIGFuIGBJZ3hEcmFnYCBlbGVtZW50IGlzIHJlbGVhc2VkIGluc2lkZVxuICAgICAqICB0aGUgY3VycmVudCBkcm9wIGFyZWEuIFRoZSBwcm92aWRlZCBzdHJhdGVnaWVzIGFyZTpcbiAgICAgKiAgLSBJZ3hEZWZhdWx0RHJvcFN0cmF0ZWd5IC0gVGhpcyBpcyB0aGUgZGVmYXVsdCBiYXNlIHN0cmF0ZWd5IGFuZCBpdCBkb2Vzbid0IHBlcmZvcm0gYW55IGFjdGlvbnMuXG4gICAgICogIC0gSWd4QXBwZW5kRHJvcFN0cmF0ZWd5IC0gQXBwZW5kcyB0aGUgZHJvcHBlZCBlbGVtZW50IHRvIGxhc3QgcG9zaXRpb24gYXMgYSBkaXJlY3QgY2hpbGQgdG8gdGhlIGBpZ3hEcm9wYC5cbiAgICAgKiAgLSBJZ3hQcmVwZW5kRHJvcFN0cmF0ZWd5IC0gUHJlcGVuZHMgdGhlIGRyb3BwZWQgZWxlbWVudCB0byBmaXJzdCBwb3NpdGlvbiBhcyBhIGRpcmVjdCBjaGlsZCB0byB0aGUgYGlneERyb3BgLlxuICAgICAqICAtIElneEluc2VydERyb3BTdHJhdGVneSAtIElmIHRoZSBkcm9wcGVkIGVsZW1lbnQgaXMgcmVsZWFzZWQgYWJvdmUgYSBjaGlsZCBlbGVtZW50IG9mIHRoZSBgaWd4RHJvcGAsIGl0IHdpbGwgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgICAgIGF0IHRoYXQgcG9zaXRpb24uIE90aGVyd2lzZSB0aGUgZHJvcHBlZCBlbGVtZW50IHdpbGwgYmUgYXBwZW5kZWQgaWYgcmVsZWFzZWQgb3V0c2lkZSBhbnkgY2hpbGQgb2YgdGhlIGBpZ3hEcm9wYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnPlxuICAgICAqICAgICAgPHNwYW4+RHJhZ01lPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIDxkaXYgaWd4RHJvcCBbZHJvcFN0cmF0ZWd5XT1cIm15RHJvcFN0cmF0ZWd5XCI+XG4gICAgICogICAgICAgICA8c3Bhbj5OdW1iZXJzIGRyb3AgYXJlYSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGltcG9ydCB7IElneEFwcGVuZERyb3BTdHJhdGVneSB9IGZyb20gJ2lnbml0ZXVpLWFuZ3VsYXInO1xuICAgICAqXG4gICAgICogZXhwb3J0IGNsYXNzIEFwcCB7XG4gICAgICogICAgICBwdWJsaWMgbXlEcm9wU3RyYXRlZ3kgPSBJZ3hBcHBlbmREcm9wU3RyYXRlZ3k7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcm9wRGlyZWN0aXZlXG4gICAgICovXG4gICAgc2V0IGRyb3BTdHJhdGVneShjbGFzc1JlZjogYW55KTtcbiAgICBnZXQgZHJvcFN0cmF0ZWd5KCk6IGFueTtcbiAgICAvKiogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGVudGVycyB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAoZW50ZXIpPVwiZHJhZ0VudGVyKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0VudGVyKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgZW50ZXJlZCB0aGUgY2hpcCBhcmVhIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBlbnRlcjogRXZlbnRFbWl0dGVyPElEcm9wQmFzZUV2ZW50QXJncz47XG4gICAgLyoqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIGRyYWdnZWQgZWxlbWVudCBlbnRlcnMgdGhlIGFyZWEgb2YgdGhlIGVsZW1lbnQuXG4gKiBgYGBodG1sXG4gKiA8ZGl2IGNsYXNzPVwiY2FnZUFyZWFcIiBpZ3hEcm9wIChlbnRlcik9XCJkcmFnRW50ZXIoKVwiIChpZ3hEcmFnRW50ZXIpPVwib25EcmFnQ2FnZUVudGVyKClcIiAoaWd4RHJhZ0xlYXZlKT1cIm9uRHJhZ0NhZ2VMZWF2ZSgpXCI+XG4gKiA8L2Rpdj5cbiAqIGBgYFxuICogYGBgdHlwZXNjcmlwdFxuICogcHVibGljIGRyYWdFbnRlcigpe1xuICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgZW50ZXJlZCB0aGUgY2hpcCBhcmVhIVwiKTtcbiAqIH1cbiAqIGBgYFxuICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAqL1xuICAgIG92ZXI6IEV2ZW50RW1pdHRlcjxJRHJvcEJhc2VFdmVudEFyZ3M+O1xuICAgIC8qKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiBkcmFnZ2VkIGVsZW1lbnQgbGVhdmVzIHRoZSBhcmVhIG9mIHRoZSBlbGVtZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGNsYXNzPVwiY2FnZUFyZWFcIiBpZ3hEcm9wIChsZWF2ZSk9XCJkcmFnTGVhdmUoKVwiIChpZ3hEcmFnRW50ZXIpPVwib25EcmFnQ2FnZUVudGVyKClcIiAoaWd4RHJhZ0xlYXZlKT1cIm9uRHJhZ0NhZ2VMZWF2ZSgpXCI+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBkcmFnTGVhdmUoKXtcbiAgICAgKiAgICAgYWxlcnQoXCJBIGRyYWdnYWJsZSBlbGVtZW50IGhhcyBsZWZ0IHRoZSBjaGlwIGFyZWEhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJvcERpcmVjdGl2ZVxuICAgICAqL1xuICAgIGxlYXZlOiBFdmVudEVtaXR0ZXI8SURyb3BCYXNlRXZlbnRBcmdzPjtcbiAgICAvKiogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGlzIGRyb3BwZWQgaW4gdGhlIGFyZWEgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogU2luY2UgdGhlIGBpZ3hEcm9wYCBoYXMgZGVmYXVsdCBsb2dpYyB0aGF0IGFwcGVuZHMgdGhlIGRyb3BwZWQgZWxlbWVudCBhcyBhIGNoaWxkLCBpdCBjYW4gYmUgY2FuY2VsZWQgaGVyZS5cbiAgICAgKiBUbyBjYW5jZWwgdGhlIGRlZmF1bHQgbG9naWMgdGhlIGBjYW5jZWxgIHByb3BlcnR5IG9mIHRoZSBldmVudCBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAoZHJvcHBlZCk9XCJkcmFnRHJvcCgpXCIgKGlneERyYWdFbnRlcik9XCJvbkRyYWdDYWdlRW50ZXIoKVwiIChpZ3hEcmFnTGVhdmUpPVwib25EcmFnQ2FnZUxlYXZlKClcIj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGRyYWdEcm9wKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgYmVlbiBkcm9wcGVkIGluIHRoZSBjaGlwIGFyZWEhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJvcERpcmVjdGl2ZVxuICAgICAqL1xuICAgIGRyb3BwZWQ6IEV2ZW50RW1pdHRlcjxJRHJvcERyb3BwZWRFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBkcm9wcGFibGU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGRyYWdvdmVyOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2Rlc3Ryb3k6IFN1YmplY3Q8Ym9vbGVhbj47XG4gICAgcHJvdGVjdGVkIF9kcm9wU3RyYXRlZ3k6IElEcm9wU3RyYXRlZ3k7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudFJlZiwgX3JlbmRlcmVyOiBSZW5kZXJlcjIsIF96b25lOiBOZ1pvbmUpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkRyYWdPdmVyKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkRyYWdFbnRlcihldmVudDogQ3VzdG9tRXZlbnQ8SWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscz4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkRyYWdMZWF2ZShldmVudDogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25EcmFnRHJvcChldmVudDogYW55KTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgZ2V0V2luZG93U2Nyb2xsVG9wKCk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgZ2V0V2luZG93U2Nyb2xsTGVmdCgpOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIGlzRHJhZ0xpbmtlZChkcmFnOiBJZ3hEcmFnRGlyZWN0aXZlKTogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgZ2V0SW5zZXJ0SW5kZXhBdChkcmFnZ2VkRGlyOiBJZ3hEcmFnRGlyZWN0aXZlLCBlbGVtZW50c0F0UG9pbnQ6IGFueVtdKTogbnVtYmVyO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneERyYWdEcm9wTW9kdWxlIHtcbn1cbiJdfQ==