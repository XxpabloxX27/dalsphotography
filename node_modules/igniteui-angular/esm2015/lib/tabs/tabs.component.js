var IgxTabsComponent_1;
import { __decorate } from "tslib";
import { CommonModule } from '@angular/common';
import { AfterViewInit, Component, ContentChildren, ElementRef, EventEmitter, forwardRef, HostBinding, Input, NgModule, Output, QueryList, ViewChild, ViewChildren, OnDestroy, NgZone } from '@angular/core';
import { IgxBadgeModule } from '../badge/badge.component';
import { IgxRippleModule } from '../directives/ripple/ripple.directive';
import { IgxIconModule } from '../icon/index';
import { IgxTabItemComponent } from './tab-item.component';
import { IgxTabsGroupComponent } from './tabs-group.component';
import { IgxLeftButtonStyleDirective, IgxRightButtonStyleDirective, IgxTabItemTemplateDirective } from './tabs.directives';
import { IgxTabsBase } from './tabs.common';
import ResizeObserver from 'resize-observer-polyfill';
import { PlatformUtil } from '../core/utils';
export var IgxTabsType;
(function (IgxTabsType) {
    IgxTabsType["FIXED"] = "fixed";
    IgxTabsType["CONTENTFIT"] = "contentfit";
})(IgxTabsType || (IgxTabsType = {}));
let IgxTabsComponent = IgxTabsComponent_1 = class IgxTabsComponent {
    constructor(_element, _ngZone, platformUtil) {
        this._element = _element;
        this._ngZone = _ngZone;
        this.platformUtil = platformUtil;
        /**
         *@hidden
         */
        this.selectedIndexChange = new EventEmitter();
        /**
         * Defines the tab header sizing mode. You can choose between `contentfit` or `fixed`.
         * By default the header sizing mode is `contentfit`.
         * ```html
         * <igx-tabs type="fixed">
         *     <igx-tabs-group label="HOME">Home</igx-tabs-group>
         * </igx-tabs>
         * ```
         */
        this.type = 'contentfit';
        /**
        * @hidden
        */
        this.class = '';
        /**
         * Emitted when a tab item is deselected.
         * ```html
         * <igx-tabs (onTabItemDeselected)="itemDeselected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemDeselected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.onTabItemDeselected = new EventEmitter();
        /**
        * Emitted when a tab item is selected.
        * ```html
        * <igx-tabs (onTabItemSelected)="itemSelected($event)">
        *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
        *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
        * </igx-tabs>
        * ```
        * ```typescript
        * itemSelected(e){
        *      const tabGroup = e.group;
        *      const tabItem = e.tab;
        * }
        * ```
        */
        this.onTabItemSelected = new EventEmitter();
        /**
         * @hidden
         */
        this.offset = 0;
        this._selectedIndex = -1;
    }
    /**
    * An @Input property that sets the value of the `selectedIndex`.
    * Default value is 0.
    * ```html
    * <igx-tabs selectedIndex="1">
    * ```
    *
    * Two-way data binding.
    * ```html
    * <igx-tabs [(selectedIndex)]="model.selectedIndex">
    * ```
    */
    get selectedIndex() {
        return this._selectedIndex;
    }
    set selectedIndex(index) {
        const newIndex = typeof index !== 'number' ? parseInt(index, 10) : index;
        if (this._selectedIndex !== newIndex) {
            if (this.tabs && this.tabs.length > 0) {
                const newTab = this.tabs.toArray()[newIndex];
                if (newTab) {
                    this.performSelectionChange(newTab);
                }
            }
            else {
                this._selectedIndex = newIndex;
            }
        }
    }
    /**
     * Provides an observable collection of all `IgxTabItemComponent`s.
     * First try to get them as content children if not available get them as view children.
     * ```typescript
     * const tabItems = this.myTabComponent.tabs;
     * ```
     */
    get tabs() {
        if (this.hasContentTabs) {
            return this.contentTabs;
        }
        return this.viewTabs;
    }
    /**
     *@hidden
     */
    get hasContentTabs() {
        return (this.contentTabs && this.contentTabs.length > 0);
    }
    /**
     * @hidden
     */
    get cssClass() {
        const defaultStyle = `igx-tabs`;
        const fixedStyle = `igx-tabs--fixed`;
        const iconStyle = `igx-tabs--icons`;
        const iconLabelFoundInGroups = this.groups.find((group) => group.icon != null && group.label != null);
        const iconLabelFoundInTabs = this.contentTabs.find((tab) => tab.icon != null && tab.label != null);
        let css;
        switch (IgxTabsType[this.type.toUpperCase()]) {
            case IgxTabsType.FIXED: {
                css = fixedStyle;
                break;
            }
            default: {
                css = defaultStyle;
                break;
            }
        }
        // Layout fix for items with icons
        if (iconLabelFoundInGroups !== undefined || iconLabelFoundInTabs !== undefined) {
            css = `${css} ${iconStyle}`;
        }
        return `${css} ${this.class}`;
    }
    /**
     * @hidden
     */
    scrollLeft(event) {
        this.scroll(false);
    }
    /**
     * @hidden
     */
    scrollRight(event) {
        this.scroll(true);
    }
    /**
     * @hidden
     */
    scrollElement(element, scrollRight) {
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        this.offset = (scrollRight) ? element.offsetWidth + element.offsetLeft - viewPortWidth : element.offsetLeft;
        this.itemsContainer.nativeElement.style.transform = `translate(${-this.offset}px)`;
    }
    /**
     * Gets the selected `IgxTabItemComponent`.
     * ```
     * const selectedItem = this.myTabComponent.selectedTabItem;
     * ```
     */
    get selectedTabItem() {
        if (this.tabs && this.selectedIndex !== undefined) {
            return this.tabs.toArray()[this.selectedIndex];
        }
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        if (this._selectedIndex === -1) {
            this.tabs.forEach((t) => {
                if (t.isSelected) {
                    this._selectedIndex = t.index;
                }
            });
        }
        if (!this.hasContentTabs && (this.selectedIndex < 0 || this.selectedIndex >= this.groups.length)) {
            this._selectedIndex = 0;
        }
        if (this.platformUtil.isBrowser) {
            requestAnimationFrame(() => {
                const newTab = this.tabs.toArray()[this._selectedIndex];
                if (newTab) {
                    this.performSelection(newTab);
                }
                else {
                    this.hideIndicator();
                }
            });
            this._ngZone.runOutsideAngular(() => {
                this._resizeObserver = new ResizeObserver(() => {
                    if (!this.hasContentTabs && this._selectedIndex >= 0 && this._selectedIndex < this.tabs.length) {
                        const newTab = this.tabs.toArray()[this._selectedIndex];
                        this.transformContentAnimation(newTab, 0);
                    }
                });
                this._resizeObserver.observe(this.tabsContainer.nativeElement);
            });
        }
        this._groupChanges$ = this.groups.changes.subscribe(() => {
            this.resetSelectionOnCollectionChanged();
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this._groupChanges$) {
            this._groupChanges$.unsubscribe();
        }
        if (this._resizeObserver) {
            this._ngZone.runOutsideAngular(() => {
                this._resizeObserver.disconnect();
            });
        }
    }
    resetSelectionOnCollectionChanged() {
        requestAnimationFrame(() => {
            const currentTab = this.tabs.toArray()[this.selectedIndex];
            if (currentTab) {
                this.performSelectionChange(currentTab);
            }
            else if (this.selectedIndex >= this.tabs.length) {
                this.performSelectionChange(this.tabs.last);
            }
            else {
                this.hideIndicator();
            }
        });
    }
    scroll(scrollRight) {
        const tabsArray = this.tabs.toArray();
        for (const tab of tabsArray) {
            const element = tab.nativeTabItem.nativeElement;
            if (scrollRight) {
                if (element.offsetWidth + element.offsetLeft > this.viewPort.nativeElement.offsetWidth + this.offset) {
                    this.scrollElement(element, scrollRight);
                    break;
                }
            }
            else {
                if (element.offsetWidth + element.offsetLeft >= this.offset) {
                    this.scrollElement(element, scrollRight);
                    break;
                }
            }
        }
    }
    /**
     * @hidden
     */
    performSelectionChange(newTab) {
        const oldTab = this.selectedTabItem;
        if (oldTab) {
            this.performDeselection(oldTab);
        }
        if (newTab) {
            this.performSelection(newTab);
        }
        else {
            // if there is no new selected tab hide the selection indicator
            this.hideIndicator();
        }
        this.selectedIndexChange.emit(this._selectedIndex);
    }
    performDeselection(oldTab) {
        oldTab.setSelectedInternal(false);
        const oldTabRelatedGroup = this.groups.toArray()[oldTab.index];
        if (oldTabRelatedGroup) {
            oldTabRelatedGroup.setSelectedInternal(false);
        }
        this._selectedIndex = -1;
        this.onTabItemDeselected.emit({ tab: oldTab, group: oldTabRelatedGroup });
    }
    performSelection(newTab) {
        newTab.setSelectedInternal(true);
        this._selectedIndex = newTab.index;
        let newTabRelatedGroup = null;
        if (!this.hasContentTabs && this.groups) {
            newTabRelatedGroup = this.groups.toArray()[newTab.index];
            if (newTabRelatedGroup) {
                newTabRelatedGroup.setSelectedInternal(true);
            }
        }
        this.onTabItemSelected.emit({ tab: newTab, group: newTabRelatedGroup });
        requestAnimationFrame(() => {
            // bring the new selected tab into view if it is not
            this.bringNewTabIntoView(newTab);
            // animate the new selection indicator
            this.transformIndicatorAnimation(newTab.nativeTabItem.nativeElement);
            // animate the new tab's group content
            if (!this.hasContentTabs) {
                this.transformContentAnimation(newTab, 0.2);
            }
        });
    }
    bringNewTabIntoView(newTab) {
        const tabNativeElement = newTab.nativeTabItem.nativeElement;
        // Scroll left if there is need
        if (tabNativeElement.offsetLeft < this.offset) {
            this.scrollElement(tabNativeElement, false);
        }
        // Scroll right if there is need
        const viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;
        const delta = (tabNativeElement.offsetLeft + tabNativeElement.offsetWidth) - (viewPortOffsetWidth + this.offset);
        // Fix for IE 11, a difference is accumulated from the widths calculations
        if (delta > 1) {
            this.scrollElement(tabNativeElement, true);
        }
    }
    /**
     * @hidden
     */
    // animation for the new panel/group (not needed for tab only mode)
    transformContentAnimation(tab, duration) {
        const contentOffset = this.tabsContainer.nativeElement.offsetWidth * tab.index;
        this.contentsContainer.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
        this.contentsContainer.nativeElement.style.transform = `translate(${-contentOffset}px)`;
    }
    /**
     * @hidden
     */
    transformIndicatorAnimation(element, duration = 0.3) {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'visible';
            this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
            this.selectedIndicator.nativeElement.style.width = `${element.offsetWidth}px`;
            this.selectedIndicator.nativeElement.style.transform = `translate(${element.offsetLeft}px)`;
        }
    }
    hideIndicator() {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'hidden';
        }
    }
};
IgxTabsComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: PlatformUtil }
];
__decorate([
    ContentChildren(forwardRef(() => IgxTabsGroupComponent))
], IgxTabsComponent.prototype, "groups", void 0);
__decorate([
    ContentChildren(forwardRef(() => IgxTabItemComponent))
], IgxTabsComponent.prototype, "contentTabs", void 0);
__decorate([
    Input()
], IgxTabsComponent.prototype, "selectedIndex", null);
__decorate([
    Output()
], IgxTabsComponent.prototype, "selectedIndexChange", void 0);
__decorate([
    Input('type')
], IgxTabsComponent.prototype, "type", void 0);
__decorate([
    Input()
], IgxTabsComponent.prototype, "class", void 0);
__decorate([
    Output()
], IgxTabsComponent.prototype, "onTabItemDeselected", void 0);
__decorate([
    Output()
], IgxTabsComponent.prototype, "onTabItemSelected", void 0);
__decorate([
    ViewChild('contentsContainer', { static: true })
], IgxTabsComponent.prototype, "contentsContainer", void 0);
__decorate([
    ViewChild('headerContainer', { static: true })
], IgxTabsComponent.prototype, "headerContainer", void 0);
__decorate([
    ViewChild('itemsContainer', { static: true })
], IgxTabsComponent.prototype, "itemsContainer", void 0);
__decorate([
    ViewChild('selectedIndicator')
], IgxTabsComponent.prototype, "selectedIndicator", void 0);
__decorate([
    ViewChild('tabsContainer', { static: true })
], IgxTabsComponent.prototype, "tabsContainer", void 0);
__decorate([
    ViewChild('viewPort', { static: true })
], IgxTabsComponent.prototype, "viewPort", void 0);
__decorate([
    ViewChildren(forwardRef(() => IgxTabItemComponent))
], IgxTabsComponent.prototype, "viewTabs", void 0);
__decorate([
    HostBinding('attr.class')
], IgxTabsComponent.prototype, "cssClass", null);
IgxTabsComponent = IgxTabsComponent_1 = __decorate([
    Component({
        selector: 'igx-tabs',
        template: "<!-- TODO Remove tab container from here -->\n<div #tabsContainer>\n    <div class=\"igx-tabs__header\" #headerContainer>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollLeft($event)\" igxLeftButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_before</igx-icon>\n        </button>\n        <div class=\"igx-tabs__header-wrapper-fixed\" #viewPort>\n            <div #itemsContainer class=\"igx-tabs__header-wrapper-fluid\">\n                <ng-container *ngIf=\"!hasContentTabs\">\n                    <igx-tab-item igxRipple *ngFor=\"let group of groups\" [relatedGroup]=\"group\">\n                    </igx-tab-item>\n                </ng-container>\n                <ng-content select=\"igx-tab-item\"></ng-content>\n                <div #selectedIndicator *ngIf=\"groups.length > 0 || contentTabs.length > 0\" class=\"igx-tabs__header-menu-item-indicator\"></div>\n            </div>\n        </div>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollRight($event)\" igxRightButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_next</igx-icon>\n        </button>\n    </div>\n    <div class=\"igx-tabs__content-fixed\">\n        <div #contentsContainer class=\"igx-tabs__content-fluid\">\n            <ng-content></ng-content>\n        </div>\n    </div>\n</div>",
        providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent_1 }]
    })
], IgxTabsComponent);
export { IgxTabsComponent };
/**
 * @hidden
 */
let IgxTabsModule = class IgxTabsModule {
};
IgxTabsModule = __decorate([
    NgModule({
        declarations: [IgxTabsComponent,
            IgxTabsGroupComponent,
            IgxTabItemComponent,
            IgxTabItemTemplateDirective,
            IgxRightButtonStyleDirective,
            IgxLeftButtonStyleDirective],
        exports: [IgxTabsComponent,
            IgxTabsGroupComponent,
            IgxTabItemComponent,
            IgxTabItemTemplateDirective,
            IgxRightButtonStyleDirective,
            IgxLeftButtonStyleDirective],
        imports: [CommonModule, IgxBadgeModule, IgxIconModule, IgxRippleModule]
    })
], IgxTabsModule);
export { IgxTabsModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFicy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL3RhYnMvdGFicy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUNILGFBQWEsRUFDYixTQUFTLEVBQ1QsZUFBZSxFQUNmLFVBQVUsRUFDVixZQUFZLEVBQ1osVUFBVSxFQUNWLFdBQVcsRUFDWCxLQUFLLEVBQ0wsUUFBUSxFQUNSLE1BQU0sRUFDTixTQUFTLEVBQ1QsU0FBUyxFQUNULFlBQVksRUFDWixTQUFTLEVBQ1QsTUFBTSxFQUNULE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sdUNBQXVDLENBQUM7QUFDeEUsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM5QyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMzRCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUMvRCxPQUFPLEVBQUUsMkJBQTJCLEVBQUUsNEJBQTRCLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUMzSCxPQUFPLEVBQUUsV0FBVyxFQUFrQixNQUFNLGVBQWUsQ0FBQztBQUM1RCxPQUFPLGNBQWMsTUFBTSwwQkFBMEIsQ0FBQztBQUN0RCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTdDLE1BQU0sQ0FBTixJQUFZLFdBR1g7QUFIRCxXQUFZLFdBQVc7SUFDbkIsOEJBQWUsQ0FBQTtJQUNmLHdDQUF5QixDQUFBO0FBQzdCLENBQUMsRUFIVyxXQUFXLEtBQVgsV0FBVyxRQUd0QjtBQVFELElBQWEsZ0JBQWdCLHdC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OENoRDtJQURDLFdBQVcsQ0FBQyxZQUFZLENBQUM7Z0RBeUJ6QjtBQS9OUSxnQkFBZ0I7SUFONUIsU0FBUyxDQUFDO1FBQ1AsUUFBUSxFQUFFLFVBQVU7UUFDcEIsdTNDQUFrQztRQUNsQyxTQUFTLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLGtCQUFnQixFQUFFLENBQUM7S0FDdkUsQ0FBQztHQUVXLGdCQUFnQixDQWtjNUI7U0FsY1ksZ0JBQWdCO0FBb2M3Qjs7R0FFRztBQWlCSCxJQUFhLGFBQWEsR0FBMUIsTUFBYSxhQUFhO0NBQ3pCLENBQUE7QUFEWSxhQUFhO0lBaEJ6QixRQUFRLENBQUM7UUFDTixZQUFZLEVBQUUsQ0FBQyxnQkFBZ0I7WUFDM0IscUJBQXFCO1lBQ3JCLG1CQUFtQjtZQUNuQiwyQkFBMkI7WUFDM0IsNEJBQTRCO1lBQzVCLDJCQUEyQixDQUFDO1FBQ2hDLE9BQU8sRUFBRSxDQUFDLGdCQUFnQjtZQUN0QixxQkFBcUI7WUFDckIsbUJBQW1CO1lBQ25CLDJCQUEyQjtZQUMzQiw0QkFBNEI7WUFDNUIsMkJBQTJCLENBQUM7UUFDaEMsT0FBTyxFQUFFLENBQUMsWUFBWSxFQUFFLGNBQWMsRUFBRSxhQUFhLEVBQUUsZUFBZSxDQUFDO0tBQzFFLENBQUM7R0FFVyxhQUFhLENBQ3pCO1NBRFksYUFBYSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICAgIEFmdGVyVmlld0luaXQsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZHJlbixcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIElucHV0LFxuICAgIE5nTW9kdWxlLFxuICAgIE91dHB1dCxcbiAgICBRdWVyeUxpc3QsXG4gICAgVmlld0NoaWxkLFxuICAgIFZpZXdDaGlsZHJlbixcbiAgICBPbkRlc3Ryb3ksXG4gICAgTmdab25lXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBJZ3hCYWRnZU1vZHVsZSB9IGZyb20gJy4uL2JhZGdlL2JhZGdlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hSaXBwbGVNb2R1bGUgfSBmcm9tICcuLi9kaXJlY3RpdmVzL3JpcHBsZS9yaXBwbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneEljb25Nb2R1bGUgfSBmcm9tICcuLi9pY29uL2luZGV4JztcbmltcG9ydCB7IElneFRhYkl0ZW1Db21wb25lbnQgfSBmcm9tICcuL3RhYi1pdGVtLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hUYWJzR3JvdXBDb21wb25lbnQgfSBmcm9tICcuL3RhYnMtZ3JvdXAuY29tcG9uZW50JztcbmltcG9ydCB7IElneExlZnRCdXR0b25TdHlsZURpcmVjdGl2ZSwgSWd4UmlnaHRCdXR0b25TdHlsZURpcmVjdGl2ZSwgSWd4VGFiSXRlbVRlbXBsYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi90YWJzLmRpcmVjdGl2ZXMnO1xuaW1wb3J0IHsgSWd4VGFic0Jhc2UsIElneFRhYkl0ZW1CYXNlIH0gZnJvbSAnLi90YWJzLmNvbW1vbic7XG5pbXBvcnQgUmVzaXplT2JzZXJ2ZXIgZnJvbSAncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJztcbmltcG9ydCB7IFBsYXRmb3JtVXRpbCB9IGZyb20gJy4uL2NvcmUvdXRpbHMnO1xuXG5leHBvcnQgZW51bSBJZ3hUYWJzVHlwZSB7XG4gICAgRklYRUQgPSAnZml4ZWQnLFxuICAgIENPTlRFTlRGSVQgPSAnY29udGVudGZpdCdcbn1cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtdGFicycsXG4gICAgdGVtcGxhdGVVcmw6ICd0YWJzLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IElneFRhYnNCYXNlLCB1c2VFeGlzdGluZzogSWd4VGFic0NvbXBvbmVudCB9XVxufSlcblxuZXhwb3J0IGNsYXNzIElneFRhYnNDb21wb25lbnQgaW1wbGVtZW50cyBJZ3hUYWJzQmFzZSwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgICAvKipcbiAgICAqIFByb3ZpZGVzIGFuIG9ic2VydmFibGUgY29sbGVjdGlvbiBvZiBhbGwgYElneFRhYnNHcm91cENvbXBvbmVudGBzLlxuICAgICogYGBgdHlwZXNjcmlwdFxuICAgICogY29uc3QgZ3JvdXBJdGVtcyA9IHRoaXMubXlUYWJDb21wb25lbnQuZ3JvdXBzO1xuICAgICogYGBgXG4gICAgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKGZvcndhcmRSZWYoKCkgPT4gSWd4VGFic0dyb3VwQ29tcG9uZW50KSlcbiAgICBwdWJsaWMgZ3JvdXBzOiBRdWVyeUxpc3Q8SWd4VGFic0dyb3VwQ29tcG9uZW50PjtcblxuICAgIC8qKlxuICAgICogUHJvdmlkZXMgYW4gb2JzZXJ2YWJsZSBjb2xsZWN0aW9uIG9mIGFsbCBgSWd4VGFiSXRlbUNvbXBvbmVudGBzIGRlZmluZWQgaW4gdGhlIHBhZ2UuXG4gICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgKiBjb25zdCB0YWJJdGVtcyA9IHRoaXMubXlUYWJDb21wb25lbnQuY29udGVudFRhYnM7XG4gICAgKiBgYGBcbiAgICAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oZm9yd2FyZFJlZigoKSA9PiBJZ3hUYWJJdGVtQ29tcG9uZW50KSlcbiAgICBwdWJsaWMgY29udGVudFRhYnM6IFF1ZXJ5TGlzdDxJZ3hUYWJJdGVtQ29tcG9uZW50PjtcblxuICAgIC8qKlxuICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgdGhlIGBzZWxlY3RlZEluZGV4YC5cbiAgICAqIERlZmF1bHQgdmFsdWUgaXMgMC5cbiAgICAqIGBgYGh0bWxcbiAgICAqIDxpZ3gtdGFicyBzZWxlY3RlZEluZGV4PVwiMVwiPlxuICAgICogYGBgXG4gICAgKlxuICAgICogVHdvLXdheSBkYXRhIGJpbmRpbmcuXG4gICAgKiBgYGBodG1sXG4gICAgKiA8aWd4LXRhYnMgWyhzZWxlY3RlZEluZGV4KV09XCJtb2RlbC5zZWxlY3RlZEluZGV4XCI+XG4gICAgKiBgYGBcbiAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBzZWxlY3RlZEluZGV4KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZEluZGV4O1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgc2VsZWN0ZWRJbmRleChpbmRleDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gdHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJyA/IHBhcnNlSW50KGluZGV4LCAxMCkgOiBpbmRleDtcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkSW5kZXggIT09IG5ld0luZGV4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy50YWJzICYmIHRoaXMudGFicy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VGFiID0gdGhpcy50YWJzLnRvQXJyYXkoKVtuZXdJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RhYikge1xuICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybVNlbGVjdGlvbkNoYW5nZShuZXdUYWIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IG5ld0luZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHNlbGVjdGVkSW5kZXhDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIHRhYiBoZWFkZXIgc2l6aW5nIG1vZGUuIFlvdSBjYW4gY2hvb3NlIGJldHdlZW4gYGNvbnRlbnRmaXRgIG9yIGBmaXhlZGAuXG4gICAgICogQnkgZGVmYXVsdCB0aGUgaGVhZGVyIHNpemluZyBtb2RlIGlzIGBjb250ZW50Zml0YC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10YWJzIHR5cGU9XCJmaXhlZFwiPlxuICAgICAqICAgICA8aWd4LXRhYnMtZ3JvdXAgbGFiZWw9XCJIT01FXCI+SG9tZTwvaWd4LXRhYnMtZ3JvdXA+XG4gICAgICogPC9pZ3gtdGFicz5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoJ3R5cGUnKVxuICAgIHB1YmxpYyB0eXBlOiBzdHJpbmcgfCBJZ3hUYWJzVHlwZSA9ICdjb250ZW50Zml0JztcblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY2xhc3MgPSAnJztcblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBhIHRhYiBpdGVtIGlzIGRlc2VsZWN0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdGFicyAob25UYWJJdGVtRGVzZWxlY3RlZCk9XCJpdGVtRGVzZWxlY3RlZCgkZXZlbnQpXCI+XG4gICAgICogICAgICA8aWd4LXRhYnMtZ3JvdXAgbGFiZWw9XCJUYWIgMVwiPlRoaXMgaXMgVGFiIDEgY29udGVudC48L2lneC10YWJzLWdyb3VwPlxuICAgICAqICAgICAgPGlneC10YWJzLWdyb3VwIGxhYmVsPVwiVGFiIDJcIj5UaGlzIGlzIFRhYiAyIGNvbnRlbnQuPC9pZ3gtdGFicy1ncm91cD5cbiAgICAgKiA8L2lneC10YWJzPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBpdGVtRGVzZWxlY3RlZChlKXtcbiAgICAgKiAgICAgIGNvbnN0IHRhYkdyb3VwID0gZS5ncm91cDtcbiAgICAgKiAgICAgIGNvbnN0IHRhYkl0ZW0gPSBlLnRhYjtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uVGFiSXRlbURlc2VsZWN0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAqIEVtaXR0ZWQgd2hlbiBhIHRhYiBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICogYGBgaHRtbFxuICAgICogPGlneC10YWJzIChvblRhYkl0ZW1TZWxlY3RlZCk9XCJpdGVtU2VsZWN0ZWQoJGV2ZW50KVwiPlxuICAgICogICAgICA8aWd4LXRhYnMtZ3JvdXAgbGFiZWw9XCJUYWIgMVwiPlRoaXMgaXMgVGFiIDEgY29udGVudC48L2lneC10YWJzLWdyb3VwPlxuICAgICogICAgICA8aWd4LXRhYnMtZ3JvdXAgbGFiZWw9XCJUYWIgMlwiPlRoaXMgaXMgVGFiIDIgY29udGVudC48L2lneC10YWJzLWdyb3VwPlxuICAgICogPC9pZ3gtdGFicz5cbiAgICAqIGBgYFxuICAgICogYGBgdHlwZXNjcmlwdFxuICAgICogaXRlbVNlbGVjdGVkKGUpe1xuICAgICogICAgICBjb25zdCB0YWJHcm91cCA9IGUuZ3JvdXA7XG4gICAgKiAgICAgIGNvbnN0IHRhYkl0ZW0gPSBlLnRhYjtcbiAgICAqIH1cbiAgICAqIGBgYFxuICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uVGFiSXRlbVNlbGVjdGVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2NvbnRlbnRzQ29udGFpbmVyJywgeyBzdGF0aWM6IHRydWUgfSlcbiAgICBwdWJsaWMgY29udGVudHNDb250YWluZXI6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnaGVhZGVyQ29udGFpbmVyJywgeyBzdGF0aWM6IHRydWUgfSlcbiAgICBwdWJsaWMgaGVhZGVyQ29udGFpbmVyOiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2l0ZW1zQ29udGFpbmVyJywgeyBzdGF0aWM6IHRydWUgfSlcbiAgICBwdWJsaWMgaXRlbXNDb250YWluZXI6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnc2VsZWN0ZWRJbmRpY2F0b3InKVxuICAgIHB1YmxpYyBzZWxlY3RlZEluZGljYXRvcjogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICovXG4gICAgQFZpZXdDaGlsZCgndGFic0NvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIHRhYnNDb250YWluZXI6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgndmlld1BvcnQnLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHB1YmxpYyB2aWV3UG9ydDogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGFuIG9ic2VydmFibGUgY29sbGVjdGlvbiBvZiBhbGwgYElneFRhYkl0ZW1Db21wb25lbnRgcy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgdGFiSXRlbXMgPSB0aGlzLm15VGFiQ29tcG9uZW50LnZpZXdUYWJzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGRyZW4oZm9yd2FyZFJlZigoKSA9PiBJZ3hUYWJJdGVtQ29tcG9uZW50KSlcbiAgICBwdWJsaWMgdmlld1RhYnM6IFF1ZXJ5TGlzdDxJZ3hUYWJJdGVtQ29tcG9uZW50PjtcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGFuIG9ic2VydmFibGUgY29sbGVjdGlvbiBvZiBhbGwgYElneFRhYkl0ZW1Db21wb25lbnRgcy5cbiAgICAgKiBGaXJzdCB0cnkgdG8gZ2V0IHRoZW0gYXMgY29udGVudCBjaGlsZHJlbiBpZiBub3QgYXZhaWxhYmxlIGdldCB0aGVtIGFzIHZpZXcgY2hpbGRyZW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHRhYkl0ZW1zID0gdGhpcy5teVRhYkNvbXBvbmVudC50YWJzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdGFicygpOiBRdWVyeUxpc3Q8SWd4VGFiSXRlbUNvbXBvbmVudD4ge1xuICAgICAgICBpZiAodGhpcy5oYXNDb250ZW50VGFicykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFRhYnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1RhYnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBoYXNDb250ZW50VGFicygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmNvbnRlbnRUYWJzICYmIHRoaXMuY29udGVudFRhYnMubGVuZ3RoID4gMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBjYWxjdWxhdGVkV2lkdGg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgdmlzaWJsZUl0ZW1zV2lkdGg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb2Zmc2V0ID0gMDtcblxuICAgIHByaXZhdGUgX2dyb3VwQ2hhbmdlcyQ6IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF9zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgcHJpdmF0ZSBfcmVzaXplT2JzZXJ2ZXI6IFJlc2l6ZU9ic2VydmVyO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5jbGFzcycpXG4gICAgcHVibGljIGdldCBjc3NDbGFzcygpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFN0eWxlID0gYGlneC10YWJzYDtcbiAgICAgICAgY29uc3QgZml4ZWRTdHlsZSA9IGBpZ3gtdGFicy0tZml4ZWRgO1xuICAgICAgICBjb25zdCBpY29uU3R5bGUgPSBgaWd4LXRhYnMtLWljb25zYDtcbiAgICAgICAgY29uc3QgaWNvbkxhYmVsRm91bmRJbkdyb3VwcyA9IHRoaXMuZ3JvdXBzLmZpbmQoKGdyb3VwKSA9PiBncm91cC5pY29uICE9IG51bGwgJiYgZ3JvdXAubGFiZWwgIT0gbnVsbCk7XG4gICAgICAgIGNvbnN0IGljb25MYWJlbEZvdW5kSW5UYWJzID0gdGhpcy5jb250ZW50VGFicy5maW5kKCh0YWIpID0+IHRhYi5pY29uICE9IG51bGwgJiYgdGFiLmxhYmVsICE9IG51bGwpO1xuICAgICAgICBsZXQgY3NzOiBzdHJpbmc7XG4gICAgICAgIHN3aXRjaCAoSWd4VGFic1R5cGVbdGhpcy50eXBlLnRvVXBwZXJDYXNlKCldKSB7XG4gICAgICAgICAgICBjYXNlIElneFRhYnNUeXBlLkZJWEVEOiB7XG4gICAgICAgICAgICAgICAgY3NzID0gZml4ZWRTdHlsZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjc3MgPSBkZWZhdWx0U3R5bGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMYXlvdXQgZml4IGZvciBpdGVtcyB3aXRoIGljb25zXG4gICAgICAgIGlmIChpY29uTGFiZWxGb3VuZEluR3JvdXBzICE9PSB1bmRlZmluZWQgfHwgaWNvbkxhYmVsRm91bmRJblRhYnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY3NzID0gYCR7Y3NzfSAke2ljb25TdHlsZX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGAke2Nzc30gJHt0aGlzLmNsYXNzfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBzY3JvbGxMZWZ0KGV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2Nyb2xsKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHNjcm9sbFJpZ2h0KGV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2Nyb2xsKHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2Nyb2xsRWxlbWVudChlbGVtZW50OiBhbnksIHNjcm9sbFJpZ2h0OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHZpZXdQb3J0V2lkdGggPSB0aGlzLnZpZXdQb3J0Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgdGhpcy5vZmZzZXQgPSAoc2Nyb2xsUmlnaHQpID8gZWxlbWVudC5vZmZzZXRXaWR0aCArIGVsZW1lbnQub2Zmc2V0TGVmdCAtIHZpZXdQb3J0V2lkdGggOiBlbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgICAgIHRoaXMuaXRlbXNDb250YWluZXIubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7LXRoaXMub2Zmc2V0fXB4KWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2VsZWN0ZWQgYElneFRhYkl0ZW1Db21wb25lbnRgLlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IHNlbGVjdGVkSXRlbSA9IHRoaXMubXlUYWJDb21wb25lbnQuc2VsZWN0ZWRUYWJJdGVtO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZFRhYkl0ZW0oKTogSWd4VGFiSXRlbUNvbXBvbmVudCB7XG4gICAgICAgIGlmICh0aGlzLnRhYnMgJiYgdGhpcy5zZWxlY3RlZEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhYnMudG9BcnJheSgpW3RoaXMuc2VsZWN0ZWRJbmRleF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmLCBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSwgcHJpdmF0ZSBwbGF0Zm9ybVV0aWw6IFBsYXRmb3JtVXRpbCkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMudGFicy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHQuaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gdC5pbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5oYXNDb250ZW50VGFicyAmJiAodGhpcy5zZWxlY3RlZEluZGV4IDwgMCB8fCB0aGlzLnNlbGVjdGVkSW5kZXggPj0gdGhpcy5ncm91cHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wbGF0Zm9ybVV0aWwuaXNCcm93c2VyKSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RhYiA9IHRoaXMudGFicy50b0FycmF5KClbdGhpcy5fc2VsZWN0ZWRJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RhYikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1TZWxlY3Rpb24obmV3VGFiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVJbmRpY2F0b3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzQ29udGVudFRhYnMgJiYgdGhpcy5fc2VsZWN0ZWRJbmRleCA+PSAwICYmIHRoaXMuX3NlbGVjdGVkSW5kZXggPCB0aGlzLnRhYnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdUYWIgPSB0aGlzLnRhYnMudG9BcnJheSgpW3RoaXMuX3NlbGVjdGVkSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1Db250ZW50QW5pbWF0aW9uKG5ld1RhYiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy50YWJzQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ncm91cENoYW5nZXMkID0gdGhpcy5ncm91cHMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvbk9uQ29sbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2dyb3VwQ2hhbmdlcyQpIHtcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwQ2hhbmdlcyQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHJlc2V0U2VsZWN0aW9uT25Db2xsZWN0aW9uQ2hhbmdlZCgpOiB2b2lkIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUYWIgPSB0aGlzLnRhYnMudG9BcnJheSgpW3RoaXMuc2VsZWN0ZWRJbmRleF07XG4gICAgICAgICAgICBpZiAoY3VycmVudFRhYikge1xuICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybVNlbGVjdGlvbkNoYW5nZShjdXJyZW50VGFiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3RlZEluZGV4ID49IHRoaXMudGFicy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1TZWxlY3Rpb25DaGFuZ2UodGhpcy50YWJzLmxhc3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVJbmRpY2F0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzY3JvbGwoc2Nyb2xsUmlnaHQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdGFic0FycmF5ID0gdGhpcy50YWJzLnRvQXJyYXkoKTtcbiAgICAgICAgZm9yIChjb25zdCB0YWIgb2YgdGFic0FycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGFiLm5hdGl2ZVRhYkl0ZW0ubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChzY3JvbGxSaWdodCkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm9mZnNldFdpZHRoICsgZWxlbWVudC5vZmZzZXRMZWZ0ID4gdGhpcy52aWV3UG9ydC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoICsgdGhpcy5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50KGVsZW1lbnQsIHNjcm9sbFJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5vZmZzZXRXaWR0aCArIGVsZW1lbnQub2Zmc2V0TGVmdCA+PSB0aGlzLm9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQoZWxlbWVudCwgc2Nyb2xsUmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHBlcmZvcm1TZWxlY3Rpb25DaGFuZ2UobmV3VGFiOiBJZ3hUYWJJdGVtQmFzZSk6IHZvaWQge1xuICAgICAgICBjb25zdCBvbGRUYWIgPSB0aGlzLnNlbGVjdGVkVGFiSXRlbTtcbiAgICAgICAgaWYgKG9sZFRhYikge1xuICAgICAgICAgICAgdGhpcy5wZXJmb3JtRGVzZWxlY3Rpb24ob2xkVGFiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VGFiKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1TZWxlY3Rpb24obmV3VGFiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIG5ldyBzZWxlY3RlZCB0YWIgaGlkZSB0aGUgc2VsZWN0aW9uIGluZGljYXRvclxuICAgICAgICAgICAgdGhpcy5oaWRlSW5kaWNhdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4Q2hhbmdlLmVtaXQodGhpcy5fc2VsZWN0ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwZXJmb3JtRGVzZWxlY3Rpb24ob2xkVGFiOiBJZ3hUYWJJdGVtQmFzZSk6IHZvaWQge1xuICAgICAgICBvbGRUYWIuc2V0U2VsZWN0ZWRJbnRlcm5hbChmYWxzZSk7XG4gICAgICAgIGNvbnN0IG9sZFRhYlJlbGF0ZWRHcm91cCA9IHRoaXMuZ3JvdXBzLnRvQXJyYXkoKVtvbGRUYWIuaW5kZXhdO1xuICAgICAgICBpZiAob2xkVGFiUmVsYXRlZEdyb3VwKSB7XG4gICAgICAgICAgICBvbGRUYWJSZWxhdGVkR3JvdXAuc2V0U2VsZWN0ZWRJbnRlcm5hbChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLm9uVGFiSXRlbURlc2VsZWN0ZWQuZW1pdCh7IHRhYjogb2xkVGFiLCBncm91cDogb2xkVGFiUmVsYXRlZEdyb3VwIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgcGVyZm9ybVNlbGVjdGlvbihuZXdUYWI6IElneFRhYkl0ZW1CYXNlKTogdm9pZCB7XG4gICAgICAgIG5ld1RhYi5zZXRTZWxlY3RlZEludGVybmFsKHRydWUpO1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gbmV3VGFiLmluZGV4O1xuXG4gICAgICAgIGxldCBuZXdUYWJSZWxhdGVkR3JvdXAgPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuaGFzQ29udGVudFRhYnMgJiYgdGhpcy5ncm91cHMpIHtcbiAgICAgICAgICAgIG5ld1RhYlJlbGF0ZWRHcm91cCA9IHRoaXMuZ3JvdXBzLnRvQXJyYXkoKVtuZXdUYWIuaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5ld1RhYlJlbGF0ZWRHcm91cCkge1xuICAgICAgICAgICAgICAgIG5ld1RhYlJlbGF0ZWRHcm91cC5zZXRTZWxlY3RlZEludGVybmFsKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vblRhYkl0ZW1TZWxlY3RlZC5lbWl0KHsgdGFiOiBuZXdUYWIsIGdyb3VwOiBuZXdUYWJSZWxhdGVkR3JvdXAgfSk7XG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGJyaW5nIHRoZSBuZXcgc2VsZWN0ZWQgdGFiIGludG8gdmlldyBpZiBpdCBpcyBub3RcbiAgICAgICAgICAgIHRoaXMuYnJpbmdOZXdUYWJJbnRvVmlldyhuZXdUYWIpO1xuICAgICAgICAgICAgLy8gYW5pbWF0ZSB0aGUgbmV3IHNlbGVjdGlvbiBpbmRpY2F0b3JcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtSW5kaWNhdG9yQW5pbWF0aW9uKG5ld1RhYi5uYXRpdmVUYWJJdGVtLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgLy8gYW5pbWF0ZSB0aGUgbmV3IHRhYidzIGdyb3VwIGNvbnRlbnRcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNDb250ZW50VGFicykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtQ29udGVudEFuaW1hdGlvbihuZXdUYWIsIDAuMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgYnJpbmdOZXdUYWJJbnRvVmlldyhuZXdUYWI6IElneFRhYkl0ZW1CYXNlKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRhYk5hdGl2ZUVsZW1lbnQgPSBuZXdUYWIubmF0aXZlVGFiSXRlbS5uYXRpdmVFbGVtZW50O1xuXG4gICAgICAgIC8vIFNjcm9sbCBsZWZ0IGlmIHRoZXJlIGlzIG5lZWRcbiAgICAgICAgaWYgKHRhYk5hdGl2ZUVsZW1lbnQub2Zmc2V0TGVmdCA8IHRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQodGFiTmF0aXZlRWxlbWVudCwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2Nyb2xsIHJpZ2h0IGlmIHRoZXJlIGlzIG5lZWRcbiAgICAgICAgY29uc3Qgdmlld1BvcnRPZmZzZXRXaWR0aCA9IHRoaXMudmlld1BvcnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgY29uc3QgZGVsdGEgPSAodGFiTmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0ICsgdGFiTmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCkgLSAodmlld1BvcnRPZmZzZXRXaWR0aCArIHRoaXMub2Zmc2V0KTtcblxuICAgICAgICAvLyBGaXggZm9yIElFIDExLCBhIGRpZmZlcmVuY2UgaXMgYWNjdW11bGF0ZWQgZnJvbSB0aGUgd2lkdGhzIGNhbGN1bGF0aW9uc1xuICAgICAgICBpZiAoZGVsdGEgPiAxKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQodGFiTmF0aXZlRWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgLy8gYW5pbWF0aW9uIGZvciB0aGUgbmV3IHBhbmVsL2dyb3VwIChub3QgbmVlZGVkIGZvciB0YWIgb25seSBtb2RlKVxuICAgIHB1YmxpYyB0cmFuc2Zvcm1Db250ZW50QW5pbWF0aW9uKHRhYjogSWd4VGFiSXRlbUJhc2UsIGR1cmF0aW9uOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29udGVudE9mZnNldCA9IHRoaXMudGFic0NvbnRhaW5lci5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoICogdGFiLmluZGV4O1xuICAgICAgICB0aGlzLmNvbnRlbnRzQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gPiAwID8gYCR7ZHVyYXRpb259c2AgOiAnaW5pdGlhbCc7XG4gICAgICAgIHRoaXMuY29udGVudHNDb250YWluZXIubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7LWNvbnRlbnRPZmZzZXR9cHgpYDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHRyYW5zZm9ybUluZGljYXRvckFuaW1hdGlvbihlbGVtZW50OiBIVE1MRWxlbWVudCwgZHVyYXRpb24gPSAwLjMpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljYXRvci5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uID4gMCA/IGAke2R1cmF0aW9ufXNgIDogJ2luaXRpYWwnO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljYXRvci5uYXRpdmVFbGVtZW50LnN0eWxlLndpZHRoID0gYCR7ZWxlbWVudC5vZmZzZXRXaWR0aH1weGA7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2VsZW1lbnQub2Zmc2V0TGVmdH1weClgO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGhpZGVJbmRpY2F0b3IoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kaWNhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW0lneFRhYnNDb21wb25lbnQsXG4gICAgICAgIElneFRhYnNHcm91cENvbXBvbmVudCxcbiAgICAgICAgSWd4VGFiSXRlbUNvbXBvbmVudCxcbiAgICAgICAgSWd4VGFiSXRlbVRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICBJZ3hSaWdodEJ1dHRvblN0eWxlRGlyZWN0aXZlLFxuICAgICAgICBJZ3hMZWZ0QnV0dG9uU3R5bGVEaXJlY3RpdmVdLFxuICAgIGV4cG9ydHM6IFtJZ3hUYWJzQ29tcG9uZW50LFxuICAgICAgICBJZ3hUYWJzR3JvdXBDb21wb25lbnQsXG4gICAgICAgIElneFRhYkl0ZW1Db21wb25lbnQsXG4gICAgICAgIElneFRhYkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgSWd4UmlnaHRCdXR0b25TdHlsZURpcmVjdGl2ZSxcbiAgICAgICAgSWd4TGVmdEJ1dHRvblN0eWxlRGlyZWN0aXZlXSxcbiAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBJZ3hCYWRnZU1vZHVsZSwgSWd4SWNvbk1vZHVsZSwgSWd4UmlwcGxlTW9kdWxlXVxufSlcblxuZXhwb3J0IGNsYXNzIElneFRhYnNNb2R1bGUge1xufVxuIl19