import { __decorate } from "tslib";
import { Directive, ElementRef, EventEmitter, HostBinding, HostListener, Input, NgModule, NgZone, OnDestroy, OnInit, Output, Renderer2, ChangeDetectorRef, ViewContainerRef, AfterContentInit, TemplateRef, ContentChildren, QueryList } from '@angular/core';
import { animationFrameScheduler, fromEvent, interval, Subject } from 'rxjs';
import { takeUntil, throttle } from 'rxjs/operators';
import { IgxDragHandleDirective } from './drag-handle.directive';
import { DeprecateProperty } from '../../core/deprecateDecorators';
import { IgxDefaultDropStrategy } from './drag-drop.strategy';
export var RestrictDrag;
(function (RestrictDrag) {
    RestrictDrag[RestrictDrag["VERTICALLY"] = 0] = "VERTICALLY";
    RestrictDrag[RestrictDrag["HORIZONTALLY"] = 1] = "HORIZONTALLY";
    RestrictDrag[RestrictDrag["NONE"] = 2] = "NONE";
})(RestrictDrag || (RestrictDrag = {}));
export class IgxDragLocation {
    constructor(_pageX, _pageY) {
        this._pageX = _pageX;
        this._pageY = _pageY;
        this.pageX = parseFloat(_pageX);
        this.pageY = parseFloat(_pageY);
    }
}
let IgxDragDirective = class IgxDragDirective {
    constructor(cdr, element, viewContainer, zone, renderer) {
        this.cdr = cdr;
        this.element = element;
        this.viewContainer = viewContainer;
        this.zone = zone;
        this.renderer = renderer;
        this.ghostContext = null;
        /**
         * An @Input property that indicates when the drag should start.
         * By default the drag starts after the draggable element is moved by 5px.
         * ```html
         * <div igxDrag [dragTolerance]="100">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * @memberof IgxDragDirective
         */
        this.dragTolerance = 5;
        /**
         * An @Input property that specifies if the base element should not be moved and a ghost element should be rendered that represents it.
         * By default it is set to `true`.
         * If it is set to `false` when dragging the base element is moved instead and no ghost elements are rendered.
         * ```html
         * <div igxDrag [ghost]="false">
         *      <span>Drag Me!</span>
         * </div>
         * ```
         * @memberof IgxDragDirective
         */
        this.ghost = true;
        /**
         * Sets a custom class that will be added to the `ghostElement` element.
         * ```html
         * <div igxDrag [ghostClass]="'ghostElement'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * @memberof IgxDragDirective
         */
        this.ghostClass = '';
        /**
         * @deprecated Please use custom base styling instead.
         * An @Input property that hides the draggable element.
         * By default it's set to false.
         * ```html
         * <div igxDrag [dragTolerance]="100" [hideBaseOnDrag]="'true'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * @memberof IgxDragDirective
         */
        this.hideBaseOnDrag = false;
        /**
         * @deprecated Please use provided transition functions in future.
         * An @Input property that enables/disables the draggable element animation
         * when the element is released.
         * By default it's set to false.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * @memberof IgxDragDirective
         */
        this.animateOnRelease = false;
        /**
         * Event triggered when the draggable element drag starts.
         * ```html
         * <div igxDrag (dragStart)="onDragStart()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragStart(){
         *      alert("The drag has stared!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.dragStart = new EventEmitter();
        /**
         * Event triggered when the draggable element has been moved.
         * ```html
         * <div igxDrag  (dragMove)="onDragMove()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragMove(){
         *      alert("The element has moved!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.dragMove = new EventEmitter();
        /**
         * Event triggered when the draggable element is released.
         * ```html
         * <div igxDrag (dragEnd)="onDragEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragEnd(){
         *      alert("The drag has ended!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.dragEnd = new EventEmitter();
        /**
         * Event triggered when the draggable element is clicked.
         * ```html
         * <div igxDrag (dragClick)="onDragClick()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragClick(){
         *      alert("The element has been clicked!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.dragClick = new EventEmitter();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostCreate)="ghostCreated()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostCreated(){
         *      alert("The ghost has been created!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.ghostCreate = new EventEmitter();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostDestroy)="ghostDestroyed()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostDestroyed(){
         *      alert("The ghost has been destroyed!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.ghostDestroy = new EventEmitter();
        /**
         * Event triggered after the draggable element is released and after its animation has finished.
         * ```html
         * <div igxDrag (transitioned)="onMoveEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onMoveEnd(){
         *      alert("The move has ended!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.transitioned = new EventEmitter();
        /**
         * @hidden
         */
        this._visibility = 'visible';
        /**
         * @hidden
         */
        this.baseClass = true;
        /**
         * @hidden
         */
        this.selectDisabled = false;
        /**
         * @hidden
         */
        this.defaultReturnDuration = '0.5s';
        /**
         * @hidden
         */
        this.animInProgress = false;
        this._startX = 0;
        this._startY = 0;
        this._lastX = 0;
        this._lastY = 0;
        this._dragStarted = false;
        this._ghostHostX = 0;
        this._ghostHostY = 0;
        this._pointerDownId = null;
        this._clicked = false;
        this._lastDropArea = null;
        this._destroy = new Subject();
        this._removeOnDestroy = true;
    }
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetX]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    set ghostOffsetX(value) {
        this._offsetX = parseInt(value, 10);
    }
    get ghostOffsetX() {
        return this._offsetX !== undefined ? this._offsetX : this._defaultOffsetX;
    }
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetY]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    set ghostOffsetY(value) {
        this._offsetY = parseInt(value, 10);
    }
    get ghostOffsetY() {
        return this._offsetY !== undefined ? this._offsetY : this._defaultOffsetY;
    }
    /**
     * @deprecated Please use native angular ways of hiding it using custom to the base element styling for future versions.
     * Sets the visibility of the draggable element.
     * ```typescript
     * @ViewChild("myDrag" ,{read: IgxDragDirective})
     * public myDrag: IgxDragDirective;
     * ngAfterViewInit(){
     *     this.myDrag.visible = false;
     * }
     * ```
     */
    set visible(bVisible) {
        this._visibility = bVisible ? 'visible' : 'hidden';
        this.cdr.detectChanges();
    }
    /**
     * Returns the visibility state of the draggable element.
     * ```typescript
     * @ViewChild("myDrag" ,{read: IgxDragDirective})
     * public myDrag: IgxDragDirective;
     * ngAfterViewInit(){
     *     let dragVisibility = this.myDrag.visible;
     * }
     * ```
     */
    get visible() {
        return this._visibility === 'visible';
    }
    /**
     * Gets the current location of the element relative to the page.
     */
    get location() {
        return new IgxDragLocation(this.pageX, this.pageY);
    }
    /**
     * Gets the original location of the element before dragging started.
     */
    get originLocation() {
        return new IgxDragLocation(this.baseOriginLeft, this.baseOriginTop);
    }
    /**
     * @hidden
     */
    get pointerEventsEnabled() {
        return typeof PointerEvent !== 'undefined';
    }
    /**
     * @hidden
     */
    get touchEventsEnabled() {
        return 'ontouchstart' in window;
    }
    /**
     * @hidden
     */
    get pageX() {
        if (this.ghost && this.ghostElement) {
            return this.ghostLeft;
        }
        return this.baseLeft;
    }
    /**
     * @hidden
     */
    get pageY() {
        if (this.ghost && this.ghostElement) {
            return this.ghostTop;
        }
        return this.baseTop;
    }
    get baseLeft() {
        return this.element.nativeElement.getBoundingClientRect().left;
    }
    get baseTop() {
        return this.element.nativeElement.getBoundingClientRect().top;
    }
    get baseOriginLeft() {
        return this.baseLeft - this.getTransformX(this.element.nativeElement);
    }
    get baseOriginTop() {
        return this.baseTop - this.getTransformY(this.element.nativeElement);
    }
    set ghostLeft(pageX) {
        if (this.ghostElement) {
            // We need to take into account marginLeft, since top style does not include margin, but pageX includes the margin.
            const ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
            // If ghost host is defined it needs to be taken into account.
            this.ghostElement.style.left = (pageX - ghostMarginLeft - this._ghostHostX) + 'px';
        }
    }
    get ghostLeft() {
        return parseInt(this.ghostElement.style.left, 10) + this._ghostHostX;
    }
    set ghostTop(pageY) {
        if (this.ghostElement) {
            // We need to take into account marginTop, since top style does not include margin, but pageY includes the margin.
            const ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
            // If ghost host is defined it needs to be taken into account.
            this.ghostElement.style.top = (pageY - ghostMarginTop - this._ghostHostY) + 'px';
        }
    }
    get ghostTop() {
        return parseInt(this.ghostElement.style.top, 10) + this._ghostHostY;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (!this.dragHandles || !this.dragHandles.length) {
            // Set user select none to the whole draggable element if no drag handles are defined.
            this.selectDisabled = true;
        }
        // Bind events
        this.zone.runOutsideAngular(() => {
            const targetElements = this.dragHandles && this.dragHandles.length ?
                this.dragHandles.map((item) => item.element.nativeElement) : [this.element.nativeElement];
            targetElements.forEach((element) => {
                if (this.pointerEventsEnabled) {
                    fromEvent(element, 'pointerdown').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                    fromEvent(element, 'pointermove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                    fromEvent(element, 'pointerup').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerUp(res));
                    if (!this.ghost) {
                        // Do not bind `lostpointercapture` to the target, because we will bind it on the ghost later.
                        fromEvent(element, 'lostpointercapture').pipe(takeUntil(this._destroy))
                            .subscribe((res) => this.onPointerLost(res));
                    }
                }
                else if (this.touchEventsEnabled) {
                    fromEvent(element, 'touchstart').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                }
                else {
                    // We don't have pointer events and touch events. Use then mouse events.
                    fromEvent(element, 'mousedown').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                }
            });
            // We should bind to document events only once when there are no pointer events.
            if (!this.pointerEventsEnabled && this.touchEventsEnabled) {
                fromEvent(document.defaultView, 'touchmove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                fromEvent(document.defaultView, 'touchend').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerUp(res));
            }
            else if (!this.pointerEventsEnabled) {
                fromEvent(document.defaultView, 'mousemove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                fromEvent(document.defaultView, 'mouseup').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerUp(res));
            }
            this.element.nativeElement.addEventListener('transitionend', (args) => {
                this.onTransitionEnd(args);
            });
        });
        // Set transition duration to 0s. This also helps with setting `visibility: hidden` to the base to not lag.
        this.element.nativeElement.style.transitionDuration = '0.0s';
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
        if (this.ghost && this.ghostElement && this._removeOnDestroy) {
            this.ghostElement.parentNode.removeChild(this.ghostElement);
            this.ghostElement = null;
        }
    }
    /**
     * Sets desired location of the base element or ghost element if rended relative to the document.
     * @param newLocation New location that should be applied. It is advised to get new location using getBoundingClientRects() + scroll.
     */
    setLocation(newLocation) {
        // We do not subtract marginLeft and marginTop here because here we calculate deltas.
        if (this.ghost && this.ghostElement) {
            const offsetHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
            const offsetHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
            this.ghostLeft = newLocation.pageX - offsetHostX + this.getWindowScrollLeft();
            this.ghostTop = newLocation.pageY - offsetHostY + this.getWindowScrollTop();
        }
        else if (!this.ghost) {
            const deltaX = newLocation.pageX - this.pageX;
            const deltaY = newLocation.pageY - this.pageY;
            const transformX = this.getTransformX(this.element.nativeElement);
            const transformY = this.getTransformY(this.element.nativeElement);
            this.setTransformXY(transformX + deltaX, transformY + deltaY);
        }
        this._startX = this.baseLeft;
        this._startY = this.baseTop;
    }
    /**
     * Animates the base or ghost element depending on the `ghost` input to its initial location.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * If the base element has changed its DOM position its initial location will be changed accordingly.
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionToOrigin(customAnimArgs, startLocation) {
        if ((!!startLocation && startLocation.pageX === this.baseOriginLeft && startLocation.pageY === this.baseOriginLeft) ||
            (!startLocation && this.ghost && !this.ghostElement)) {
            return;
        }
        if (!!startLocation && startLocation.pageX !== this.pageX && startLocation.pageY !== this.pageY) {
            if (this.ghost && !this.ghostElement) {
                this._startX = startLocation.pageX;
                this._startY = startLocation.pageY;
                this._ghostStartX = this._startX;
                this._ghostStartY = this._startY;
                this.createGhost(this._startX, this._startY);
            }
            this.setLocation(startLocation);
        }
        this.animInProgress = true;
        // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
        setTimeout(() => {
            if (this.ghost) {
                this.ghostElement.style.transitionProperty = 'top, left';
                this.ghostElement.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
                this.ghostElement.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                this.ghostElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                this.setLocation(new IgxDragLocation(this.baseLeft, this.baseTop));
            }
            else if (!this.ghost) {
                this.element.nativeElement.style.transitionProperty = 'transform';
                this.element.nativeElement.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
                this.element.nativeElement.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                this.element.nativeElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                this._startX = this.baseLeft;
                this._startY = this.baseTop;
                this.setTransformXY(0, 0);
            }
        }, 0);
    }
    /**
     * Animates the base or ghost element to a specific target location or other element using transition.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * It is recommended to use 'getBoundingClientRects() + pageScroll' when determining desired location.
     * @param target Target that the base or ghost will transition to. It can be either location in the page or another HTML element.
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionTo(target, customAnimArgs, startLocation) {
        if (!!startLocation && this.ghost && !this.ghostElement) {
            this._startX = startLocation.pageX;
            this._startY = startLocation.pageY;
            this._ghostStartX = this._startX;
            this._ghostStartY = this._startY;
        }
        else if (!!startLocation && (!this.ghost || this.ghostElement)) {
            this.setLocation(startLocation);
        }
        else if (this.ghost && !this.ghostElement) {
            this._startX = this.baseLeft;
            this._startY = this.baseTop;
            this._ghostStartX = this._startX + this.getWindowScrollLeft();
            this._ghostStartY = this._startY + this.getWindowScrollTop();
        }
        if (this.ghost && !this.ghostElement) {
            this.createGhost(this._startX, this._startY);
        }
        this.animInProgress = true;
        // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
        setTimeout(() => {
            const movedElem = this.ghost ? this.ghostElement : this.element.nativeElement;
            movedElem.style.transitionProperty = this.ghost && this.ghostElement ? 'left, top' : 'transform';
            movedElem.style.transitionDuration =
                customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
            movedElem.style.transitionTimingFunction =
                customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
            movedElem.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
            if (target instanceof IgxDragLocation) {
                this.setLocation(new IgxDragLocation(target.pageX, target.pageY));
            }
            else {
                const targetRects = target.nativeElement.getBoundingClientRect();
                this.setLocation(new IgxDragLocation(targetRects.left - this.getWindowScrollLeft(), targetRects.top - this.getWindowScrollTop()));
            }
        }, 0);
    }
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param event PointerDown event captured
     */
    onPointerDown(event) {
        this._clicked = true;
        this._pointerDownId = event.pointerId;
        // Set pointer capture so we detect pointermove even if mouse is out of bounds until ghostElement is created.
        const handleFound = this.dragHandles.find(handle => handle.element.nativeElement === event.currentTarget);
        const targetElement = handleFound ? handleFound.element.nativeElement : this.element.nativeElement;
        if (this.pointerEventsEnabled) {
            targetElement.setPointerCapture(this._pointerDownId);
        }
        else {
            targetElement.focus();
            event.preventDefault();
        }
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            this._startX = event.pageX;
            this._startY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            this._startX = event.touches[0].pageX;
            this._startY = event.touches[0].pageY;
        }
        this._defaultOffsetX = this.baseLeft - this._startX + this.getWindowScrollLeft();
        this._defaultOffsetY = this.baseTop - this._startY + this.getWindowScrollTop();
        this._ghostStartX = this._startX + this.ghostOffsetX;
        this._ghostStartY = this._startY + this.ghostOffsetY;
        this._lastX = this._startX;
        this._lastY = this._startY;
    }
    /**
     * @hidden
     * Perform drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned it. Then this method is bound to it.
     * @param event PointerMove event captured
     */
    onPointerMove(event) {
        if (this._clicked) {
            let pageX, pageY;
            if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                pageX = event.pageX;
                pageY = event.pageY;
            }
            else if (this.touchEventsEnabled) {
                pageX = event.touches[0].pageX;
                pageY = event.touches[0].pageY;
                // Prevent scrolling on touch while dragging
                event.preventDefault();
            }
            const totalMovedX = pageX - this._startX;
            const totalMovedY = pageY - this._startY;
            if (!this._dragStarted &&
                (Math.abs(totalMovedX) > this.dragTolerance || Math.abs(totalMovedY) > this.dragTolerance)) {
                const dragStartArgs = {
                    originalEvent: event,
                    owner: this,
                    startX: pageX - totalMovedX,
                    startY: pageY - totalMovedY,
                    pageX: pageX,
                    pageY: pageY,
                    cancel: false
                };
                this.zone.run(() => {
                    this.dragStart.emit(dragStartArgs);
                });
                if (!dragStartArgs.cancel) {
                    this._dragStarted = true;
                    if (this.ghost) {
                        // We moved enough so ghostElement can be rendered and actual dragging to start.
                        // When creating it will take into account any offset set by the user by default.
                        this.createGhost(pageX, pageY);
                    }
                    else if (this._offsetX !== undefined || this._offsetY !== undefined) {
                        // There is no need for ghost, but we will need to position initially the base element to reflect any offset.
                        const transformX = (this._offsetX !== undefined ? this._offsetX - this._defaultOffsetX : 0) +
                            this.getTransformX(this.element.nativeElement);
                        const transformY = (this._offsetY !== undefined ? this._offsetY - this._defaultOffsetY : 0) +
                            this.getTransformY(this.element.nativeElement);
                        this.setTransformXY(transformX, transformY);
                    }
                }
                else {
                    return;
                }
            }
            else if (!this._dragStarted) {
                return;
            }
            const moveArgs = {
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: this._lastX,
                pageY: this._lastY,
                nextPageX: pageX,
                nextPageY: pageY,
                cancel: false
            };
            this.dragMove.emit(moveArgs);
            const setPageX = moveArgs.nextPageX;
            const setPageY = moveArgs.nextPageY;
            const updatedMovedX = setPageX - this._startX;
            const updatedMovedY = setPageY - this._startY;
            if (!moveArgs.cancel) {
                if (this.ghost) {
                    this.ghostLeft = this._ghostStartX + updatedMovedX;
                    this.ghostTop = this._ghostStartY + updatedMovedY;
                }
                else {
                    const lastMovedX = setPageX - this._lastX;
                    const lastMovedY = setPageY - this._lastY;
                    const translateX = this.getTransformX(this.element.nativeElement) + lastMovedX;
                    const translateY = this.getTransformY(this.element.nativeElement) + lastMovedY;
                    this.setTransformXY(translateX, translateY);
                }
                this.dispatchDragEvents(pageX, pageY, event);
            }
            this._lastX = setPageX;
            this._lastY = setPageY;
        }
    }
    /**
     * @hidden
     * Perform drag end logic when releasing the ghostElement and dispatching drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned to it. Then this method is bound to it.
     * @param event PointerUp event captured
     */
    onPointerUp(event) {
        if (!this._clicked) {
            return;
        }
        let pageX, pageY;
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            pageX = event.pageX;
            pageY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            pageX = event.touches[0].pageX;
            pageY = event.touches[0].pageY;
            // Prevent scrolling on touch while dragging
            event.preventDefault();
        }
        const eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY
        };
        this._pointerDownId = null;
        this._clicked = false;
        if (this._dragStarted) {
            if (this._lastDropArea && this._lastDropArea !== this.element.nativeElement) {
                this.dispatchDropEvent(event.pageX, event.pageY, event);
            }
            else if (this.animateOnRelease) {
                this.transitionToOrigin();
            }
            this.zone.run(() => {
                this.dragEnd.emit(eventArgs);
            });
            if (!this.animInProgress) {
                this.onTransitionEnd(null);
            }
        }
        else {
            // Trigger our own click event because when there is no ghost, native click cannot be prevented when dragging.
            this.zone.run(() => {
                this.dragClick.emit(eventArgs);
            });
        }
    }
    /**
     * @hidden
     * Execute this method whe the pointer capture has been lost.
     * This means that during dragging the user has performed other action like right clicking and then clicking somewhere else.
     * This method will ensure that the drag state is being reset in this case as if the user released the dragged element.
     * @param event Event captured
     */
    onPointerLost(event) {
        if (!this._clicked) {
            return;
        }
        const eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX: event.pageX,
            pageY: event.pageY
        };
        this._pointerDownId = null;
        this._clicked = false;
        if (this._dragStarted) {
            this.zone.run(() => {
                this.dragEnd.emit(eventArgs);
            });
            if (this.animateOnRelease) {
                this.transitionToOrigin();
            }
            else if (!this.animInProgress) {
                this.onTransitionEnd(null);
            }
        }
    }
    /**
     * @hidden
     * Create ghost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @param pageX Latest pointer position on the X axis relative to the page.
     * @param pageY Latest pointer position on the Y axis relative to the page.
     * @param node The Node object to be cloned.
     */
    createGhost(pageX, pageY, node = null) {
        if (!this.ghost) {
            return;
        }
        let dynamicGhostRef;
        if (this.ghostTemplate) {
            dynamicGhostRef = this.viewContainer.createEmbeddedView(this.ghostTemplate, this.ghostContext);
            this.ghostElement = dynamicGhostRef.rootNodes[0];
        }
        else {
            this.ghostElement = node ? node.cloneNode(true) : this.element.nativeElement.cloneNode(true);
        }
        const totalMovedX = pageX - this._startX;
        const totalMovedY = pageY - this._startY;
        this._ghostHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
        this._ghostHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
        this.ghostElement.style.transitionDuration = '0.0s';
        this.ghostElement.style.position = 'absolute';
        if (this.ghostClass) {
            this.renderer.addClass(this.ghostElement, this.ghostClass);
        }
        const createEventArgs = {
            owner: this,
            ghostElement: this.ghostElement,
            cancel: false
        };
        this.ghostCreate.emit(createEventArgs);
        if (createEventArgs.cancel) {
            this.ghostElement = null;
            if (this.ghostTemplate && dynamicGhostRef) {
                dynamicGhostRef.destroy();
            }
            return;
        }
        if (this.ghostHost) {
            this.ghostHost.appendChild(this.ghostElement);
        }
        else {
            document.body.appendChild(this.ghostElement);
        }
        const ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
        const ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
        this.ghostElement.style.left = (this._ghostStartX - ghostMarginLeft + totalMovedX - this._ghostHostX) + 'px';
        this.ghostElement.style.top = (this._ghostStartY - ghostMarginTop + totalMovedY - this._ghostHostX) + 'px';
        if (this.pointerEventsEnabled) {
            // The ghostElement takes control for moving and dragging after it has been rendered.
            if (this._pointerDownId !== null) {
                this.ghostElement.setPointerCapture(this._pointerDownId);
            }
            this.ghostElement.addEventListener('pointermove', (args) => {
                this.onPointerMove(args);
            });
            this.ghostElement.addEventListener('pointerup', (args) => {
                this.onPointerUp(args);
            });
            this.ghostElement.addEventListener('lostpointercapture', (args) => {
                this.onPointerLost(args);
            });
        }
        // Transition animation when the ghostElement is released and it returns to it's original position.
        this.ghostElement.addEventListener('transitionend', (args) => {
            this.onTransitionEnd(args);
        });
        // Hide the base after the ghostElement is created, because otherwise the ghostElement will be not visible.
        if (this.hideBaseOnDrag) {
            this.visible = false;
        }
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     */
    dispatchDragEvents(pageX, pageY, originalEvent) {
        let topDropArea;
        const customEventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this,
            originalEvent: originalEvent
        };
        const elementsFromPoint = this.getElementsAtPoint(pageX, pageY);
        for (let i = 0; i < elementsFromPoint.length; i++) {
            if (elementsFromPoint[i].getAttribute('droppable') === 'true' &&
                elementsFromPoint[i] !== this.ghostElement && elementsFromPoint[i] !== this.element.nativeElement) {
                topDropArea = elementsFromPoint[i];
                break;
            }
        }
        if (topDropArea &&
            (!this._lastDropArea || (this._lastDropArea && this._lastDropArea !== topDropArea))) {
            if (this._lastDropArea) {
                this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            }
            this._lastDropArea = topDropArea;
            this.dispatchEvent(this._lastDropArea, 'igxDragEnter', customEventArgs);
        }
        else if (!topDropArea && this._lastDropArea) {
            this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            this._lastDropArea = null;
            return;
        }
        if (topDropArea) {
            this.dispatchEvent(topDropArea, 'igxDragOver', customEventArgs);
        }
    }
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in @dispatchDragEvents method.
     */
    dispatchDropEvent(pageX, pageY, originalEvent) {
        const eventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this,
            originalEvent: originalEvent
        };
        this.dispatchEvent(this._lastDropArea, 'igxDrop', eventArgs);
        this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
        this._lastDropArea = null;
    }
    /**
     * @hidden
     */
    onTransitionEnd(event) {
        if ((!this._dragStarted && !this.animInProgress) || this._clicked) {
            // Return if no dragging started and there is no animation in progress.
            return;
        }
        if (this.ghost && this.ghostElement) {
            this._ghostStartX = this.baseLeft + this.getWindowScrollLeft();
            this._ghostStartY = this.baseTop + this.getWindowScrollTop();
            const ghostDestroyArgs = {
                owner: this,
                ghostElement: this.ghostElement,
                cancel: false
            };
            this.ghostDestroy.emit(ghostDestroyArgs);
            if (ghostDestroyArgs.cancel) {
                return;
            }
            if (this.hideBaseOnDrag) {
                this.visible = true;
            }
            this.ghostElement.parentNode.removeChild(this.ghostElement);
            this.ghostElement = null;
        }
        else if (!this.ghost) {
            this.element.nativeElement.style.transitionProperty = '';
            this.element.nativeElement.style.transitionDuration = '0.0s';
            this.element.nativeElement.style.transitionTimingFunction = '';
            this.element.nativeElement.style.transitionDelay = '';
        }
        this.animInProgress = false;
        this._dragStarted = false;
        // Execute transitioned after everything is reset so if the user sets new location on the base now it would work as expected.
        this.zone.run(() => {
            this.transitioned.emit({
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: this._startX,
                pageY: this._startY
            });
        });
    }
    /**
     * @hidden
     */
    getElementsAtPoint(pageX, pageY) {
        // correct the coordinates with the current scroll position, because
        // document.elementsFromPoint consider position within the current viewport
        // window.pageXOffset == window.scrollX; // always true
        // using window.pageXOffset for IE9 compatibility
        const viewPortX = pageX - window.pageXOffset;
        const viewPortY = pageY - window.pageYOffset;
        if (document['msElementsFromPoint']) {
            // Edge and IE special snowflakes
            const elements = document['msElementsFromPoint'](viewPortX, viewPortY);
            return elements === null ? [] : elements;
        }
        else {
            // Other browsers like Chrome, Firefox, Opera
            return document.elementsFromPoint(viewPortX, viewPortY);
        }
    }
    /**
     * @hidden
     */
    dispatchEvent(target, eventName, eventArgs) {
        // This way is IE11 compatible.
        const dragLeaveEvent = document.createEvent('CustomEvent');
        dragLeaveEvent.initCustomEvent(eventName, false, false, eventArgs);
        target.dispatchEvent(dragLeaveEvent);
        // Otherwise can be used `target.dispatchEvent(new CustomEvent(eventName, eventArgs));`
    }
    getTransformX(elem) {
        let posX = 0;
        if (elem.style.transform) {
            const matrix = elem.style.transform;
            const values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posX = values ? Number(values[1]) : 0;
        }
        return posX;
    }
    getTransformY(elem) {
        let posY = 0;
        if (elem.style.transform) {
            const matrix = elem.style.transform;
            const values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posY = values ? Number(values[2]) : 0;
        }
        return posY;
    }
    /** Method setting transformation to the base draggable element. */
    setTransformXY(x, y) {
        this.element.nativeElement.style.transform = 'translate3d(' + x + 'px, ' + y + 'px, 0px)';
    }
    getWindowScrollTop() {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    }
    getWindowScrollLeft() {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    }
    ghostHostOffsetLeft(ghostHost) {
        const ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
        if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
            return 0;
        }
        else if (ghostPosition === 'static' && ghostHost.offsetParent) {
            return ghostHost.offsetParent.getBoundingClientRect().left - this.getWindowScrollLeft();
        }
        return ghostHost.getBoundingClientRect().left - this.getWindowScrollLeft();
    }
    ghostHostOffsetTop(ghostHost) {
        const ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
        if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
            return 0;
        }
        else if (ghostPosition === 'static' && ghostHost.offsetParent) {
            return ghostHost.offsetParent.getBoundingClientRect().top - this.getWindowScrollTop();
        }
        return ghostHost.getBoundingClientRect().top - this.getWindowScrollTop();
    }
};
IgxDragDirective.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: NgZone },
    { type: Renderer2 }
];
__decorate([
    Input('igxDrag')
], IgxDragDirective.prototype, "data", void 0);
__decorate([
    Input()
], IgxDragDirective.prototype, "dragTolerance", void 0);
__decorate([
    Input()
], IgxDragDirective.prototype, "dragChannel", void 0);
__decorate([
    Input()
], IgxDragDirective.prototype, "ghost", void 0);
__decorate([
    Input()
], IgxDragDirective.prototype, "ghostClass", void 0);
__decorate([
    DeprecateProperty(`'hideBaseOnDrag' @Input property is deprecated and will be removed in future major versions.
        Alternatives to it are using the new no ghost dragging and custom base styling.`),
    Input()
], IgxDragDirective.prototype, "hideBaseOnDrag", void 0);
__decorate([
    DeprecateProperty(`'animateOnRelease' @Input property is deprecated and will be removed in future major versions.
        Please use 'transitionToOrigin' or 'transitionTo' methods instead.`),
    Input()
], IgxDragDirective.prototype, "animateOnRelease", void 0);
__decorate([
    Input()
], IgxDragDirective.prototype, "ghostTemplate", void 0);
__decorate([
    Input()
], IgxDragDirective.prototype, "ghostHost", void 0);
__decorate([
    Input()
], IgxDragDirective.prototype, "ghostOffsetX", null);
__decorate([
    Input()
], IgxDragDirective.prototype, "ghostOffsetY", null);
__decorate([
    Output()
], IgxDragDirective.prototype, "dragStart", void 0);
__decorate([
    Output()
], IgxDragDirective.prototype, "dragMove", void 0);
__decorate([
    Output()
], IgxDragDirective.prototype, "dragEnd", void 0);
__decorate([
    Output()
], IgxDragDirective.prototype, "dragClick", void 0);
__decorate([
    Output()
], IgxDragDirective.prototype, "ghostCreate", void 0);
__decorate([
    Output()
], IgxDragDirective.prototype, "ghostDestroy", void 0);
__decorate([
    Output()
], IgxDragDirective.prototype, "transitioned", void 0);
__decorate([
    ContentChildren(IgxDragHandleDirective)
], IgxDragDirective.prototype, "dragHandles", void 0);
__decorate([
    HostBinding('style.visibility')
], IgxDragDirective.prototype, "_visibility", void 0);
__decorate([
    HostBinding('class.igx-drag')
], IgxDragDirective.prototype, "baseClass", void 0);
__decorate([
    HostBinding('class.igx-drag--select-disabled')
], IgxDragDirective.prototype, "selectDisabled", void 0);
__decorate([
    DeprecateProperty(`'visible' @Input property is deprecated and will be removed in future major versions.
        Please use native angular ways of hiding the base element using styling.`)
], IgxDragDirective.prototype, "visible", null);
IgxDragDirective = __decorate([
    Directive({
        exportAs: 'drag',
        selector: '[igxDrag]'
    })
], IgxDragDirective);
export { IgxDragDirective };
let IgxDropDirective = class IgxDropDirective {
    constructor(element, _renderer, _zone) {
        this.element = element;
        this._renderer = _renderer;
        this._zone = _zone;
        /** Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         * @memberof IgxDropDirective
         */
        this.enter = new EventEmitter();
        /** Event triggered when dragged element enters the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragEnter(){
     *     alert("A draggable element has entered the chip area!");
     * }
     * ```
     * @memberof IgxDropDirective
     */
        this.over = new EventEmitter();
        /** Event triggered when dragged element leaves the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (leave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragLeave(){
         *     alert("A draggable element has left the chip area!");
         * }
         * ```
         * @memberof IgxDropDirective
         */
        this.leave = new EventEmitter();
        /** Event triggered when dragged element is dropped in the area of the element.
         * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
         * To cancel the default logic the `cancel` property of the event needs to be set to true.
         * ```html
         * <div class="cageArea" igxDrop (dropped)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragDrop(){
         *     alert("A draggable element has been dropped in the chip area!");
         * }
         * ```
         * @memberof IgxDropDirective
         */
        this.dropped = new EventEmitter();
        /**
         * @hidden
         */
        this.droppable = true;
        /**
         * @hidden
         */
        this.dragover = false;
        /**
         * @hidden
         */
        this._destroy = new Subject();
        this._dropStrategy = new IgxDefaultDropStrategy();
    }
    /**
     * An @Input property that specifies a drop strategy type that will be executed when an `IgxDrag` element is released inside
     *  the current drop area. The provided strategies are:
     *  - IgxDefaultDropStrategy - This is the default base strategy and it doesn't perform any actions.
     *  - IgxAppendDropStrategy - Appends the dropped element to last position as a direct child to the `igxDrop`.
     *  - IgxPrependDropStrategy - Prepends the dropped element to first position as a direct child to the `igxDrop`.
     *  - IgxInsertDropStrategy - If the dropped element is released above a child element of the `igxDrop`, it will be inserted
     *      at that position. Otherwise the dropped element will be appended if released outside any child of the `igxDrop`.
     * ```html
     * <div igxDrag>
     *      <span>DragMe</span>
     * </div>
     * <div igxDrop [dropStrategy]="myDropStrategy">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * ```typescript
     * import { IgxAppendDropStrategy } from 'igniteui-angular';
     *
     * export class App {
     *      public myDropStrategy = IgxAppendDropStrategy;
     * }
     * ```
     * @memberof IgxDropDirective
     */
    set dropStrategy(classRef) {
        this._dropStrategy = new classRef(this._renderer);
    }
    get dropStrategy() {
        return this._dropStrategy;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this._zone.runOutsideAngular(() => {
            fromEvent(this.element.nativeElement, 'igxDragEnter').pipe(takeUntil(this._destroy))
                .subscribe((res) => this.onDragEnter(res));
            fromEvent(this.element.nativeElement, 'igxDragLeave').pipe(takeUntil(this._destroy)).subscribe((res) => this.onDragLeave(res));
            fromEvent(this.element.nativeElement, 'igxDragOver').pipe(takeUntil(this._destroy)).subscribe((res) => this.onDragOver(res));
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
    }
    /**
     * @hidden
     */
    onDragOver(event) {
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this.over.emit(eventArgs);
    }
    /**
     * @hidden
     */
    onDragEnter(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        this.dragover = true;
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this._zone.run(() => {
            this.enter.emit(eventArgs);
        });
    }
    /**
     * @hidden
     */
    onDragLeave(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        this.dragover = false;
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this._zone.run(() => {
            this.leave.emit(eventArgs);
        });
    }
    /**
     * @hidden
     */
    onDragDrop(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const args = {
            owner: this,
            originalEvent: event.detail.originalEvent,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY,
            cancel: false
        };
        this._zone.run(() => {
            this.dropped.emit(args);
        });
        if (this._dropStrategy && !args.cancel) {
            const elementsAtPoint = event.detail.owner.getElementsAtPoint(event.detail.pageX, event.detail.pageY);
            const insertIndex = this.getInsertIndexAt(event.detail.owner, elementsAtPoint);
            this._dropStrategy.dropAction(event.detail.owner, this, insertIndex);
        }
    }
    getWindowScrollTop() {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    }
    getWindowScrollLeft() {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    }
    isDragLinked(drag) {
        const dragLinkArray = drag.dragChannel instanceof Array;
        const dropLinkArray = this.dropChannel instanceof Array;
        if (!dragLinkArray && !dropLinkArray) {
            return this.dropChannel === drag.dragChannel;
        }
        else if (!dragLinkArray && dropLinkArray) {
            const dropLinks = this.dropChannel;
            for (let i = 0; i < dropLinks.length; i++) {
                if (dropLinks[i] === drag.dragChannel) {
                    return true;
                }
            }
        }
        else if (dragLinkArray && !dropLinkArray) {
            const dragLinks = drag.dragChannel;
            for (let i = 0; i < dragLinks.length; i++) {
                if (dragLinks[i] === this.dropChannel) {
                    return true;
                }
            }
        }
        else {
            const dragLinks = drag.dragChannel;
            const dropLinks = this.dropChannel;
            for (let i = 0; i < dragLinks.length; i++) {
                for (let j = 0; j < dropLinks.length; j++) {
                    if (dragLinks[i] === dropLinks[j]) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    getInsertIndexAt(draggedDir, elementsAtPoint) {
        let insertIndex = -1;
        const dropChildren = Array.prototype.slice.call(this.element.nativeElement.children);
        if (!dropChildren.length) {
            return insertIndex;
        }
        let i = 0;
        let childUnder = null;
        while (!childUnder && i < elementsAtPoint.length) {
            if (elementsAtPoint[i].parentElement === this.element.nativeElement) {
                childUnder = elementsAtPoint[i];
            }
            i++;
        }
        const draggedElemIndex = dropChildren.indexOf(draggedDir.element.nativeElement);
        insertIndex = dropChildren.indexOf(childUnder);
        if (draggedElemIndex !== -1 && draggedElemIndex < insertIndex) {
            insertIndex++;
        }
        return insertIndex;
    }
};
IgxDropDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
__decorate([
    Input('igxDrop')
], IgxDropDirective.prototype, "data", void 0);
__decorate([
    Input()
], IgxDropDirective.prototype, "dropChannel", void 0);
__decorate([
    Input()
], IgxDropDirective.prototype, "dropStrategy", null);
__decorate([
    Output()
], IgxDropDirective.prototype, "enter", void 0);
__decorate([
    Output()
], IgxDropDirective.prototype, "over", void 0);
__decorate([
    Output()
], IgxDropDirective.prototype, "leave", void 0);
__decorate([
    Output()
], IgxDropDirective.prototype, "dropped", void 0);
__decorate([
    HostBinding('attr.droppable')
], IgxDropDirective.prototype, "droppable", void 0);
__decorate([
    HostBinding('class.dragOver')
], IgxDropDirective.prototype, "dragover", void 0);
__decorate([
    HostListener('igxDrop', ['$event'])
], IgxDropDirective.prototype, "onDragDrop", null);
IgxDropDirective = __decorate([
    Directive({
        exportAs: 'drop',
        selector: '[igxDrop]'
    })
], IgxDropDirective);
export { IgxDropDirective };
/**
 * @hidden
 */
let IgxDragDropModule = class IgxDragDropModule {
};
IgxDragDropModule = __decorate([
    NgModule({
        declarations: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective],
        exports: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective]
    })
], IgxDragDropModule);
export { IgxDragDropModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZy1kcm9wLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZGlyZWN0aXZlcy9kcmFnLWRyb3AvZHJhZy1kcm9wLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUMsT0FBTyxFQUNKLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLFdBQVcsRUFDWCxZQUFZLEVBQ1osS0FBSyxFQUNMLFFBQVEsRUFDUixNQUFNLEVBQ04sU0FBUyxFQUNULE1BQU0sRUFDTixNQUFNLEVBQ04sU0FBUyxFQUNULGlCQUFpQixFQUNqQixnQkFBZ0IsRUFDaEIsZ0JBQWdCLEVBQ2hCLFdBQVcsRUFDWCxlQUFlLEVBQ2YsU0FBUyxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM3RSxPQUFPLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ2pFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRW5FLE9BQU8sRUFBaUIsc0JBQXNCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUU3RSxNQUFNLENBQU4sSUFBWSxZQUlYO0FBSkQsV0FBWSxZQUFZO0lBQ3BCLDJEQUFVLENBQUE7SUFDViwrREFBWSxDQUFBO0lBQ1osK0NBQUksQ0FBQTtBQUNSLENBQUMsRUFKVyxZQUFZLEtBQVosWUFBWSxRQUl2QjtBQTBHRCxNQUFNLE9BQU8sZUFBZTtJQUl4QixZQUFvQixNQUFNLEVBQVUsTUFBTTtRQUF0QixXQUFNLEdBQU4sTUFBTSxDQUFBO1FBQVUsV0FBTSxHQUFOLE1BQU0sQ0FBQTtRQUN0QyxJQUFJLENBQUMsS0FBSyxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNoQyxJQUFJLENBQUMsS0FBSyxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNwQyxDQUFDO0NBQ0o7QUFNRCxJQUFhLGdCQUFnQixHQUE3QixNQUFhLGdCQUFnQjtJQTZkekIsWUFDVyxHQUFzQixFQUN0QixPQUFtQixFQUNuQixhQUErQixFQUMvQixJQUFZLEVBQ1osUUFBbUI7UUFKbkIsUUFBRyxHQUFILEdBQUcsQ0FBbUI7UUFDdEIsWUFBTyxHQUFQLE9BQU8sQ0FBWTtRQUNuQixrQkFBYSxHQUFiLGFBQWEsQ0FBa0I7UUFDL0IsU0FBSSxHQUFKLElBQUksQ0FBUTtRQUNaLGFBQVEsR0FBUixRQUFRLENBQVc7UUFoZXBCLGlCQUFZLEdBQVEsSUFBSSxDQUFDO1FBWW5DOzs7Ozs7Ozs7V0FTRztRQUVJLGtCQUFhLEdBQUcsQ0FBQyxDQUFDO1FBa0J6Qjs7Ozs7Ozs7OztXQVVHO1FBRUksVUFBSyxHQUFHLElBQUksQ0FBQztRQUVwQjs7Ozs7Ozs7V0FRRztRQUVJLGVBQVUsR0FBRyxFQUFFLENBQUM7UUFFdkI7Ozs7Ozs7Ozs7V0FVRztRQUlJLG1CQUFjLEdBQUcsS0FBSyxDQUFDO1FBRTlCOzs7Ozs7Ozs7OztXQVdHO1FBSUkscUJBQWdCLEdBQUcsS0FBSyxDQUFDO1FBMEVoQzs7Ozs7Ozs7Ozs7OztXQWFHO1FBRUksY0FBUyxHQUFHLElBQUksWUFBWSxFQUF1QixDQUFDO1FBRTNEOzs7Ozs7Ozs7Ozs7O1dBYUc7UUFFSSxhQUFRLEdBQUcsSUFBSSxZQUFZLEVBQXNCLENBQUM7UUFFekQ7Ozs7Ozs7Ozs7Ozs7V0FhRztRQUVJLFlBQU8sR0FBRyxJQUFJLFlBQVksRUFBc0IsQ0FBQztRQUV4RDs7Ozs7Ozs7Ozs7OztXQWFHO1FBRUksY0FBUyxHQUFHLElBQUksWUFBWSxFQUFzQixDQUFDO1FBRTFEOzs7Ozs7Ozs7Ozs7O1dBYUc7UUFFSSxnQkFBVyxHQUFHLElBQUksWUFBWSxFQUEyQixDQUFDO1FBRWpFOzs7Ozs7Ozs7Ozs7O1dBYUc7UUFFSSxpQkFBWSxHQUFHLElBQUksWUFBWSxFQUEyQixDQUFDO1FBRWxFOzs7Ozs7Ozs7Ozs7O1dBYUc7UUFFSSxpQkFBWSxHQUFHLElBQUksWUFBWSxFQUFzQixDQUFDO1FBUTdEOztXQUVHO1FBRUksZ0JBQVcsR0FBRyxTQUFTLENBQUM7UUFFL0I7O1dBRUc7UUFFSSxjQUFTLEdBQUcsSUFBSSxDQUFDO1FBRXhCOztXQUVHO1FBRUksbUJBQWMsR0FBRyxLQUFLLENBQUM7UUE0SDlCOztXQUVHO1FBQ0ksMEJBQXFCLEdBQUcsTUFBTSxDQUFDO1FBT3RDOztXQUVHO1FBQ0ksbUJBQWMsR0FBRyxLQUFLLENBQUM7UUFFcEIsWUFBTyxHQUFHLENBQUMsQ0FBQztRQUNaLFlBQU8sR0FBRyxDQUFDLENBQUM7UUFDWixXQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQ1gsV0FBTSxHQUFHLENBQUMsQ0FBQztRQUNYLGlCQUFZLEdBQUcsS0FBSyxDQUFDO1FBU3JCLGdCQUFXLEdBQUcsQ0FBQyxDQUFDO1FBQ2hCLGdCQUFXLEdBQUcsQ0FBQyxDQUFDO1FBRWhCLG1CQUFjLEdBQUcsSUFBSSxDQUFDO1FBQ3RCLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFDakIsa0JBQWEsR0FBRyxJQUFJLENBQUM7UUFFckIsYUFBUSxHQUFHLElBQUksT0FBTyxFQUFXLENBQUM7UUFDbEMscUJBQWdCLEdBQUcsSUFBSSxDQUFDO0lBU2xDLENBQUM7SUE5VkQ7Ozs7Ozs7Ozs7T0FVRztJQUVILElBQVcsWUFBWSxDQUFDLEtBQUs7UUFDekIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRCxJQUFXLFlBQVk7UUFDbkIsT0FBTyxJQUFJLENBQUMsUUFBUSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQztJQUM5RSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUVILElBQVcsWUFBWSxDQUFDLEtBQUs7UUFDekIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRCxJQUFXLFlBQVk7UUFDbkIsT0FBTyxJQUFJLENBQUMsUUFBUSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBRTtJQUMvRSxDQUFDO0lBaUpEOzs7Ozs7Ozs7O09BVUc7SUFHSCxJQUFXLE9BQU8sQ0FBQyxRQUFRO1FBQ3ZCLElBQUksQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQztRQUNuRCxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBQzdCLENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSCxJQUFXLE9BQU87UUFDZCxPQUFPLElBQUksQ0FBQyxXQUFXLEtBQUssU0FBUyxDQUFDO0lBQzFDLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsUUFBUTtRQUNmLE9BQU8sSUFBSSxlQUFlLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBVyxjQUFjO1FBQ3JCLE9BQU8sSUFBSSxlQUFlLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDeEUsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBVyxvQkFBb0I7UUFDM0IsT0FBTyxPQUFPLFlBQVksS0FBSyxXQUFXLENBQUM7SUFDL0MsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBVyxrQkFBa0I7UUFDekIsT0FBTyxjQUFjLElBQUksTUFBTSxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsS0FBSztRQUNaLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ2pDLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztTQUN6QjtRQUNELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN6QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLEtBQUs7UUFDWixJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNqQyxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7U0FDeEI7UUFDRCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7SUFDeEIsQ0FBQztJQUVELElBQWMsUUFBUTtRQUNsQixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLHFCQUFxQixFQUFFLENBQUMsSUFBSSxDQUFDO0lBQ25FLENBQUM7SUFFRCxJQUFjLE9BQU87UUFDakIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLEdBQUcsQ0FBQztJQUNsRSxDQUFDO0lBRUQsSUFBYyxjQUFjO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDMUUsQ0FBQztJQUVELElBQWMsYUFBYTtRQUN2QixPQUFPLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFRCxJQUFjLFNBQVMsQ0FBQyxLQUFhO1FBQ2pDLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNuQixtSEFBbUg7WUFDbkgsTUFBTSxlQUFlLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLGFBQWEsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzlHLDhEQUE4RDtZQUM5RCxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxLQUFLLEdBQUcsZUFBZSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxJQUFJLENBQUM7U0FDdEY7SUFDTCxDQUFDO0lBRUQsSUFBYyxTQUFTO1FBQ25CLE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO0lBQ3pFLENBQUM7SUFFRCxJQUFjLFFBQVEsQ0FBQyxLQUFhO1FBQ2hDLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNuQixrSEFBa0g7WUFDbEgsTUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzVHLDhEQUE4RDtZQUM5RCxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQyxLQUFLLEdBQUcsY0FBYyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxJQUFJLENBQUM7U0FDcEY7SUFDTCxDQUFDO0lBRUQsSUFBYyxRQUFRO1FBQ2xCLE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO0lBQ3hFLENBQUM7SUFpREQ7O09BRUc7SUFDSSxrQkFBa0I7UUFDckIsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRztZQUNoRCxzRkFBc0Y7WUFDdEYsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7U0FDOUI7UUFFRCxjQUFjO1FBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUU7WUFDN0IsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUNoRSxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQzlGLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtnQkFDL0IsSUFBSSxJQUFJLENBQUMsb0JBQW9CLEVBQUU7b0JBQzNCLFNBQVMsQ0FBQyxPQUFPLEVBQUUsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7eUJBQy9ELFNBQVMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO29CQUU3QyxTQUFTLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FDbEMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsdUJBQXVCLENBQUMsQ0FBQyxFQUNwRCxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUMzQixDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO29CQUU5QyxTQUFTLENBQUMsT0FBTyxFQUFFLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO3lCQUN6RCxTQUFTLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztvQkFFL0MsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7d0JBQ2IsOEZBQThGO3dCQUM5RixTQUFTLENBQUMsT0FBTyxFQUFFLG9CQUFvQixDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7NkJBQ3RFLFNBQVMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO3FCQUNoRDtpQkFDSjtxQkFBTSxJQUFJLElBQUksQ0FBQyxrQkFBa0IsRUFBRTtvQkFDaEMsU0FBUyxDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzt5QkFDOUQsU0FBUyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7aUJBQ2hEO3FCQUFNO29CQUNILHdFQUF3RTtvQkFDeEUsU0FBUyxDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzt5QkFDN0QsU0FBUyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7aUJBQ2hEO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFFSCxnRkFBZ0Y7WUFDaEYsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7Z0JBQ3ZELFNBQVMsQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FDN0MsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsdUJBQXVCLENBQUMsQ0FBQyxFQUNwRCxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUMzQixDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUU5QyxTQUFTLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztxQkFDckUsU0FBUyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDbEQ7aUJBQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtnQkFDbkMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUM3QyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDLEVBQ3BELFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQzNCLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBRTlDLFNBQVMsQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO3FCQUNwRSxTQUFTLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzthQUNsRDtZQUVELElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFO2dCQUNsRSxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQy9CLENBQUMsQ0FBQyxDQUFDO1FBQ1AsQ0FBQyxDQUFDLENBQUM7UUFFSCwyR0FBMkc7UUFDM0csSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLGtCQUFrQixHQUFHLE1BQU0sQ0FBQztJQUNqRSxDQUFDO0lBRUQ7O09BRUc7SUFDSSxXQUFXO1FBQ2QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUV6QixJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7WUFDMUQsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUM1RCxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztTQUM1QjtJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDSSxXQUFXLENBQUMsV0FBNEI7UUFDM0MscUZBQXFGO1FBQ3JGLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ2pDLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsRixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDakYsSUFBSSxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUMsS0FBSyxHQUFHLFdBQVcsR0FBRyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztZQUM5RSxJQUFJLENBQUMsUUFBUSxHQUFHLFdBQVcsQ0FBQyxLQUFLLEdBQUcsV0FBVyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1NBQy9FO2FBQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDcEIsTUFBTSxNQUFNLEdBQUcsV0FBVyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1lBQzlDLE1BQU0sTUFBTSxHQUFHLFdBQVcsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztZQUM5QyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDbEUsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ2xFLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxHQUFHLE1BQU0sRUFBRSxVQUFVLEdBQUcsTUFBTSxDQUFDLENBQUM7U0FDakU7UUFFRCxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDN0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ2hDLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxrQkFBa0IsQ0FBQyxjQUEwQyxFQUFFLGFBQStCO1FBQ2pHLElBQUksQ0FBQyxDQUFDLENBQUMsYUFBYSxJQUFJLGFBQWEsQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDLGNBQWMsSUFBSSxhQUFhLENBQUMsS0FBSyxLQUFLLElBQUksQ0FBQyxjQUFjLENBQUM7WUFDL0csQ0FBQyxDQUFDLGFBQWEsSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFO1lBQ3RELE9BQU87U0FDVjtRQUVELElBQUksQ0FBQyxDQUFDLGFBQWEsSUFBSSxhQUFhLENBQUMsS0FBSyxLQUFLLElBQUksQ0FBQyxLQUFLLElBQUksYUFBYSxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQzdGLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQ2xDLElBQUksQ0FBQyxPQUFPLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQztnQkFDbkMsSUFBSSxDQUFDLE9BQU8sR0FBRyxhQUFhLENBQUMsS0FBSyxDQUFDO2dCQUNuQyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7Z0JBQ2pDLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztnQkFDakMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUNoRDtZQUVELElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7U0FDbkM7UUFFRCxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQztRQUMzQix1SEFBdUg7UUFDdkgsVUFBVSxDQUFDLEdBQUcsRUFBRTtZQUNaLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtnQkFDWixJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsR0FBRyxXQUFXLENBQUM7Z0JBQ3pELElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLGtCQUFrQjtvQkFDdEMsY0FBYyxJQUFJLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxRQUFRLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUU7Z0JBQzVHLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLHdCQUF3QjtvQkFDNUMsY0FBYyxJQUFJLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztnQkFDekYsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsZUFBZSxHQUFHLGNBQWMsSUFBSSxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO2dCQUNuSCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksZUFBZSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7YUFDdEU7aUJBQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7Z0JBQ3BCLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsR0FBRyxXQUFXLENBQUM7Z0JBQ2xFLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxrQkFBa0I7b0JBQy9DLGNBQWMsSUFBSSxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsUUFBUSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFFO2dCQUM1RyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsd0JBQXdCO29CQUNyRCxjQUFjLElBQUksY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO2dCQUN6RixJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsZUFBZSxHQUFHLGNBQWMsSUFBSSxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO2dCQUM1SCxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7Z0JBQzdCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztnQkFDNUIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDN0I7UUFDTCxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDVixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLFlBQVksQ0FBQyxNQUFvQyxFQUFFLGNBQTBDLEVBQUUsYUFBK0I7UUFDakksSUFBSSxDQUFDLENBQUMsYUFBYSxJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3JELElBQUksQ0FBQyxPQUFPLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQztZQUNuQyxJQUFJLENBQUMsT0FBTyxHQUFHLGFBQWEsQ0FBQyxLQUFLLENBQUM7WUFDbkMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztTQUNwQzthQUFNLElBQUksQ0FBQyxDQUFDLGFBQWEsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUU7WUFDOUQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUNuQzthQUFNLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDekMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1lBQzdCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztZQUM1QixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7WUFDOUQsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1NBQ2hFO1FBRUQsSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNsQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ2hEO1FBRUQsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7UUFDM0IsdUhBQXVIO1FBQ3ZILFVBQVUsQ0FBQyxHQUFHLEVBQUU7WUFDWixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQztZQUM5RSxTQUFTLENBQUMsS0FBSyxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUM7WUFDakcsU0FBUyxDQUFDLEtBQUssQ0FBQyxrQkFBa0I7Z0JBQzlCLGNBQWMsSUFBSSxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsUUFBUSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFFO1lBQzVHLFNBQVMsQ0FBQyxLQUFLLENBQUMsd0JBQXdCO2dCQUNwQyxjQUFjLElBQUksY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ3pGLFNBQVMsQ0FBQyxLQUFLLENBQUMsZUFBZSxHQUFHLGNBQWMsSUFBSSxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBRTNHLElBQUksTUFBTSxZQUFZLGVBQWUsRUFBRTtnQkFDbkMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLGVBQWUsQ0FBRSxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2FBQ3RFO2lCQUFNO2dCQUNILE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUMscUJBQXFCLEVBQUUsQ0FBQztnQkFDakUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLGVBQWUsQ0FDaEMsV0FBVyxDQUFDLElBQUksR0FBSSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsRUFDOUMsV0FBVyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FDOUMsQ0FBQyxDQUFDO2FBQ047UUFDTCxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDVixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLGFBQWEsQ0FBQyxLQUFLO1FBQ3RCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxjQUFjLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQztRQUV0Qyw2R0FBNkc7UUFDN0csTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLGFBQWEsS0FBSyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDMUcsTUFBTSxhQUFhLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUM7UUFDbkcsSUFBSSxJQUFJLENBQUMsb0JBQW9CLEVBQUU7WUFDM0IsYUFBYSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUN4RDthQUFNO1lBQ0gsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ3RCLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztTQUMxQjtRQUVELElBQUksSUFBSSxDQUFDLG9CQUFvQixJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixFQUFFO1lBQ3ZELDRHQUE0RztZQUM1RyxJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUM7WUFDM0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO1NBQzlCO2FBQU0sSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7WUFDaEMsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztZQUN0QyxJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO1NBQ3pDO1FBRUQsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7UUFDakYsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDL0UsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7UUFDckQsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7UUFDckQsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQzNCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUMvQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksYUFBYSxDQUFDLEtBQUs7UUFDdEIsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2YsSUFBSSxLQUFLLEVBQUUsS0FBSyxDQUFDO1lBQ2pCLElBQUksSUFBSSxDQUFDLG9CQUFvQixJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixFQUFFO2dCQUN2RCw0R0FBNEc7Z0JBQzVHLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO2dCQUNwQixLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQzthQUN2QjtpQkFBTSxJQUFJLElBQUksQ0FBQyxrQkFBa0IsRUFBRTtnQkFDaEMsS0FBSyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO2dCQUMvQixLQUFLLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7Z0JBRS9CLDRDQUE0QztnQkFDNUMsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO2FBQzFCO1lBRUQsTUFBTSxXQUFXLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7WUFDekMsTUFBTSxXQUFXLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7WUFDekMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZO2dCQUNsQixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLEdBQUcsSUFBSSxDQUFDLGFBQWEsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRTtnQkFDNUYsTUFBTSxhQUFhLEdBQXdCO29CQUN2QyxhQUFhLEVBQUUsS0FBSztvQkFDcEIsS0FBSyxFQUFFLElBQUk7b0JBQ1gsTUFBTSxFQUFFLEtBQUssR0FBRyxXQUFXO29CQUMzQixNQUFNLEVBQUUsS0FBSyxHQUFHLFdBQVc7b0JBQzNCLEtBQUssRUFBRSxLQUFLO29CQUNaLEtBQUssRUFBRSxLQUFLO29CQUNaLE1BQU0sRUFBRSxLQUFLO2lCQUNoQixDQUFDO2dCQUNGLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRTtvQkFDZixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztnQkFDdkMsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUU7b0JBQ3ZCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO29CQUN6QixJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7d0JBQ1osZ0ZBQWdGO3dCQUNoRixpRkFBaUY7d0JBQ2pGLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO3FCQUNsQzt5QkFBTSxJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssU0FBUyxJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssU0FBUyxFQUFFO3dCQUNuRSw2R0FBNkc7d0JBQzdHLE1BQU0sVUFBVSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDOzRCQUN2RixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7d0JBQ25ELE1BQU0sVUFBVSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDOzRCQUN2RixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7d0JBQ25ELElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxDQUFDO3FCQUMvQztpQkFDSjtxQkFBTTtvQkFDSCxPQUFPO2lCQUNWO2FBQ0o7aUJBQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQzNCLE9BQU87YUFDVjtZQUVELE1BQU0sUUFBUSxHQUF1QjtnQkFDakMsYUFBYSxFQUFFLEtBQUs7Z0JBQ3BCLEtBQUssRUFBRSxJQUFJO2dCQUNYLE1BQU0sRUFBRSxJQUFJLENBQUMsT0FBTztnQkFDcEIsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPO2dCQUNwQixLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU07Z0JBQ2xCLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTTtnQkFDbEIsU0FBUyxFQUFFLEtBQUs7Z0JBQ2hCLFNBQVMsRUFBRSxLQUFLO2dCQUNoQixNQUFNLEVBQUUsS0FBSzthQUNoQixDQUFDO1lBQ0YsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFN0IsTUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztZQUNwQyxNQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO1lBQ3BDLE1BQU0sYUFBYSxHQUFHLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1lBQzlDLE1BQU0sYUFBYSxHQUFHLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1lBRTlDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFO2dCQUNsQixJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7b0JBQ1osSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsWUFBWSxHQUFHLGFBQWEsQ0FBQztvQkFDbkQsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsWUFBWSxHQUFHLGFBQWEsQ0FBQztpQkFDckQ7cUJBQU07b0JBQ0gsTUFBTSxVQUFVLEdBQUcsUUFBUSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7b0JBQzFDLE1BQU0sVUFBVSxHQUFHLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO29CQUMxQyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEdBQUcsVUFBVSxDQUFDO29CQUMvRSxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEdBQUcsVUFBVSxDQUFDO29CQUMvRSxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQztpQkFDL0M7Z0JBQ0QsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7YUFDaEQ7WUFFRCxJQUFJLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQztZQUN2QixJQUFJLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQztTQUMxQjtJQUNMLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxXQUFXLENBQUMsS0FBSztRQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNoQixPQUFPO1NBQ1Y7UUFFRCxJQUFJLEtBQUssRUFBRSxLQUFLLENBQUM7UUFDakIsSUFBSSxJQUFJLENBQUMsb0JBQW9CLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLEVBQUU7WUFDdkQsNEdBQTRHO1lBQzVHLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO1lBQ3BCLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO1NBQ3ZCO2FBQU0sSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7WUFDaEMsS0FBSyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO1lBQy9CLEtBQUssR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztZQUUvQiw0Q0FBNEM7WUFDNUMsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO1NBQzFCO1FBRUQsTUFBTSxTQUFTLEdBQXVCO1lBQ2xDLGFBQWEsRUFBRSxLQUFLO1lBQ3BCLEtBQUssRUFBRSxJQUFJO1lBQ1gsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPO1lBQ3BCLE1BQU0sRUFBRSxJQUFJLENBQUMsT0FBTztZQUNwQixLQUFLLEVBQUUsS0FBSztZQUNaLEtBQUssRUFBRSxLQUFLO1NBQ2YsQ0FBQztRQUNGLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDO1FBQzNCLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3RCLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNuQixJQUFJLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLGFBQWEsS0FBSyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRztnQkFDMUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQzthQUMzRDtpQkFBTSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtnQkFDOUIsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7YUFDN0I7WUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUU7Z0JBQ2YsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDakMsQ0FBQyxDQUFDLENBQUM7WUFFSCxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRTtnQkFDdEIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM5QjtTQUNKO2FBQU07WUFDSCw4R0FBOEc7WUFDOUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFO2dCQUNmLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ25DLENBQUMsQ0FBQyxDQUFDO1NBQ047SUFDTCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksYUFBYSxDQUFDLEtBQUs7UUFDdEIsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDaEIsT0FBTztTQUNWO1FBRUQsTUFBTSxTQUFTLEdBQUc7WUFDZCxhQUFhLEVBQUUsS0FBSztZQUNwQixLQUFLLEVBQUUsSUFBSTtZQUNYLE1BQU0sRUFBRSxJQUFJLENBQUMsT0FBTztZQUNwQixNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU87WUFDcEIsS0FBSyxFQUFFLEtBQUssQ0FBQyxLQUFLO1lBQ2xCLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSztTQUNyQixDQUFDO1FBQ0YsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7UUFDM0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFDdEIsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRTtnQkFDZixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNqQyxDQUFDLENBQUMsQ0FBQztZQUNILElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFO2dCQUN2QixJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQzthQUM3QjtpQkFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRTtnQkFDN0IsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM5QjtTQUNKO0lBQ0wsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ08sV0FBVyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsT0FBWSxJQUFJO1FBQ2hELElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ2IsT0FBTztTQUNWO1FBRUQsSUFBSSxlQUFlLENBQUM7UUFDcEIsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ3BCLGVBQWUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQy9GLElBQUksQ0FBQyxZQUFZLEdBQUcsZUFBZSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNwRDthQUFNO1lBQ0gsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNoRztRQUVELE1BQU0sV0FBVyxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ3pDLE1BQU0sV0FBVyxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pGLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRWhGLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLGtCQUFrQixHQUFHLE1BQU0sQ0FBQztRQUNwRCxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDO1FBRzlDLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNqQixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUM5RDtRQUVELE1BQU0sZUFBZSxHQUFHO1lBQ3BCLEtBQUssRUFBRSxJQUFJO1lBQ1gsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZO1lBQy9CLE1BQU0sRUFBRSxLQUFLO1NBQ2hCLENBQUM7UUFDRixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUN2QyxJQUFJLGVBQWUsQ0FBQyxNQUFNLEVBQUU7WUFDeEIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7WUFDekIsSUFBSSxJQUFJLENBQUMsYUFBYSxJQUFJLGVBQWUsRUFBRTtnQkFDdkMsZUFBZSxDQUFDLE9BQU8sRUFBRSxDQUFDO2FBQzdCO1lBQ0QsT0FBTztTQUNWO1FBRUQsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2hCLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUNqRDthQUFNO1lBQ0gsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQ2hEO1FBRUQsTUFBTSxlQUFlLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLGFBQWEsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzlHLE1BQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUM1RyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBWSxHQUFHLGVBQWUsR0FBRyxXQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUM3RyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBWSxHQUFHLGNBQWMsR0FBRyxXQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUUzRyxJQUFJLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtZQUMzQixxRkFBcUY7WUFDckYsSUFBSSxJQUFJLENBQUMsY0FBYyxLQUFLLElBQUksRUFBRTtnQkFDOUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7YUFDNUQ7WUFDRCxJQUFJLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFO2dCQUN2RCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzdCLENBQUMsQ0FBQyxDQUFDO1lBQ0gsSUFBSSxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRTtnQkFDckQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMzQixDQUFDLENBQUMsQ0FBQztZQUNILElBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRTtnQkFDOUQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM3QixDQUFDLENBQUMsQ0FBQztTQUNOO1FBRUQsbUdBQW1HO1FBQ25HLElBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsZUFBZSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDekQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMvQixDQUFDLENBQUMsQ0FBQztRQUVILDJHQUEyRztRQUMzRyxJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDckIsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7U0FDeEI7UUFFRCxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBQzdCLENBQUM7SUFFRDs7O09BR0c7SUFDTyxrQkFBa0IsQ0FBQyxLQUFhLEVBQUUsS0FBYSxFQUFFLGFBQWE7UUFDcEUsSUFBSSxXQUFXLENBQUM7UUFDaEIsTUFBTSxlQUFlLEdBQThCO1lBQy9DLE1BQU0sRUFBRSxJQUFJLENBQUMsT0FBTztZQUNwQixNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU87WUFDcEIsS0FBSyxFQUFFLEtBQUs7WUFDWixLQUFLLEVBQUUsS0FBSztZQUNaLEtBQUssRUFBRSxJQUFJO1lBQ1gsYUFBYSxFQUFFLGFBQWE7U0FDL0IsQ0FBQztRQUVGLE1BQU0saUJBQWlCLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNoRSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsaUJBQWlCLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQy9DLElBQUksaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxLQUFLLE1BQU07Z0JBQ3pELGlCQUFpQixDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxZQUFZLElBQUksaUJBQWlCLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUU7Z0JBQ25HLFdBQVcsR0FBRyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDbkMsTUFBTTthQUNUO1NBQ0o7UUFFRCxJQUFJLFdBQVc7WUFDWCxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLGFBQWEsS0FBSyxXQUFXLENBQUMsQ0FBQyxFQUFFO1lBQ2pGLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtnQkFDcEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLGNBQWMsRUFBRSxlQUFlLENBQUMsQ0FBQzthQUMzRTtZQUVELElBQUksQ0FBQyxhQUFhLEdBQUcsV0FBVyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxjQUFjLEVBQUUsZUFBZSxDQUFDLENBQUM7U0FDM0U7YUFBTSxJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDM0MsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLGNBQWMsRUFBRSxlQUFlLENBQUMsQ0FBQztZQUN4RSxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQztZQUMxQixPQUFPO1NBQ1Y7UUFFTCxJQUFJLFdBQVcsRUFBRTtZQUNiLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFFLGFBQWEsRUFBRSxlQUFlLENBQUMsQ0FBQztTQUNuRTtJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBQ08saUJBQWlCLENBQUMsS0FBYSxFQUFFLEtBQWEsRUFBRSxhQUFhO1FBQ25FLE1BQU0sU0FBUyxHQUE4QjtZQUN6QyxNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU87WUFDcEIsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPO1lBQ3BCLEtBQUssRUFBRSxLQUFLO1lBQ1osS0FBSyxFQUFFLEtBQUs7WUFDWixLQUFLLEVBQUUsSUFBSTtZQUNYLGFBQWEsRUFBRSxhQUFhO1NBQy9CLENBQUM7UUFFRixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQzdELElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxjQUFjLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDbEUsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7SUFDOUIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksZUFBZSxDQUFDLEtBQUs7UUFDeEIsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQy9ELHVFQUF1RTtZQUN2RSxPQUFRO1NBQ1g7UUFFRCxJQUFJLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNqQyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7WUFDL0QsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1lBRTdELE1BQU0sZ0JBQWdCLEdBQTRCO2dCQUM5QyxLQUFLLEVBQUUsSUFBSTtnQkFDWCxZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVk7Z0JBQy9CLE1BQU0sRUFBRSxLQUFLO2FBQ2hCLENBQUM7WUFDRixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQ3pDLElBQUksZ0JBQWdCLENBQUMsTUFBTSxFQUFFO2dCQUN6QixPQUFPO2FBQ1Y7WUFFRCxJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7Z0JBQ3JCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO2FBQ3ZCO1lBQ0QsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUM1RCxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztTQUM1QjthQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ3BCLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsR0FBRyxFQUFFLENBQUM7WUFDekQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLGtCQUFrQixHQUFHLE1BQU0sQ0FBQztZQUM3RCxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsd0JBQXdCLEdBQUcsRUFBRSxDQUFDO1lBQy9ELElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsRUFBRSxDQUFDO1NBQ3pEO1FBQ0QsSUFBSSxDQUFDLGNBQWMsR0FBRyxLQUFLLENBQUM7UUFDNUIsSUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7UUFFMUIsNkhBQTZIO1FBQzdILElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRTtZQUNmLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDO2dCQUNuQixhQUFhLEVBQUUsS0FBSztnQkFDcEIsS0FBSyxFQUFFLElBQUk7Z0JBQ1gsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPO2dCQUNwQixNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU87Z0JBQ3BCLEtBQUssRUFBRSxJQUFJLENBQUMsT0FBTztnQkFDbkIsS0FBSyxFQUFFLElBQUksQ0FBQyxPQUFPO2FBQ3RCLENBQUMsQ0FBQztRQUNQLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVEOztPQUVHO0lBQ08sa0JBQWtCLENBQUMsS0FBYSxFQUFFLEtBQWE7UUFDckQsb0VBQW9FO1FBQ3BFLDJFQUEyRTtRQUMzRSx1REFBdUQ7UUFDdkQsaURBQWlEO1FBQ2pELE1BQU0sU0FBUyxHQUFHLEtBQUssR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDO1FBQzdDLE1BQU0sU0FBUyxHQUFHLEtBQUssR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDO1FBQzdDLElBQUksUUFBUSxDQUFDLHFCQUFxQixDQUFDLEVBQUU7WUFDakMsaUNBQWlDO1lBQ2pDLE1BQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUN2RSxPQUFPLFFBQVEsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO1NBQzVDO2FBQU07WUFDSCw2Q0FBNkM7WUFDN0MsT0FBTyxRQUFRLENBQUMsaUJBQWlCLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1NBQzNEO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ08sYUFBYSxDQUFDLE1BQU0sRUFBRSxTQUFpQixFQUFFLFNBQW9DO1FBQ25GLCtCQUErQjtRQUMvQixNQUFNLGNBQWMsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQzNELGNBQWMsQ0FBQyxlQUFlLENBQUMsU0FBUyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDbkUsTUFBTSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUNyQyx1RkFBdUY7SUFDM0YsQ0FBQztJQUVTLGFBQWEsQ0FBQyxJQUFJO1FBQ3hCLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQztRQUNiLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUU7WUFDdEIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUM7WUFDcEMsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7WUFDL0QsSUFBSSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBRSxDQUFDLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDM0M7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRVMsYUFBYSxDQUFDLElBQUk7UUFDeEIsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ2IsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRTtZQUN0QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQztZQUNwQyxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztZQUMvRCxJQUFJLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFFLENBQUMsQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMzQztRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxtRUFBbUU7SUFDekQsY0FBYyxDQUFDLENBQVMsRUFBRSxDQUFTO1FBQ3pDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsY0FBYyxHQUFHLENBQUMsR0FBRyxNQUFNLEdBQUcsQ0FBQyxHQUFHLFVBQVUsQ0FBQztJQUM5RixDQUFDO0lBRVMsa0JBQWtCO1FBQ3hCLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzRixDQUFDO0lBRVMsbUJBQW1CO1FBQ3pCLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzRixDQUFDO0lBRVMsbUJBQW1CLENBQUMsU0FBYztRQUN4QyxNQUFNLGFBQWEsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3BHLElBQUksYUFBYSxLQUFLLFFBQVEsSUFBSSxTQUFTLENBQUMsWUFBWSxJQUFJLFNBQVMsQ0FBQyxZQUFZLEtBQUssUUFBUSxDQUFDLElBQUksRUFBRTtZQUNsRyxPQUFPLENBQUMsQ0FBQztTQUNaO2FBQU0sSUFBSSxhQUFhLEtBQUssUUFBUSxJQUFJLFNBQVMsQ0FBQyxZQUFZLEVBQUU7WUFDN0QsT0FBTyxTQUFTLENBQUMsWUFBWSxDQUFDLHFCQUFxQixFQUFFLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1NBQzNGO1FBQ0QsT0FBTyxTQUFTLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7SUFDL0UsQ0FBQztJQUVTLGtCQUFrQixDQUFDLFNBQWM7UUFDdkMsTUFBTSxhQUFhLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNwRyxJQUFJLGFBQWEsS0FBSyxRQUFRLElBQUksU0FBUyxDQUFDLFlBQVksSUFBSSxTQUFTLENBQUMsWUFBWSxLQUFLLFFBQVEsQ0FBQyxJQUFJLEVBQUU7WUFDbEcsT0FBTyxDQUFDLENBQUM7U0FDWjthQUFNLElBQUksYUFBYSxLQUFLLFFBQVEsSUFBSSxTQUFTLENBQUMsWUFBWSxFQUFFO1lBQzdELE9BQU8sU0FBUyxDQUFDLFlBQVksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztTQUN6RjtRQUNELE9BQU8sU0FBUyxDQUFDLHFCQUFxQixFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO0lBQzdFLENBQUM7Q0FDSixDQUFBOztZQXB0Qm1CLGlCQUFpQjtZQUNiLFVBQVU7WUFDSixnQkFBZ0I7WUFDekIsTUFBTTtZQUNGLFNBQVM7O0FBdGQ5QjtJQURDLEtBQUssQ0FBQyxTQUFTLENBQUM7OENBQ0E7QUFhakI7SUFEQyxLQUFLLEVBQUU7dURBQ2lCO0FBZ0J6QjtJQURDLEtBQUssRUFBRTtxREFDa0Q7QUFjMUQ7SUFEQyxLQUFLLEVBQUU7K0NBQ1k7QUFZcEI7SUFEQyxLQUFLLEVBQUU7b0RBQ2U7QUFnQnZCO0lBSEMsaUJBQWlCLENBQUM7d0ZBQ2lFLENBQUM7SUFDcEYsS0FBSyxFQUFFO3dEQUNzQjtBQWlCOUI7SUFIQyxpQkFBaUIsQ0FBQzsyRUFDb0QsQ0FBQztJQUN2RSxLQUFLLEVBQUU7MERBQ3dCO0FBa0JoQztJQURDLEtBQUssRUFBRTt1REFDK0I7QUFjdkM7SUFEQyxLQUFLLEVBQUU7bURBQ1M7QUFjakI7SUFEQyxLQUFLLEVBQUU7b0RBR1A7QUFrQkQ7SUFEQyxLQUFLLEVBQUU7b0RBR1A7QUFxQkQ7SUFEQyxNQUFNLEVBQUU7bURBQ2tEO0FBaUIzRDtJQURDLE1BQU0sRUFBRTtrREFDZ0Q7QUFpQnpEO0lBREMsTUFBTSxFQUFFO2lEQUMrQztBQWlCeEQ7SUFEQyxNQUFNLEVBQUU7bURBQ2lEO0FBaUIxRDtJQURDLE1BQU0sRUFBRTtxREFDd0Q7QUFpQmpFO0lBREMsTUFBTSxFQUFFO3NEQUN5RDtBQWlCbEU7SUFEQyxNQUFNLEVBQUU7c0RBQ29EO0FBTTdEO0lBREMsZUFBZSxDQUFDLHNCQUFzQixDQUFDO3FEQUNjO0FBTXREO0lBREMsV0FBVyxDQUFDLGtCQUFrQixDQUFDO3FEQUNEO0FBTS9CO0lBREMsV0FBVyxDQUFDLGdCQUFnQixDQUFDO21EQUNOO0FBTXhCO0lBREMsV0FBVyxDQUFDLGlDQUFpQyxDQUFDO3dEQUNqQjtBQWU5QjtJQUZDLGlCQUFpQixDQUFDO2lGQUMwRCxDQUFDOytDQUk3RTtBQTdVUSxnQkFBZ0I7SUFKNUIsU0FBUyxDQUFDO1FBQ1AsUUFBUSxFQUFFLE1BQU07UUFDaEIsUUFBUSxFQUFFLFdBQVc7S0FDeEIsQ0FBQztHQUNXLGdCQUFnQixDQWtyQzVCO1NBbHJDWSxnQkFBZ0I7QUF3ckM3QixJQUFhLGdCQUFnQixHQUE3QixNQUFhLGdCQUFnQjtJQThJekIsWUFBbUIsT0FBbUIsRUFBVSxTQUFvQixFQUFVLEtBQWE7UUFBeEUsWUFBTyxHQUFQLE9BQU8sQ0FBWTtRQUFVLGNBQVMsR0FBVCxTQUFTLENBQVc7UUFBVSxVQUFLLEdBQUwsS0FBSyxDQUFRO1FBaEYzRjs7Ozs7Ozs7Ozs7V0FXRztRQUVJLFVBQUssR0FBRyxJQUFJLFlBQVksRUFBc0IsQ0FBQztRQUVsRDs7Ozs7Ozs7Ozs7T0FXRDtRQUVJLFNBQUksR0FBRyxJQUFJLFlBQVksRUFBc0IsQ0FBQztRQUVyRDs7Ozs7Ozs7Ozs7V0FXRztRQUVJLFVBQUssR0FBRyxJQUFJLFlBQVksRUFBc0IsQ0FBQztRQUV0RDs7Ozs7Ozs7Ozs7OztXQWFHO1FBRUksWUFBTyxHQUFHLElBQUksWUFBWSxFQUF5QixDQUFDO1FBRTNEOztXQUVHO1FBRUksY0FBUyxHQUFHLElBQUksQ0FBQztRQUV4Qjs7V0FFRztRQUVJLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFFeEI7O1dBRUc7UUFDTyxhQUFRLEdBQUcsSUFBSSxPQUFPLEVBQVcsQ0FBQztRQUl4QyxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksc0JBQXNCLEVBQUUsQ0FBQztJQUN0RCxDQUFDO0lBcEhEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F3Qkc7SUFFSCxJQUFXLFlBQVksQ0FBQyxRQUFhO1FBQ2pDLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFRCxJQUFXLFlBQVk7UUFDbkIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO0lBQzlCLENBQUM7SUFzRkQ7O09BRUc7SUFDSSxRQUFRO1FBQ1gsSUFBSSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEVBQUU7WUFDOUIsU0FBUyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLGNBQWMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2lCQUMvRSxTQUFTLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBNkMsQ0FBQyxDQUFDLENBQUM7WUFFekYsU0FBUyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLGNBQWMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDL0gsU0FBUyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDakksQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxXQUFXO1FBQ2QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBRUQ7O09BRUc7SUFDSSxVQUFVLENBQUMsS0FBSztRQUNuQixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUN6RyxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUN2RyxNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxXQUFXLENBQUM7UUFDakQsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsV0FBVyxDQUFDO1FBQ2pELE1BQU0sU0FBUyxHQUF1QjtZQUNsQyxhQUFhLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxhQUFhO1lBQ3pDLEtBQUssRUFBRSxJQUFJO1lBQ1gsSUFBSSxFQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSztZQUN4QixRQUFRLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSTtZQUNqQyxNQUFNLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNO1lBQzNCLE1BQU0sRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU07WUFDM0IsS0FBSyxFQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSztZQUN6QixLQUFLLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLO1lBQ3pCLE9BQU8sRUFBRSxPQUFPO1lBQ2hCLE9BQU8sRUFBRSxPQUFPO1NBQ25CLENBQUM7UUFFRixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUY7O09BRUc7SUFDSSxXQUFXLENBQUMsS0FBNkM7UUFDNUQsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN4QyxPQUFPO1NBQ1Y7UUFFRCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztRQUNyQixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUN6RyxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUN2RyxNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxXQUFXLENBQUM7UUFDakQsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsV0FBVyxDQUFDO1FBQ2pELE1BQU0sU0FBUyxHQUF1QjtZQUNsQyxhQUFhLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxhQUFhO1lBQ3pDLEtBQUssRUFBRSxJQUFJO1lBQ1gsSUFBSSxFQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSztZQUN4QixRQUFRLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSTtZQUNqQyxNQUFNLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNO1lBQzNCLE1BQU0sRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU07WUFDM0IsS0FBSyxFQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSztZQUN6QixLQUFLLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLO1lBQ3pCLE9BQU8sRUFBRSxPQUFPO1lBQ2hCLE9BQU8sRUFBRSxPQUFPO1NBQ25CLENBQUM7UUFDRixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUU7WUFDaEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDL0IsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxXQUFXLENBQUMsS0FBSztRQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3hDLE9BQU87U0FDVjtRQUVELElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3RCLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLHFCQUFxQixFQUFFLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1FBQ3pHLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLHFCQUFxQixFQUFFLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQ3ZHLE1BQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLFdBQVcsQ0FBQztRQUNqRCxNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxXQUFXLENBQUM7UUFDakQsTUFBTSxTQUFTLEdBQXVCO1lBQ2xDLGFBQWEsRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLGFBQWE7WUFDekMsS0FBSyxFQUFFLElBQUk7WUFDWCxJQUFJLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLO1lBQ3hCLFFBQVEsRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJO1lBQ2pDLE1BQU0sRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU07WUFDM0IsTUFBTSxFQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTTtZQUMzQixLQUFLLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLO1lBQ3pCLEtBQUssRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUs7WUFDekIsT0FBTyxFQUFFLE9BQU87WUFDaEIsT0FBTyxFQUFFLE9BQU87U0FDbkIsQ0FBQztRQUNGLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRTtZQUNoQixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMvQixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7T0FFRztJQUVJLFVBQVUsQ0FBQyxLQUFLO1FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDeEMsT0FBTztTQUNWO1FBRUQsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7UUFDekcsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDdkcsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsV0FBVyxDQUFDO1FBQ2pELE1BQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLFdBQVcsQ0FBQztRQUNqRCxNQUFNLElBQUksR0FBMEI7WUFDaEMsS0FBSyxFQUFFLElBQUk7WUFDWCxhQUFhLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxhQUFhO1lBQ3pDLElBQUksRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUs7WUFDeEIsUUFBUSxFQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUk7WUFDakMsTUFBTSxFQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTTtZQUMzQixNQUFNLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNO1lBQzNCLEtBQUssRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUs7WUFDekIsS0FBSyxFQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSztZQUN6QixPQUFPLEVBQUUsT0FBTztZQUNoQixPQUFPLEVBQUUsT0FBTztZQUNoQixNQUFNLEVBQUUsS0FBSztTQUNoQixDQUFDO1FBQ0YsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFO1lBQ2hCLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVCLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxJQUFJLENBQUMsYUFBYSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNwQyxNQUFNLGVBQWUsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3RHLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxlQUFlLENBQUMsQ0FBQztZQUMvRSxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUM7U0FDeEU7SUFDTCxDQUFDO0lBRVMsa0JBQWtCO1FBQ3hCLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzRixDQUFDO0lBRVMsbUJBQW1CO1FBQ3pCLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzRixDQUFDO0lBRVMsWUFBWSxDQUFDLElBQXNCO1FBQ3pDLE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxXQUFXLFlBQVksS0FBSyxDQUFDO1FBQ3hELE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxXQUFXLFlBQVksS0FBSyxDQUFDO1FBRXhELElBQUksQ0FBQyxhQUFhLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDbEMsT0FBTyxJQUFJLENBQUMsV0FBVyxLQUFLLElBQUksQ0FBQyxXQUFXLENBQUM7U0FDaEQ7YUFBTSxJQUFJLENBQUMsYUFBYSxJQUFJLGFBQWEsRUFBRTtZQUN4QyxNQUFNLFNBQVMsR0FBZSxJQUFJLENBQUMsV0FBVyxDQUFDO1lBQy9DLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRyxFQUFFO2dCQUN4QyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsV0FBVyxFQUFFO29CQUNuQyxPQUFPLElBQUksQ0FBQztpQkFDZjthQUNKO1NBQ0o7YUFBTSxJQUFJLGFBQWEsSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUN4QyxNQUFNLFNBQVMsR0FBZSxJQUFJLENBQUMsV0FBVyxDQUFDO1lBQy9DLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRyxFQUFFO2dCQUN4QyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsV0FBVyxFQUFFO29CQUNuQyxPQUFPLElBQUksQ0FBQztpQkFDZjthQUNKO1NBQ0o7YUFBTTtZQUNILE1BQU0sU0FBUyxHQUFlLElBQUksQ0FBQyxXQUFXLENBQUM7WUFDL0MsTUFBTSxTQUFTLEdBQWUsSUFBSSxDQUFDLFdBQVcsQ0FBQztZQUMvQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUcsRUFBRTtnQkFDeEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFHLEVBQUU7b0JBQ3hDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRTt3QkFDL0IsT0FBTyxJQUFJLENBQUM7cUJBQ2Y7aUJBQ0o7YUFDSjtTQUNKO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQztJQUVTLGdCQUFnQixDQUFDLFVBQTRCLEVBQUUsZUFBc0I7UUFDM0UsSUFBSSxXQUFXLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDckIsTUFBTSxZQUFZLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3JGLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFO1lBQ3RCLE9BQU8sV0FBVyxDQUFDO1NBQ3RCO1FBRUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDO1FBQ3RCLE9BQU8sQ0FBQyxVQUFVLElBQUksQ0FBQyxHQUFHLGVBQWUsQ0FBQyxNQUFNLEVBQUU7WUFDOUMsSUFBSSxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxLQUFLLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFO2dCQUNqRSxVQUFVLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ25DO1lBQ0QsQ0FBQyxFQUFFLENBQUM7U0FDUDtRQUVELE1BQU0sZ0JBQWdCLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ2hGLFdBQVcsR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQy9DLElBQUksZ0JBQWdCLEtBQUssQ0FBQyxDQUFDLElBQUksZ0JBQWdCLEdBQUcsV0FBVyxFQUFFO1lBQzNELFdBQVcsRUFBRSxDQUFDO1NBQ2pCO1FBRUQsT0FBTyxXQUFXLENBQUM7SUFDdkIsQ0FBQztDQUNKLENBQUE7O1lBck4rQixVQUFVO1lBQXFCLFNBQVM7WUFBaUIsTUFBTTs7QUFwSTNGO0lBREMsS0FBSyxDQUFDLFNBQVMsQ0FBQzs4Q0FDQTtBQWdCakI7SUFEQyxLQUFLLEVBQUU7cURBQ2tEO0FBNEIxRDtJQURDLEtBQUssRUFBRTtvREFHUDtBQW1CRDtJQURDLE1BQU0sRUFBRTsrQ0FDNkM7QUFldEQ7SUFEQyxNQUFNLEVBQUU7OENBQzRDO0FBZXJEO0lBREMsTUFBTSxFQUFFOytDQUM2QztBQWlCdEQ7SUFEQyxNQUFNLEVBQUU7aURBQ2tEO0FBTTNEO0lBREMsV0FBVyxDQUFDLGdCQUFnQixDQUFDO21EQUNOO0FBTXhCO0lBREMsV0FBVyxDQUFDLGdCQUFnQixDQUFDO2tEQUNOO0FBeUh4QjtJQURDLFlBQVksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztrREFnQ25DO0FBOVJRLGdCQUFnQjtJQUo1QixTQUFTLENBQUM7UUFDUCxRQUFRLEVBQUUsTUFBTTtRQUNoQixRQUFRLEVBQUUsV0FBVztLQUN4QixDQUFDO0dBQ1csZ0JBQWdCLENBbVc1QjtTQW5XWSxnQkFBZ0I7QUFzVzdCOztHQUVHO0FBS0gsSUFBYSxpQkFBaUIsR0FBOUIsTUFBYSxpQkFBaUI7Q0FBSSxDQUFBO0FBQXJCLGlCQUFpQjtJQUo3QixRQUFRLENBQUM7UUFDTixZQUFZLEVBQUUsQ0FBQyxnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBRSxzQkFBc0IsQ0FBQztRQUMxRSxPQUFPLEVBQUUsQ0FBQyxnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBRSxzQkFBc0IsQ0FBQztLQUN4RSxDQUFDO0dBQ1csaUJBQWlCLENBQUk7U0FBckIsaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsi77u/aW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSG9zdExpc3RlbmVyLFxuICAgIElucHV0LFxuICAgIE5nTW9kdWxlLFxuICAgIE5nWm9uZSxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIE91dHB1dCxcbiAgICBSZW5kZXJlcjIsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgVmlld0NvbnRhaW5lclJlZixcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIENvbnRlbnRDaGlsZHJlbixcbiAgICBRdWVyeUxpc3Rcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBhbmltYXRpb25GcmFtZVNjaGVkdWxlciwgZnJvbUV2ZW50LCBpbnRlcnZhbCwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsLCB0aHJvdHRsZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElneERyYWdIYW5kbGVEaXJlY3RpdmUgfSBmcm9tICcuL2RyYWctaGFuZGxlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBEZXByZWNhdGVQcm9wZXJ0eSB9IGZyb20gJy4uLy4uL2NvcmUvZGVwcmVjYXRlRGVjb3JhdG9ycyc7XG5pbXBvcnQgeyBJQmFzZUV2ZW50QXJncyB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSURyb3BTdHJhdGVneSwgSWd4RGVmYXVsdERyb3BTdHJhdGVneSB9IGZyb20gJy4vZHJhZy1kcm9wLnN0cmF0ZWd5JztcblxuZXhwb3J0IGVudW0gUmVzdHJpY3REcmFnIHtcbiAgICBWRVJUSUNBTExZLFxuICAgIEhPUklaT05UQUxMWSxcbiAgICBOT05FXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscyB7XG4gICAgc3RhcnRYOiBudW1iZXI7XG4gICAgc3RhcnRZOiBudW1iZXI7XG4gICAgcGFnZVg6IG51bWJlcjtcbiAgICBwYWdlWTogbnVtYmVyO1xuICAgIG93bmVyOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgIG9yaWdpbmFsRXZlbnQ6IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRHJvcEJhc2VFdmVudEFyZ3MgZXh0ZW5kcyBJQmFzZUV2ZW50QXJncyB7XG4gICAgICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgZXZlbnQgdGhhdCBjYXVzZWQgdGhlIGRyYWdnYWJsZSBlbGVtZW50IHRvIGVudGVyIHRoZSBpZ3hEcm9wIGVsZW1lbnQuXG4gICAgICogQ2FuIGJlIFBvaW50ZXJFdmVudCwgVG91Y2hFdmVudCBvciBNb3VzZUV2ZW50LlxuICAgICAqL1xuICAgIG9yaWdpbmFsRXZlbnQ6IGFueTtcbiAgICAvKiogVGhlIG93bmVyIGlneERyb3AgZGlyZWN0aXZlIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuICovXG4gICAgb3duZXI6IElneERyb3BEaXJlY3RpdmU7XG4gICAgLyoqIFRoZSBpZ3hEcmFnIGRpcmVjdGl2ZSBpbnN0YW5jZWQgb24gYW4gZWxlbWVudCB0aGF0IGVudGVyZWQgdGhlIGFyZWEgb2YgdGhlIGlneERyb3AgZWxlbWVudCAqL1xuICAgIGRyYWc6IElneERyYWdEaXJlY3RpdmU7XG4gICAgLyoqIFRoZSBkYXRhIGNvbnRhaW5lZCBmb3IgdGhlIGRyYWdnYWJsZSBlbGVtZW50IGluIGlneERyYWcgZGlyZWN0aXZlLiAqL1xuICAgIGRyYWdEYXRhOiBhbnk7XG4gICAgLyoqIFRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFggYXhpcyB3aGVuIHRoZSBkcmFnZ2VkIGVsZW1lbnQgYmVnYW4gbW92aW5nICovXG4gICAgc3RhcnRYOiBudW1iZXI7XG4gICAgLyoqIFRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFkgYXhpcyB3aGVuIHRoZSBkcmFnZ2VkIGVsZW1lbnQgYmVnYW4gbW92aW5nICovXG4gICAgc3RhcnRZOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWCBheGlzIHdoZW4gdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQuXG4gICAgICogTm90ZTogVGhlIGJyb3dzZXIgbWlnaHQgdHJpZ2dlciB0aGUgZXZlbnQgd2l0aCBzb21lIGRlbGF5IGFuZCBwb2ludGVyIHdvdWxkIGJlIGFscmVhZHkgaW5zaWRlIHRoZSBpZ3hEcm9wLlxuICAgICAqL1xuICAgIHBhZ2VYOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWSBheGlzIHdoZW4gdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQuXG4gICAgICogTm90ZTogVGhlIGJyb3dzZXIgbWlnaHQgdHJpZ2dlciB0aGUgZXZlbnQgd2l0aCBzb21lIGRlbGF5IGFuZCBwb2ludGVyIHdvdWxkIGJlIGFscmVhZHkgaW5zaWRlIHRoZSBpZ3hEcm9wLlxuICAgICAqL1xuICAgIHBhZ2VZOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWCBheGlzIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgdGhhdCBpbml0aWFsaXplcyB0aGUgaWd4RHJvcC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgb2Zmc2V0WDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFkgYXhpcyByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIGlneERyb3AuXG4gICAgICogTm90ZTogVGhlIGJyb3dzZXIgbWlnaHQgdHJpZ2dlciB0aGUgZXZlbnQgd2l0aCBzb21lIGRlbGF5IGFuZCBwb2ludGVyIHdvdWxkIGJlIGFscmVhZHkgaW5zaWRlIHRoZSBpZ3hEcm9wLlxuICAgICAqL1xuICAgIG9mZnNldFk6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRHJvcERyb3BwZWRFdmVudEFyZ3MgZXh0ZW5kcyBJRHJvcEJhc2VFdmVudEFyZ3Mge1xuICAgIC8qKiBTcGVjaWZpZXMgaWYgdGhlIGRlZmF1bHQgZHJvcCBsb2dpYyByZWxhdGVkIHRvIHRoZSBldmVudCBzaG91bGQgYmUgY2FuY2VsZWQuICovXG4gICAgY2FuY2VsOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEcmFnQmFzZUV2ZW50QXJncyBleHRlbmRzIElCYXNlRXZlbnRBcmdzIHtcbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIGV2ZW50IHRoYXQgY2F1c2VkIHRoZSBpbnRlcmFjdGlvbiB3aXRoIHRoZSBlbGVtZW50LlxuICAgICAqIENhbiBiZSBQb2ludGVyRXZlbnQsIFRvdWNoRXZlbnQgb3IgTW91c2VFdmVudC5cbiAgICAgKi9cbiAgICBvcmlnaW5hbEV2ZW50OiBQb2ludGVyRXZlbnQgfCBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudDtcbiAgICAvKiogVGhlIG93bmVyIGlneERyYWcgZGlyZWN0aXZlIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuICovXG4gICAgb3duZXI6IElneERyYWdEaXJlY3RpdmU7XG4gICAgLyoqIFRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFggYXhpcyB3aGVuIHRoZSBkcmFnZ2VkIGVsZW1lbnQgYmVnYW4gbW92aW5nICovXG4gICAgc3RhcnRYOiBudW1iZXI7XG4gICAgLyoqIFRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFkgYXhpcyB3aGVuIHRoZSBkcmFnZ2VkIGVsZW1lbnQgYmVnYW4gbW92aW5nICovXG4gICAgc3RhcnRZOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWCBheGlzIHdoZW4gdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQuXG4gICAgICogTm90ZTogVGhlIGJyb3dzZXIgbWlnaHQgdHJpZ2dlciB0aGUgZXZlbnQgd2l0aCBzb21lIGRlbGF5IGFuZCBwb2ludGVyIHdvdWxkIGJlIGFscmVhZHkgaW5zaWRlIHRoZSBpZ3hEcm9wLlxuICAgICAqL1xuICAgIHBhZ2VYOiBudW1iZXI7XG4gICAgICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFkgYXhpcyB3aGVuIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgICAqIE5vdGU6IFRoZSBicm93c2VyIG1pZ2h0IHRyaWdnZXIgdGhlIGV2ZW50IHdpdGggc29tZSBkZWxheSBhbmQgcG9pbnRlciB3b3VsZCBiZSBhbHJlYWR5IGluc2lkZSB0aGUgaWd4RHJvcC5cbiAgICAgKi9cbiAgICBwYWdlWTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEcmFnU3RhcnRFdmVudEFyZ3MgZXh0ZW5kcyBJRHJhZ0Jhc2VFdmVudEFyZ3Mge1xuICAgIC8qKiBTZXQgaWYgdGhlIHRoZSBkcmFnZ2luZyBzaG91bGQgYmUgY2FuY2VsZWQuICovXG4gICAgY2FuY2VsOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEcmFnTW92ZUV2ZW50QXJncyBleHRlbmRzIElEcmFnU3RhcnRFdmVudEFyZ3Mge1xuICAgIC8qKiBUaGUgbmV3IHBhZ2VYIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIHRoYXQgdGhlIGlneERyYWcgd2lsbCB1c2UuIEl0IGNhbiBiZSBvdmVycmlkZGVuIHRvIGxpbWl0IGRyYWdnZWQgZWxlbWVudCBYIG1vdmVtZW50LiAqL1xuICAgIG5leHRQYWdlWDogbnVtYmVyO1xuICAgIC8qKiBUaGUgbmV3IHBhZ2VYIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIHRoYXQgdGhlIGlneERyYWcgd2lsbCB1c2UuIEl0IGNhbiBiZSBvdmVycmlkZGVuIHRvIGxpbWl0IGRyYWdnZWQgZWxlbWVudCBZIG1vdmVtZW50LiAqL1xuICAgIG5leHRQYWdlWTogbnVtYmVyO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgSURyYWdHaG9zdEJhc2VFdmVudEFyZ3MgZXh0ZW5kcyBJQmFzZUV2ZW50QXJncyB7XG4gICAgLyoqIFRoZSBvd25lciBpZ3hEcmFnIGRpcmVjdGl2ZSB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LiAqL1xuICAgIG93bmVyOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgIC8qKiBJbnN0YW5jZSB0byB0aGUgZ2hvc3QgZWxlbWVudCB0aGF0IGlzIGNyZWF0ZWQgd2hlbiBkcmFnZ2luZyBzdGFydHMuICovXG4gICAgZ2hvc3RFbGVtZW50OiBhbnk7XG4gICAgLyoqIFNldCBpZiB0aGUgZ2hvc3QgY3JlYXRpb24vZGVzdHJ1Y3Rpb24gc2hvdWxkIGJlIGNhbmNlbGVkLiAqL1xuICAgIGNhbmNlbDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRHJhZ0N1c3RvbVRyYW5zaXRpb25BcmdzIHtcbiAgICBkdXJhdGlvbj86IG51bWJlcjtcbiAgICB0aW1pbmdGdW5jdGlvbj86IHN0cmluZztcbiAgICBkZWxheT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIElneERyYWdMb2NhdGlvbiB7XG4gICAgcHVibGljIHBhZ2VYOiBudW1iZXI7XG4gICAgcHVibGljIHBhZ2VZOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYWdlWCwgcHJpdmF0ZSBfcGFnZVkpIHtcbiAgICAgICAgdGhpcy5wYWdlWCA9IHBhcnNlRmxvYXQoX3BhZ2VYKTtcbiAgICAgICAgdGhpcy5wYWdlWSA9IHBhcnNlRmxvYXQoX3BhZ2VZKTtcbiAgICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIGV4cG9ydEFzOiAnZHJhZycsXG4gICAgc2VsZWN0b3I6ICdbaWd4RHJhZ10nXG59KVxuZXhwb3J0IGNsYXNzIElneERyYWdEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgcHJvdGVjdGVkIGdob3N0Q29udGV4dDogYW55ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIC0gU2F2ZSBkYXRhIGluc2lkZSB0aGUgYGlneERyYWdgIGRpcmVjdGl2ZS4gVGhpcyBjYW4gYmUgc2V0IHdoZW4gaW5zdGFuY2luZyBgaWd4RHJhZ2Agb24gYW4gZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBbaWd4RHJhZ109XCJ7IHNvdXJjZTogbXlFbGVtZW50IH1cIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgnaWd4RHJhZycpXG4gICAgcHVibGljIGRhdGE6IGFueTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IGluZGljYXRlcyB3aGVuIHRoZSBkcmFnIHNob3VsZCBzdGFydC5cbiAgICAgKiBCeSBkZWZhdWx0IHRoZSBkcmFnIHN0YXJ0cyBhZnRlciB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgbW92ZWQgYnkgNXB4LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2RyYWdUb2xlcmFuY2VdPVwiMTAwXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGRyYWdUb2xlcmFuY2UgPSA1O1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgcHJvdmlkZSBhIHdheSBmb3IgaWd4RHJhZyBhbmQgaWd4RHJvcCB0byBiZSBsaW5rZWQgdGhyb3VnaCBjaGFubmVscy5cbiAgICAgKiBJdCBhY2NlcHRzIHNpbmdsZSB2YWx1ZSBvciBhbiBhcnJheSBvZiB2YWx1ZXMgYW5kIGV2YWx1YXRlcyB0aGVuIHVzaW5nIHN0cmljdCBlcXVhbGl0eS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFtkcmFnQ2hhbm5lbF09XCInb2RkJ1wiPlxuICAgICAqICAgICAgICAgPHNwYW4+OTU8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogPGRpdiBpZ3hEcm9wIFtkcm9wQ2hhbm5lbF09XCJbJ29kZCcsICdpcnJhdGlvbmFsJ11cIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPk51bWJlcnMgZHJvcCBhcmVhITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGRyYWdDaGFubmVsOiBudW1iZXIgfCBzdHJpbmcgfCBudW1iZXJbXSB8IHN0cmluZ1tdO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc3BlY2lmaWVzIGlmIHRoZSBiYXNlIGVsZW1lbnQgc2hvdWxkIG5vdCBiZSBtb3ZlZCBhbmQgYSBnaG9zdCBlbGVtZW50IHNob3VsZCBiZSByZW5kZXJlZCB0aGF0IHJlcHJlc2VudHMgaXQuXG4gICAgICogQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gYHRydWVgLlxuICAgICAqIElmIGl0IGlzIHNldCB0byBgZmFsc2VgIHdoZW4gZHJhZ2dpbmcgdGhlIGJhc2UgZWxlbWVudCBpcyBtb3ZlZCBpbnN0ZWFkIGFuZCBubyBnaG9zdCBlbGVtZW50cyBhcmUgcmVuZGVyZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZ2hvc3RdPVwiZmFsc2VcIj5cbiAgICAgKiAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2hvc3QgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIGN1c3RvbSBjbGFzcyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGBnaG9zdEVsZW1lbnRgIGVsZW1lbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZ2hvc3RDbGFzc109XCInZ2hvc3RFbGVtZW50J1wiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnaG9zdENsYXNzID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIGN1c3RvbSBiYXNlIHN0eWxpbmcgaW5zdGVhZC5cbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBoaWRlcyB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAgICogQnkgZGVmYXVsdCBpdCdzIHNldCB0byBmYWxzZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFtkcmFnVG9sZXJhbmNlXT1cIjEwMFwiIFtoaWRlQmFzZU9uRHJhZ109XCIndHJ1ZSdcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQERlcHJlY2F0ZVByb3BlcnR5KGAnaGlkZUJhc2VPbkRyYWcnIEBJbnB1dCBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIG1ham9yIHZlcnNpb25zLlxuICAgICAgICBBbHRlcm5hdGl2ZXMgdG8gaXQgYXJlIHVzaW5nIHRoZSBuZXcgbm8gZ2hvc3QgZHJhZ2dpbmcgYW5kIGN1c3RvbSBiYXNlIHN0eWxpbmcuYClcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBoaWRlQmFzZU9uRHJhZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBwcm92aWRlZCB0cmFuc2l0aW9uIGZ1bmN0aW9ucyBpbiBmdXR1cmUuXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgZW5hYmxlcy9kaXNhYmxlcyB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgYW5pbWF0aW9uXG4gICAgICogd2hlbiB0aGUgZWxlbWVudCBpcyByZWxlYXNlZC5cbiAgICAgKiBCeSBkZWZhdWx0IGl0J3Mgc2V0IHRvIGZhbHNlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2FuaW1hdGVPblJlbGVhc2VdPVwiJ3RydWUnXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBEZXByZWNhdGVQcm9wZXJ0eShgJ2FuaW1hdGVPblJlbGVhc2UnIEBJbnB1dCBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIG1ham9yIHZlcnNpb25zLlxuICAgICAgICBQbGVhc2UgdXNlICd0cmFuc2l0aW9uVG9PcmlnaW4nIG9yICd0cmFuc2l0aW9uVG8nIG1ldGhvZHMgaW5zdGVhZC5gKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGFuaW1hdGVPblJlbGVhc2UgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNwZWNpZmllcyBhIHRlbXBsYXRlIGZvciB0aGUgZ2hvc3QgZWxlbWVudCBjcmVhdGVkIHdoZW4gZHJhZ2dpbmcgc3RhcnRzIGFuZCBgZ2hvc3RgIGlzIHRydWUuXG4gICAgICogQnkgZGVmYXVsdCBhIGNsb25lIG9mIHRoZSBiYXNlIGVsZW1lbnQgdGhlIGlneERyYWcgaXMgaW5zdGFuY2VkIGlzIGNyZWF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZ2hvc3RUZW1wbGF0ZV09XCJjdXN0b21HaG9zdFwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogPG5nLXRlbXBsYXRlICNjdXN0b21HaG9zdD5cbiAgICAgKiAgICAgIDxkaXYgY2xhc3M9XCJjdXN0b21HaG9zdFN0eWxlXCI+XG4gICAgICogICAgICAgICAgPHNwYW4+SSBhbSBiZWluZyBkcmFnZ2VkITwvc3Bhbj5cbiAgICAgKiAgICAgIDwvZGl2PlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnaG9zdFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgZWxlbWVudCB0byB3aGljaCB0aGUgZHJhZ2dlZCBlbGVtZW50IHdpbGwgYmUgYXBwZW5kZWQuXG4gICAgICogQnkgZGVmYXVsdCBpdCdzIHNldCB0byBudWxsIGFuZCB0aGUgZHJhZ2dlZCBlbGVtZW50IGlzIGFwcGVuZGVkIHRvIHRoZSBib2R5LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2ICNob3N0RGl2PjwvZGl2PlxuICAgICAqIDxkaXYgaWd4RHJhZyBbZ2hvc3RIb3N0XT1cImhvc3REaXZcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2hvc3RIb3N0O1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc3BlY2lmaWVzIHRoZSBvZmZzZXQgb2YgdGhlIGRyYWdnZWQgZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgbW91c2UgaW4gcGl4ZWxzLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQncyB0YWtpbmcgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIHRvIHRoZSBtb3VzZSB3aGVuIHRoZSBkcmFnIHN0YXJ0ZWQgYW5kIGtlZXBzIGl0IHRoZSBzYW1lLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2ICNob3N0RGl2PjwvZGl2PlxuICAgICAqIDxkaXYgaWd4RHJhZyBbZ2hvc3RPZmZzZXRYXT1cIjBcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IGdob3N0T2Zmc2V0WCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9vZmZzZXRYID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGdob3N0T2Zmc2V0WCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldFggIT09IHVuZGVmaW5lZCA/IHRoaXMuX29mZnNldFggOiB0aGlzLl9kZWZhdWx0T2Zmc2V0WDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzcGVjaWZpZXMgdGhlIG9mZnNldCBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSBtb3VzZSBpbiBwaXhlbHMuXG4gICAgICogQnkgZGVmYXVsdCBpdCdzIHRha2luZyB0aGUgcmVsYXRpdmUgcG9zaXRpb24gdG8gdGhlIG1vdXNlIHdoZW4gdGhlIGRyYWcgc3RhcnRlZCBhbmQga2VlcHMgaXQgdGhlIHNhbWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgI2hvc3REaXY+PC9kaXY+XG4gICAgICogPGRpdiBpZ3hEcmFnIFtnaG9zdE9mZnNldFldPVwiMFwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgZ2hvc3RPZmZzZXRZKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX29mZnNldFkgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZ2hvc3RPZmZzZXRZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0WSAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb2Zmc2V0WSA6IHRoaXMuX2RlZmF1bHRPZmZzZXRZIDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgZHJhZyBzdGFydHMuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyAoZHJhZ1N0YXJ0KT1cIm9uRHJhZ1N0YXJ0KClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25EcmFnU3RhcnQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGRyYWcgaGFzIHN0YXJlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGRyYWdTdGFydCA9IG5ldyBFdmVudEVtaXR0ZXI8SURyYWdTdGFydEV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgYmVlbiBtb3ZlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnICAoZHJhZ01vdmUpPVwib25EcmFnTW92ZSgpXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIG9uRHJhZ01vdmUoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGVsZW1lbnQgaGFzIG1vdmVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZHJhZ01vdmUgPSBuZXcgRXZlbnRFbWl0dGVyPElEcmFnTW92ZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBpcyByZWxlYXNlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIChkcmFnRW5kKT1cIm9uRHJhZ0VuZCgpXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIG9uRHJhZ0VuZCgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZHJhZyBoYXMgZW5kZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBkcmFnRW5kID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJhZ0Jhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIChkcmFnQ2xpY2spPVwib25EcmFnQ2xpY2soKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBvbkRyYWdDbGljaygpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZWxlbWVudCBoYXMgYmVlbiBjbGlja2VkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZHJhZ0NsaWNrID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJhZ0Jhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZyBnaG9zdCBlbGVtZW50IGlzIGNyZWF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyAoZ2hvc3RDcmVhdGUpPVwiZ2hvc3RDcmVhdGVkKClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZ2hvc3RDcmVhdGVkKCl7XG4gICAgICogICAgICBhbGVydChcIlRoZSBnaG9zdCBoYXMgYmVlbiBjcmVhdGVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZ2hvc3RDcmVhdGUgPSBuZXcgRXZlbnRFbWl0dGVyPElEcmFnR2hvc3RCYXNlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gdGhlIGRyYWcgZ2hvc3QgZWxlbWVudCBpcyBjcmVhdGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgKGdob3N0RGVzdHJveSk9XCJnaG9zdERlc3Ryb3llZCgpXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGdob3N0RGVzdHJveWVkKCl7XG4gICAgICogICAgICBhbGVydChcIlRoZSBnaG9zdCBoYXMgYmVlbiBkZXN0cm95ZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBnaG9zdERlc3Ryb3kgPSBuZXcgRXZlbnRFbWl0dGVyPElEcmFnR2hvc3RCYXNlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIGFmdGVyIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBpcyByZWxlYXNlZCBhbmQgYWZ0ZXIgaXRzIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyAodHJhbnNpdGlvbmVkKT1cIm9uTW92ZUVuZCgpXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIG9uTW92ZUVuZCgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgbW92ZSBoYXMgZW5kZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyB0cmFuc2l0aW9uZWQgPSBuZXcgRXZlbnRFbWl0dGVyPElEcmFnQmFzZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKElneERyYWdIYW5kbGVEaXJlY3RpdmUpXG4gICAgcHVibGljIGRyYWdIYW5kbGVzOiBRdWVyeUxpc3Q8SWd4RHJhZ0hhbmRsZURpcmVjdGl2ZT47XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS52aXNpYmlsaXR5JylcbiAgICBwdWJsaWMgX3Zpc2liaWxpdHkgPSAndmlzaWJsZSc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtZHJhZycpXG4gICAgcHVibGljIGJhc2VDbGFzcyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtZHJhZy0tc2VsZWN0LWRpc2FibGVkJylcbiAgICBwdWJsaWMgc2VsZWN0RGlzYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgbmF0aXZlIGFuZ3VsYXIgd2F5cyBvZiBoaWRpbmcgaXQgdXNpbmcgY3VzdG9tIHRvIHRoZSBiYXNlIGVsZW1lbnQgc3R5bGluZyBmb3IgZnV0dXJlIHZlcnNpb25zLlxuICAgICAqIFNldHMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGRyYWdnYWJsZSBlbGVtZW50LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwibXlEcmFnXCIgLHtyZWFkOiBJZ3hEcmFnRGlyZWN0aXZlfSlcbiAgICAgKiBwdWJsaWMgbXlEcmFnOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgICAqIG5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgICB0aGlzLm15RHJhZy52aXNpYmxlID0gZmFsc2U7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBEZXByZWNhdGVQcm9wZXJ0eShgJ3Zpc2libGUnIEBJbnB1dCBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIG1ham9yIHZlcnNpb25zLlxuICAgICAgICBQbGVhc2UgdXNlIG5hdGl2ZSBhbmd1bGFyIHdheXMgb2YgaGlkaW5nIHRoZSBiYXNlIGVsZW1lbnQgdXNpbmcgc3R5bGluZy5gKVxuICAgIHB1YmxpYyBzZXQgdmlzaWJsZShiVmlzaWJsZSkge1xuICAgICAgICB0aGlzLl92aXNpYmlsaXR5ID0gYlZpc2libGUgPyAndmlzaWJsZScgOiAnaGlkZGVuJztcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZpc2liaWxpdHkgc3RhdGUgb2YgdGhlIGRyYWdnYWJsZSBlbGVtZW50LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwibXlEcmFnXCIgLHtyZWFkOiBJZ3hEcmFnRGlyZWN0aXZlfSlcbiAgICAgKiBwdWJsaWMgbXlEcmFnOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgICAqIG5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgICBsZXQgZHJhZ1Zpc2liaWxpdHkgPSB0aGlzLm15RHJhZy52aXNpYmxlO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmlsaXR5ID09PSAndmlzaWJsZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBsb2NhdGlvbiBvZiB0aGUgZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgcGFnZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGxvY2F0aW9uKCk6IElneERyYWdMb2NhdGlvbiB7XG4gICAgICAgIHJldHVybiBuZXcgSWd4RHJhZ0xvY2F0aW9uKHRoaXMucGFnZVgsIHRoaXMucGFnZVkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG9yaWdpbmFsIGxvY2F0aW9uIG9mIHRoZSBlbGVtZW50IGJlZm9yZSBkcmFnZ2luZyBzdGFydGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgb3JpZ2luTG9jYXRpb24oKTogSWd4RHJhZ0xvY2F0aW9uIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJZ3hEcmFnTG9jYXRpb24odGhpcy5iYXNlT3JpZ2luTGVmdCwgdGhpcy5iYXNlT3JpZ2luVG9wKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBwb2ludGVyRXZlbnRzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBQb2ludGVyRXZlbnQgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRvdWNoRXZlbnRzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBwYWdlWCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2hvc3QgJiYgdGhpcy5naG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdob3N0TGVmdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5iYXNlTGVmdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBwYWdlWSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2hvc3QgJiYgdGhpcy5naG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdob3N0VG9wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VUb3A7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldCBiYXNlTGVmdCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IGJhc2VUb3AoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IGJhc2VPcmlnaW5MZWZ0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VMZWZ0IC0gdGhpcy5nZXRUcmFuc2Zvcm1YKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IGJhc2VPcmlnaW5Ub3AoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVRvcCAtIHRoaXMuZ2V0VHJhbnNmb3JtWSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldCBnaG9zdExlZnQocGFnZVg6IG51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5naG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgbWFyZ2luTGVmdCwgc2luY2UgdG9wIHN0eWxlIGRvZXMgbm90IGluY2x1ZGUgbWFyZ2luLCBidXQgcGFnZVggaW5jbHVkZXMgdGhlIG1hcmdpbi5cbiAgICAgICAgICAgIGNvbnN0IGdob3N0TWFyZ2luTGVmdCA9IHBhcnNlSW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5naG9zdEVsZW1lbnQpWydtYXJnaW4tbGVmdCddLCAxMCk7XG4gICAgICAgICAgICAvLyBJZiBnaG9zdCBob3N0IGlzIGRlZmluZWQgaXQgbmVlZHMgdG8gYmUgdGFrZW4gaW50byBhY2NvdW50LlxuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc3R5bGUubGVmdCA9IChwYWdlWCAtIGdob3N0TWFyZ2luTGVmdCAtIHRoaXMuX2dob3N0SG9zdFgpICsgJ3B4JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgZ2hvc3RMZWZ0KCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5naG9zdEVsZW1lbnQuc3R5bGUubGVmdCwgMTApICsgdGhpcy5fZ2hvc3RIb3N0WDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc2V0IGdob3N0VG9wKHBhZ2VZOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2hvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IG1hcmdpblRvcCwgc2luY2UgdG9wIHN0eWxlIGRvZXMgbm90IGluY2x1ZGUgbWFyZ2luLCBidXQgcGFnZVkgaW5jbHVkZXMgdGhlIG1hcmdpbi5cbiAgICAgICAgICAgIGNvbnN0IGdob3N0TWFyZ2luVG9wID0gcGFyc2VJbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmdob3N0RWxlbWVudClbJ21hcmdpbi10b3AnXSwgMTApO1xuICAgICAgICAgICAgLy8gSWYgZ2hvc3QgaG9zdCBpcyBkZWZpbmVkIGl0IG5lZWRzIHRvIGJlIHRha2VuIGludG8gYWNjb3VudC5cbiAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnN0eWxlLnRvcCA9IChwYWdlWSAtIGdob3N0TWFyZ2luVG9wIC0gdGhpcy5fZ2hvc3RIb3N0WSkgKyAncHgnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldCBnaG9zdFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2hvc3RFbGVtZW50LnN0eWxlLnRvcCwgMTApICsgdGhpcy5fZ2hvc3RIb3N0WTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGRlZmF1bHRSZXR1cm5EdXJhdGlvbiA9ICcwLjVzJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2hvc3RFbGVtZW50O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBhbmltSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgcHJvdGVjdGVkIF9zdGFydFggPSAwO1xuICAgIHByb3RlY3RlZCBfc3RhcnRZID0gMDtcbiAgICBwcm90ZWN0ZWQgX2xhc3RYID0gMDtcbiAgICBwcm90ZWN0ZWQgX2xhc3RZID0gMDtcbiAgICBwcm90ZWN0ZWQgX2RyYWdTdGFydGVkID0gZmFsc2U7XG5cbiAgICAvKiogRHJhZyBnaG9zdCByZWxhdGVkIHByb3BlcnRpZXMgKi9cbiAgICBwcm90ZWN0ZWQgX2RlZmF1bHRPZmZzZXRYO1xuICAgIHByb3RlY3RlZCBfZGVmYXVsdE9mZnNldFk7XG4gICAgcHJvdGVjdGVkIF9vZmZzZXRYO1xuICAgIHByb3RlY3RlZCBfb2Zmc2V0WTtcbiAgICBwcm90ZWN0ZWQgX2dob3N0U3RhcnRYO1xuICAgIHByb3RlY3RlZCBfZ2hvc3RTdGFydFk7XG4gICAgcHJvdGVjdGVkIF9naG9zdEhvc3RYID0gMDtcbiAgICBwcm90ZWN0ZWQgX2dob3N0SG9zdFkgPSAwO1xuXG4gICAgcHJvdGVjdGVkIF9wb2ludGVyRG93bklkID0gbnVsbDtcbiAgICBwcm90ZWN0ZWQgX2NsaWNrZWQgPSBmYWxzZTtcbiAgICBwcm90ZWN0ZWQgX2xhc3REcm9wQXJlYSA9IG51bGw7XG5cbiAgICBwcm90ZWN0ZWQgX2Rlc3Ryb3kgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuICAgIHByb3RlY3RlZCBfcmVtb3ZlT25EZXN0cm95ID0gdHJ1ZTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHVibGljIGVsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgICAgIHB1YmxpYyB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBwdWJsaWMgem9uZTogTmdab25lLFxuICAgICAgICBwdWJsaWMgcmVuZGVyZXI6IFJlbmRlcmVyMlxuICAgICkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMuZHJhZ0hhbmRsZXMgfHwgIXRoaXMuZHJhZ0hhbmRsZXMubGVuZ3RoICkge1xuICAgICAgICAgICAgLy8gU2V0IHVzZXIgc2VsZWN0IG5vbmUgdG8gdGhlIHdob2xlIGRyYWdnYWJsZSBlbGVtZW50IGlmIG5vIGRyYWcgaGFuZGxlcyBhcmUgZGVmaW5lZC5cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0RGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmluZCBldmVudHNcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnRzID0gdGhpcy5kcmFnSGFuZGxlcyAmJiB0aGlzLmRyYWdIYW5kbGVzLmxlbmd0aCA/XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnSGFuZGxlcy5tYXAoKGl0ZW0pID0+IGl0ZW0uZWxlbWVudC5uYXRpdmVFbGVtZW50KSA6IFt0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudF07XG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9pbnRlckV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbUV2ZW50KGVsZW1lbnQsICdwb2ludGVyZG93bicpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyRG93bihyZXMpKTtcblxuICAgICAgICAgICAgICAgICAgICBmcm9tRXZlbnQoZWxlbWVudCwgJ3BvaW50ZXJtb3ZlJykucGlwZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm90dGxlKCgpID0+IGludGVydmFsKDAsIGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyKSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fZGVzdHJveSlcbiAgICAgICAgICAgICAgICAgICAgKS5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJNb3ZlKHJlcykpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZyb21FdmVudChlbGVtZW50LCAncG9pbnRlcnVwJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyVXAocmVzKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmdob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgYmluZCBgbG9zdHBvaW50ZXJjYXB0dXJlYCB0byB0aGUgdGFyZ2V0LCBiZWNhdXNlIHdlIHdpbGwgYmluZCBpdCBvbiB0aGUgZ2hvc3QgbGF0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tRXZlbnQoZWxlbWVudCwgJ2xvc3Rwb2ludGVyY2FwdHVyZScpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlckxvc3QocmVzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG91Y2hFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21FdmVudChlbGVtZW50LCAndG91Y2hzdGFydCcpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyRG93bihyZXMpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIHBvaW50ZXIgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMuIFVzZSB0aGVuIG1vdXNlIGV2ZW50cy5cbiAgICAgICAgICAgICAgICAgICAgZnJvbUV2ZW50KGVsZW1lbnQsICdtb3VzZWRvd24nKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlckRvd24ocmVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBiaW5kIHRvIGRvY3VtZW50IGV2ZW50cyBvbmx5IG9uY2Ugd2hlbiB0aGVyZSBhcmUgbm8gcG9pbnRlciBldmVudHMuXG4gICAgICAgICAgICBpZiAoIXRoaXMucG9pbnRlckV2ZW50c0VuYWJsZWQgJiYgdGhpcy50b3VjaEV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBmcm9tRXZlbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcsICd0b3VjaG1vdmUnKS5waXBlKFxuICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZSgoKSA9PiBpbnRlcnZhbCgwLCBhbmltYXRpb25GcmFtZVNjaGVkdWxlcikpLFxuICAgICAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fZGVzdHJveSlcbiAgICAgICAgICAgICAgICApLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlck1vdmUocmVzKSk7XG5cbiAgICAgICAgICAgICAgICBmcm9tRXZlbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcsICd0b3VjaGVuZCcpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyVXAocmVzKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LCAnbW91c2Vtb3ZlJykucGlwZShcbiAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGUoKCkgPT4gaW50ZXJ2YWwoMCwgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIpKSxcbiAgICAgICAgICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpXG4gICAgICAgICAgICAgICAgKS5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJNb3ZlKHJlcykpO1xuXG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LCAnbW91c2V1cCcpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyVXAocmVzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25UcmFuc2l0aW9uRW5kKGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNldCB0cmFuc2l0aW9uIGR1cmF0aW9uIHRvIDBzLiBUaGlzIGFsc28gaGVscHMgd2l0aCBzZXR0aW5nIGB2aXNpYmlsaXR5OiBoaWRkZW5gIHRvIHRoZSBiYXNlIHRvIG5vdCBsYWcuXG4gICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwLjBzJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9kZXN0cm95Lm5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3kuY29tcGxldGUoKTtcblxuICAgICAgICBpZiAodGhpcy5naG9zdCAmJiB0aGlzLmdob3N0RWxlbWVudCAmJiB0aGlzLl9yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5naG9zdEVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBkZXNpcmVkIGxvY2F0aW9uIG9mIHRoZSBiYXNlIGVsZW1lbnQgb3IgZ2hvc3QgZWxlbWVudCBpZiByZW5kZWQgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSBuZXdMb2NhdGlvbiBOZXcgbG9jYXRpb24gdGhhdCBzaG91bGQgYmUgYXBwbGllZC4gSXQgaXMgYWR2aXNlZCB0byBnZXQgbmV3IGxvY2F0aW9uIHVzaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdHMoKSArIHNjcm9sbC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0TG9jYXRpb24obmV3TG9jYXRpb246IElneERyYWdMb2NhdGlvbikge1xuICAgICAgICAvLyBXZSBkbyBub3Qgc3VidHJhY3QgbWFyZ2luTGVmdCBhbmQgbWFyZ2luVG9wIGhlcmUgYmVjYXVzZSBoZXJlIHdlIGNhbGN1bGF0ZSBkZWx0YXMuXG4gICAgICAgIGlmICh0aGlzLmdob3N0ICYmIHRoaXMuZ2hvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRIb3N0WCA9IHRoaXMuZ2hvc3RIb3N0ID8gdGhpcy5naG9zdEhvc3RPZmZzZXRMZWZ0KHRoaXMuZ2hvc3RIb3N0KSA6IDA7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRIb3N0WSA9IHRoaXMuZ2hvc3RIb3N0ID8gdGhpcy5naG9zdEhvc3RPZmZzZXRUb3AodGhpcy5naG9zdEhvc3QpIDogMDtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RMZWZ0ID0gbmV3TG9jYXRpb24ucGFnZVggLSBvZmZzZXRIb3N0WCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICAgICAgICAgICAgdGhpcy5naG9zdFRvcCA9IG5ld0xvY2F0aW9uLnBhZ2VZIC0gb2Zmc2V0SG9zdFkgKyB0aGlzLmdldFdpbmRvd1Njcm9sbFRvcCgpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmdob3N0KSB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YVggPSBuZXdMb2NhdGlvbi5wYWdlWCAtIHRoaXMucGFnZVg7XG4gICAgICAgICAgICBjb25zdCBkZWx0YVkgPSBuZXdMb2NhdGlvbi5wYWdlWSAtIHRoaXMucGFnZVk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1YID0gdGhpcy5nZXRUcmFuc2Zvcm1YKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybVkgPSB0aGlzLmdldFRyYW5zZm9ybVkodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1YWSh0cmFuc2Zvcm1YICsgZGVsdGFYLCB0cmFuc2Zvcm1ZICsgZGVsdGFZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuYmFzZUxlZnQ7XG4gICAgICAgIHRoaXMuX3N0YXJ0WSA9IHRoaXMuYmFzZVRvcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlcyB0aGUgYmFzZSBvciBnaG9zdCBlbGVtZW50IGRlcGVuZGluZyBvbiB0aGUgYGdob3N0YCBpbnB1dCB0byBpdHMgaW5pdGlhbCBsb2NhdGlvbi5cbiAgICAgKiBJZiBgZ2hvc3RgIGlzIHRydWUgYnV0IHRoZXJlIGlzIG5vdCBnaG9zdCByZW5kZXJlZCwgaXQgd2lsbCBiZSBjcmVhdGVkIGFuZCBhbmltYXRlZC5cbiAgICAgKiBJZiB0aGUgYmFzZSBlbGVtZW50IGhhcyBjaGFuZ2VkIGl0cyBET00gcG9zaXRpb24gaXRzIGluaXRpYWwgbG9jYXRpb24gd2lsbCBiZSBjaGFuZ2VkIGFjY29yZGluZ2x5LlxuICAgICAqIEBwYXJhbSBjdXN0b21BbmltQXJncyBDdXN0b20gdHJhbnNpdGlvbiBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHdoZW4gcGVyZm9ybWluZyB0aGUgdHJhbnNpdGlvbi5cbiAgICAgKiBAcGFyYW0gc3RhcnRMb2NhdGlvbiBTdGFydCBsb2NhdGlvbiBmcm9tIHdoZXJlIHRoZSB0cmFuc2l0aW9uIHNob3VsZCBzdGFydC5cbiAgICAgKi9cbiAgICBwdWJsaWMgdHJhbnNpdGlvblRvT3JpZ2luKGN1c3RvbUFuaW1BcmdzPzogSURyYWdDdXN0b21UcmFuc2l0aW9uQXJncywgc3RhcnRMb2NhdGlvbj86IElneERyYWdMb2NhdGlvbikge1xuICAgICAgICBpZiAoKCEhc3RhcnRMb2NhdGlvbiAmJiBzdGFydExvY2F0aW9uLnBhZ2VYID09PSB0aGlzLmJhc2VPcmlnaW5MZWZ0ICYmIHN0YXJ0TG9jYXRpb24ucGFnZVkgPT09IHRoaXMuYmFzZU9yaWdpbkxlZnQpIHx8XG4gICAgICAgICAgICAoIXN0YXJ0TG9jYXRpb24gJiYgdGhpcy5naG9zdCAmJiAhdGhpcy5naG9zdEVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISFzdGFydExvY2F0aW9uICYmIHN0YXJ0TG9jYXRpb24ucGFnZVggIT09IHRoaXMucGFnZVggJiYgc3RhcnRMb2NhdGlvbi5wYWdlWSAhPT0gdGhpcy5wYWdlWSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2hvc3QgJiYgIXRoaXMuZ2hvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRYID0gc3RhcnRMb2NhdGlvbi5wYWdlWDtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFkgPSBzdGFydExvY2F0aW9uLnBhZ2VZO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dob3N0U3RhcnRYID0gdGhpcy5fc3RhcnRYO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dob3N0U3RhcnRZID0gdGhpcy5fc3RhcnRZO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlR2hvc3QodGhpcy5fc3RhcnRYLCB0aGlzLl9zdGFydFkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldExvY2F0aW9uKHN0YXJ0TG9jYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hbmltSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIC8vIFVzZSBzZXRUaW1lb3V0IGJlY2F1c2Ugd2UgbmVlZCB0byBiZSBzdXJlIHRoYXQgdGhlIGVsZW1lbnQgaXMgcG9zaXRpb25lZCBmaXJzdCBjb3JyZWN0bHkgaWYgdGhlcmUgaXMgc3RhcnQgbG9jYXRpb24uXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2hvc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSAndG9wLCBsZWZ0JztcbiAgICAgICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPVxuICAgICAgICAgICAgICAgICAgICBjdXN0b21BbmltQXJncyAmJiBjdXN0b21BbmltQXJncy5kdXJhdGlvbiA/IGN1c3RvbUFuaW1BcmdzLmR1cmF0aW9uICsgJ3MnIDogdGhpcy5kZWZhdWx0UmV0dXJuRHVyYXRpb24gO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUFuaW1BcmdzICYmIGN1c3RvbUFuaW1BcmdzLnRpbWluZ0Z1bmN0aW9uID8gY3VzdG9tQW5pbUFyZ3MudGltaW5nRnVuY3Rpb24gOiAnJztcbiAgICAgICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5zdHlsZS50cmFuc2l0aW9uRGVsYXkgPSBjdXN0b21BbmltQXJncyAmJiBjdXN0b21BbmltQXJncy5kZWxheSA/IGN1c3RvbUFuaW1BcmdzLmRlbGF5ICsgJ3MnIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMb2NhdGlvbihuZXcgSWd4RHJhZ0xvY2F0aW9uKHRoaXMuYmFzZUxlZnQsIHRoaXMuYmFzZVRvcCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5naG9zdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9ICd0cmFuc2Zvcm0nO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUFuaW1BcmdzICYmIGN1c3RvbUFuaW1BcmdzLmR1cmF0aW9uID8gY3VzdG9tQW5pbUFyZ3MuZHVyYXRpb24gKyAncycgOiB0aGlzLmRlZmF1bHRSZXR1cm5EdXJhdGlvbiA7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tQW5pbUFyZ3MgJiYgY3VzdG9tQW5pbUFyZ3MudGltaW5nRnVuY3Rpb24gPyBjdXN0b21BbmltQXJncy50aW1pbmdGdW5jdGlvbiA6ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EZWxheSA9IGN1c3RvbUFuaW1BcmdzICYmIGN1c3RvbUFuaW1BcmdzLmRlbGF5ID8gY3VzdG9tQW5pbUFyZ3MuZGVsYXkgKyAncycgOiAnJztcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFggPSB0aGlzLmJhc2VMZWZ0O1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0WSA9IHRoaXMuYmFzZVRvcDtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybVhZKDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlcyB0aGUgYmFzZSBvciBnaG9zdCBlbGVtZW50IHRvIGEgc3BlY2lmaWMgdGFyZ2V0IGxvY2F0aW9uIG9yIG90aGVyIGVsZW1lbnQgdXNpbmcgdHJhbnNpdGlvbi5cbiAgICAgKiBJZiBgZ2hvc3RgIGlzIHRydWUgYnV0IHRoZXJlIGlzIG5vdCBnaG9zdCByZW5kZXJlZCwgaXQgd2lsbCBiZSBjcmVhdGVkIGFuZCBhbmltYXRlZC5cbiAgICAgKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgJ2dldEJvdW5kaW5nQ2xpZW50UmVjdHMoKSArIHBhZ2VTY3JvbGwnIHdoZW4gZGV0ZXJtaW5pbmcgZGVzaXJlZCBsb2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRhcmdldCB0aGF0IHRoZSBiYXNlIG9yIGdob3N0IHdpbGwgdHJhbnNpdGlvbiB0by4gSXQgY2FuIGJlIGVpdGhlciBsb2NhdGlvbiBpbiB0aGUgcGFnZSBvciBhbm90aGVyIEhUTUwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gY3VzdG9tQW5pbUFyZ3MgQ3VzdG9tIHRyYW5zaXRpb24gcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgYXBwbGllZCB3aGVuIHBlcmZvcm1pbmcgdGhlIHRyYW5zaXRpb24uXG4gICAgICogQHBhcmFtIHN0YXJ0TG9jYXRpb24gU3RhcnQgbG9jYXRpb24gZnJvbSB3aGVyZSB0aGUgdHJhbnNpdGlvbiBzaG91bGQgc3RhcnQuXG4gICAgICovXG4gICAgcHVibGljIHRyYW5zaXRpb25Ubyh0YXJnZXQ6IElneERyYWdMb2NhdGlvbiB8IEVsZW1lbnRSZWYsIGN1c3RvbUFuaW1BcmdzPzogSURyYWdDdXN0b21UcmFuc2l0aW9uQXJncywgc3RhcnRMb2NhdGlvbj86IElneERyYWdMb2NhdGlvbikge1xuICAgICAgICBpZiAoISFzdGFydExvY2F0aW9uICYmIHRoaXMuZ2hvc3QgJiYgIXRoaXMuZ2hvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFggPSBzdGFydExvY2F0aW9uLnBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRZID0gc3RhcnRMb2NhdGlvbi5wYWdlWTtcbiAgICAgICAgICAgIHRoaXMuX2dob3N0U3RhcnRYID0gdGhpcy5fc3RhcnRYO1xuICAgICAgICAgICAgdGhpcy5fZ2hvc3RTdGFydFkgPSB0aGlzLl9zdGFydFk7XG4gICAgICAgIH0gZWxzZSBpZiAoISFzdGFydExvY2F0aW9uICYmICghdGhpcy5naG9zdCB8fCB0aGlzLmdob3N0RWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TG9jYXRpb24oc3RhcnRMb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5naG9zdCAmJiAhdGhpcy5naG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuYmFzZUxlZnQ7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFkgPSB0aGlzLmJhc2VUb3A7XG4gICAgICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WCA9IHRoaXMuX3N0YXJ0WCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICAgICAgICAgICAgdGhpcy5fZ2hvc3RTdGFydFkgPSB0aGlzLl9zdGFydFkgKyB0aGlzLmdldFdpbmRvd1Njcm9sbFRvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ2hvc3QgJiYgIXRoaXMuZ2hvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUdob3N0KHRoaXMuX3N0YXJ0WCwgdGhpcy5fc3RhcnRZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYW5pbUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAvLyBVc2Ugc2V0VGltZW91dCBiZWNhdXNlIHdlIG5lZWQgdG8gYmUgc3VyZSB0aGF0IHRoZSBlbGVtZW50IGlzIHBvc2l0aW9uZWQgZmlyc3QgY29ycmVjdGx5IGlmIHRoZXJlIGlzIHN0YXJ0IGxvY2F0aW9uLlxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVkRWxlbSA9IHRoaXMuZ2hvc3QgPyB0aGlzLmdob3N0RWxlbWVudCA6IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgbW92ZWRFbGVtLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9IHRoaXMuZ2hvc3QgJiYgdGhpcy5naG9zdEVsZW1lbnQgPyAnbGVmdCwgdG9wJyA6ICd0cmFuc2Zvcm0nO1xuICAgICAgICAgICAgbW92ZWRFbGVtLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9XG4gICAgICAgICAgICAgICAgY3VzdG9tQW5pbUFyZ3MgJiYgY3VzdG9tQW5pbUFyZ3MuZHVyYXRpb24gPyBjdXN0b21BbmltQXJncy5kdXJhdGlvbiArICdzJyA6IHRoaXMuZGVmYXVsdFJldHVybkR1cmF0aW9uIDtcbiAgICAgICAgICAgIG1vdmVkRWxlbS5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPVxuICAgICAgICAgICAgICAgIGN1c3RvbUFuaW1BcmdzICYmIGN1c3RvbUFuaW1BcmdzLnRpbWluZ0Z1bmN0aW9uID8gY3VzdG9tQW5pbUFyZ3MudGltaW5nRnVuY3Rpb24gOiAnJztcbiAgICAgICAgICAgIG1vdmVkRWxlbS5zdHlsZS50cmFuc2l0aW9uRGVsYXkgPSBjdXN0b21BbmltQXJncyAmJiBjdXN0b21BbmltQXJncy5kZWxheSA/IGN1c3RvbUFuaW1BcmdzLmRlbGF5ICsgJ3MnIDogJyc7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBJZ3hEcmFnTG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldExvY2F0aW9uKG5ldyBJZ3hEcmFnTG9jYXRpb24gKHRhcmdldC5wYWdlWCwgdGFyZ2V0LnBhZ2VZKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFJlY3RzID0gdGFyZ2V0Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMb2NhdGlvbihuZXcgSWd4RHJhZ0xvY2F0aW9uKFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRSZWN0cy5sZWZ0IC0gIHRoaXMuZ2V0V2luZG93U2Nyb2xsTGVmdCgpLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRSZWN0cy50b3AgLSB0aGlzLmdldFdpbmRvd1Njcm9sbFRvcCgpXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBNZXRob2QgYm91bmQgdG8gdGhlIFBvaW50ZXJEb3duIGV2ZW50IG9mIHRoZSBiYXNlIGVsZW1lbnQgaWd4RHJhZyBpcyBpbml0aWFsaXplZC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgUG9pbnRlckRvd24gZXZlbnQgY2FwdHVyZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgb25Qb2ludGVyRG93bihldmVudCkge1xuICAgICAgICB0aGlzLl9jbGlja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcG9pbnRlckRvd25JZCA9IGV2ZW50LnBvaW50ZXJJZDtcblxuICAgICAgICAvLyBTZXQgcG9pbnRlciBjYXB0dXJlIHNvIHdlIGRldGVjdCBwb2ludGVybW92ZSBldmVuIGlmIG1vdXNlIGlzIG91dCBvZiBib3VuZHMgdW50aWwgZ2hvc3RFbGVtZW50IGlzIGNyZWF0ZWQuXG4gICAgICAgIGNvbnN0IGhhbmRsZUZvdW5kID0gdGhpcy5kcmFnSGFuZGxlcy5maW5kKGhhbmRsZSA9PiBoYW5kbGUuZWxlbWVudC5uYXRpdmVFbGVtZW50ID09PSBldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGhhbmRsZUZvdW5kID8gaGFuZGxlRm91bmQuZWxlbWVudC5uYXRpdmVFbGVtZW50IDogdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmICh0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50LnNldFBvaW50ZXJDYXB0dXJlKHRoaXMuX3BvaW50ZXJEb3duSWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkIHx8ICF0aGlzLnRvdWNoRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZmlyc3QgZm9yIHBvaW50ZXIgZXZlbnRzIG9yIG5vbiB0b3VjaCwgYmVjYXVzZSB3ZSBjYW4gaGF2ZSBwb2ludGVyIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzIGF0IG9uY2UuXG4gICAgICAgICAgICB0aGlzLl9zdGFydFggPSBldmVudC5wYWdlWDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0WSA9IGV2ZW50LnBhZ2VZO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG91Y2hFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRZID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RlZmF1bHRPZmZzZXRYID0gdGhpcy5iYXNlTGVmdCAtIHRoaXMuX3N0YXJ0WCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICAgICAgICB0aGlzLl9kZWZhdWx0T2Zmc2V0WSA9IHRoaXMuYmFzZVRvcCAtIHRoaXMuX3N0YXJ0WSArIHRoaXMuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG4gICAgICAgIHRoaXMuX2dob3N0U3RhcnRYID0gdGhpcy5fc3RhcnRYICsgdGhpcy5naG9zdE9mZnNldFg7XG4gICAgICAgIHRoaXMuX2dob3N0U3RhcnRZID0gdGhpcy5fc3RhcnRZICsgdGhpcy5naG9zdE9mZnNldFk7XG4gICAgICAgIHRoaXMuX2xhc3RYID0gdGhpcy5fc3RhcnRYO1xuICAgICAgICB0aGlzLl9sYXN0WSA9IHRoaXMuX3N0YXJ0WTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogUGVyZm9ybSBkcmFnIG1vdmUgbG9naWMgd2hlbiBkcmFnZ2luZyBhbmQgZGlzcGF0Y2hpbmcgZXZlbnRzIGlmIHRoZXJlIGlzIGlneERyb3AgdW5kZXIgdGhlIHBvaW50ZXIuXG4gICAgICogVGhpcyBtZXRob2QgaXMgYm91bmQgYXQgZmlyc3QgYXQgdGhlIGJhc2UgZWxlbWVudC5cbiAgICAgKiBJZiBkcmFnZ2luZyBzdGFydHMgYW5kIGFmdGVyIHRoZSBnaG9zdEVsZW1lbnQgaXMgcmVuZGVyZWQgdGhlIHBvaW50ZXJJZCBpcyByZWFzc2lnbmVkIGl0LiBUaGVuIHRoaXMgbWV0aG9kIGlzIGJvdW5kIHRvIGl0LlxuICAgICAqIEBwYXJhbSBldmVudCBQb2ludGVyTW92ZSBldmVudCBjYXB0dXJlZFxuICAgICAqL1xuICAgIHB1YmxpYyBvblBvaW50ZXJNb3ZlKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGlja2VkKSB7XG4gICAgICAgICAgICBsZXQgcGFnZVgsIHBhZ2VZO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9pbnRlckV2ZW50c0VuYWJsZWQgfHwgIXRoaXMudG91Y2hFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZmlyc3QgZm9yIHBvaW50ZXIgZXZlbnRzIG9yIG5vbiB0b3VjaCwgYmVjYXVzZSB3ZSBjYW4gaGF2ZSBwb2ludGVyIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzIGF0IG9uY2UuXG4gICAgICAgICAgICAgICAgcGFnZVggPSBldmVudC5wYWdlWDtcbiAgICAgICAgICAgICAgICBwYWdlWSA9IGV2ZW50LnBhZ2VZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRvdWNoRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHBhZ2VYID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgICAgICBwYWdlWSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZyBvbiB0b3VjaCB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRvdGFsTW92ZWRYID0gcGFnZVggLSB0aGlzLl9zdGFydFg7XG4gICAgICAgICAgICBjb25zdCB0b3RhbE1vdmVkWSA9IHBhZ2VZIC0gdGhpcy5fc3RhcnRZO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kcmFnU3RhcnRlZCAmJlxuICAgICAgICAgICAgICAgIChNYXRoLmFicyh0b3RhbE1vdmVkWCkgPiB0aGlzLmRyYWdUb2xlcmFuY2UgfHwgTWF0aC5hYnModG90YWxNb3ZlZFkpID4gdGhpcy5kcmFnVG9sZXJhbmNlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRyYWdTdGFydEFyZ3M6IElEcmFnU3RhcnRFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRYOiBwYWdlWCAtIHRvdGFsTW92ZWRYLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFk6IHBhZ2VZIC0gdG90YWxNb3ZlZFksXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VYOiBwYWdlWCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVk6IHBhZ2VZLFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnU3RhcnQuZW1pdChkcmFnU3RhcnRBcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICghZHJhZ1N0YXJ0QXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5naG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbW92ZWQgZW5vdWdoIHNvIGdob3N0RWxlbWVudCBjYW4gYmUgcmVuZGVyZWQgYW5kIGFjdHVhbCBkcmFnZ2luZyB0byBzdGFydC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gY3JlYXRpbmcgaXQgd2lsbCB0YWtlIGludG8gYWNjb3VudCBhbnkgb2Zmc2V0IHNldCBieSB0aGUgdXNlciBieSBkZWZhdWx0LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVHaG9zdChwYWdlWCwgcGFnZVkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX29mZnNldFggIT09IHVuZGVmaW5lZCB8fCB0aGlzLl9vZmZzZXRZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgZm9yIGdob3N0LCBidXQgd2Ugd2lsbCBuZWVkIHRvIHBvc2l0aW9uIGluaXRpYWxseSB0aGUgYmFzZSBlbGVtZW50IHRvIHJlZmxlY3QgYW55IG9mZnNldC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybVggPSAodGhpcy5fb2Zmc2V0WCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb2Zmc2V0WCAtIHRoaXMuX2RlZmF1bHRPZmZzZXRYIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VHJhbnNmb3JtWCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1ZID0gKHRoaXMuX29mZnNldFkgIT09IHVuZGVmaW5lZCA/IHRoaXMuX29mZnNldFkgLSB0aGlzLl9kZWZhdWx0T2Zmc2V0WSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFRyYW5zZm9ybVkodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1YWSh0cmFuc2Zvcm1YLCB0cmFuc2Zvcm1ZKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9kcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbW92ZUFyZ3M6IElEcmFnTW92ZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgICAgICBzdGFydFg6IHRoaXMuX3N0YXJ0WCxcbiAgICAgICAgICAgICAgICBzdGFydFk6IHRoaXMuX3N0YXJ0WSxcbiAgICAgICAgICAgICAgICBwYWdlWDogdGhpcy5fbGFzdFgsXG4gICAgICAgICAgICAgICAgcGFnZVk6IHRoaXMuX2xhc3RZLFxuICAgICAgICAgICAgICAgIG5leHRQYWdlWDogcGFnZVgsXG4gICAgICAgICAgICAgICAgbmV4dFBhZ2VZOiBwYWdlWSxcbiAgICAgICAgICAgICAgICBjYW5jZWw6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5kcmFnTW92ZS5lbWl0KG1vdmVBcmdzKTtcblxuICAgICAgICAgICAgY29uc3Qgc2V0UGFnZVggPSBtb3ZlQXJncy5uZXh0UGFnZVg7XG4gICAgICAgICAgICBjb25zdCBzZXRQYWdlWSA9IG1vdmVBcmdzLm5leHRQYWdlWTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRNb3ZlZFggPSBzZXRQYWdlWCAtIHRoaXMuX3N0YXJ0WDtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRNb3ZlZFkgPSBzZXRQYWdlWSAtIHRoaXMuX3N0YXJ0WTtcblxuICAgICAgICAgICAgaWYgKCFtb3ZlQXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5naG9zdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdob3N0TGVmdCA9IHRoaXMuX2dob3N0U3RhcnRYICsgdXBkYXRlZE1vdmVkWDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5naG9zdFRvcCA9IHRoaXMuX2dob3N0U3RhcnRZICsgdXBkYXRlZE1vdmVkWTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0TW92ZWRYID0gc2V0UGFnZVggLSB0aGlzLl9sYXN0WDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdE1vdmVkWSA9IHNldFBhZ2VZIC0gdGhpcy5fbGFzdFk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZVggPSB0aGlzLmdldFRyYW5zZm9ybVgodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpICsgbGFzdE1vdmVkWDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlWSA9IHRoaXMuZ2V0VHJhbnNmb3JtWSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkgKyBsYXN0TW92ZWRZO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybVhZKHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRHJhZ0V2ZW50cyhwYWdlWCwgcGFnZVksIGV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbGFzdFggPSBzZXRQYWdlWDtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RZID0gc2V0UGFnZVk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogUGVyZm9ybSBkcmFnIGVuZCBsb2dpYyB3aGVuIHJlbGVhc2luZyB0aGUgZ2hvc3RFbGVtZW50IGFuZCBkaXNwYXRjaGluZyBkcm9wIGV2ZW50IGlmIGlneERyb3AgaXMgdW5kZXIgdGhlIHBvaW50ZXIuXG4gICAgICogVGhpcyBtZXRob2QgaXMgYm91bmQgYXQgZmlyc3QgYXQgdGhlIGJhc2UgZWxlbWVudC5cbiAgICAgKiBJZiBkcmFnZ2luZyBzdGFydHMgYW5kIGFmdGVyIHRoZSBnaG9zdEVsZW1lbnQgaXMgcmVuZGVyZWQgdGhlIHBvaW50ZXJJZCBpcyByZWFzc2lnbmVkIHRvIGl0LiBUaGVuIHRoaXMgbWV0aG9kIGlzIGJvdW5kIHRvIGl0LlxuICAgICAqIEBwYXJhbSBldmVudCBQb2ludGVyVXAgZXZlbnQgY2FwdHVyZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgb25Qb2ludGVyVXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jbGlja2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGFnZVgsIHBhZ2VZO1xuICAgICAgICBpZiAodGhpcy5wb2ludGVyRXZlbnRzRW5hYmxlZCB8fCAhdGhpcy50b3VjaEV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZpcnN0IGZvciBwb2ludGVyIGV2ZW50cyBvciBub24gdG91Y2gsIGJlY2F1c2Ugd2UgY2FuIGhhdmUgcG9pbnRlciBldmVudHMgYW5kIHRvdWNoIGV2ZW50cyBhdCBvbmNlLlxuICAgICAgICAgICAgcGFnZVggPSBldmVudC5wYWdlWDtcbiAgICAgICAgICAgIHBhZ2VZID0gZXZlbnQucGFnZVk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50b3VjaEV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHBhZ2VYID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgIHBhZ2VZID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWTtcblxuICAgICAgICAgICAgLy8gUHJldmVudCBzY3JvbGxpbmcgb24gdG91Y2ggd2hpbGUgZHJhZ2dpbmdcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElEcmFnQmFzZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBzdGFydFg6IHRoaXMuX3N0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WTogdGhpcy5fc3RhcnRZLFxuICAgICAgICAgICAgcGFnZVg6IHBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IHBhZ2VZXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BvaW50ZXJEb3duSWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jbGlja2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9kcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3REcm9wQXJlYSAmJiB0aGlzLl9sYXN0RHJvcEFyZWEgIT09IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50ICkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hEcm9wRXZlbnQoZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZLCBldmVudCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYW5pbWF0ZU9uUmVsZWFzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvT3JpZ2luKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0VuZC5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmFuaW1JblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIG91ciBvd24gY2xpY2sgZXZlbnQgYmVjYXVzZSB3aGVuIHRoZXJlIGlzIG5vIGdob3N0LCBuYXRpdmUgY2xpY2sgY2Fubm90IGJlIHByZXZlbnRlZCB3aGVuIGRyYWdnaW5nLlxuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnQ2xpY2suZW1pdChldmVudEFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRXhlY3V0ZSB0aGlzIG1ldGhvZCB3aGUgdGhlIHBvaW50ZXIgY2FwdHVyZSBoYXMgYmVlbiBsb3N0LlxuICAgICAqIFRoaXMgbWVhbnMgdGhhdCBkdXJpbmcgZHJhZ2dpbmcgdGhlIHVzZXIgaGFzIHBlcmZvcm1lZCBvdGhlciBhY3Rpb24gbGlrZSByaWdodCBjbGlja2luZyBhbmQgdGhlbiBjbGlja2luZyBzb21ld2hlcmUgZWxzZS5cbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBkcmFnIHN0YXRlIGlzIGJlaW5nIHJlc2V0IGluIHRoaXMgY2FzZSBhcyBpZiB0aGUgdXNlciByZWxlYXNlZCB0aGUgZHJhZ2dlZCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSBldmVudCBFdmVudCBjYXB0dXJlZFxuICAgICAqL1xuICAgIHB1YmxpYyBvblBvaW50ZXJMb3N0KGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5fY2xpY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgIHN0YXJ0WDogdGhpcy5fc3RhcnRYLFxuICAgICAgICAgICAgc3RhcnRZOiB0aGlzLl9zdGFydFksXG4gICAgICAgICAgICBwYWdlWDogZXZlbnQucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogZXZlbnQucGFnZVlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcG9pbnRlckRvd25JZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NsaWNrZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2RyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdFbmQuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5hbmltYXRlT25SZWxlYXNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9PcmlnaW4oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuYW5pbUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBDcmVhdGUgZ2hvc3QgZWxlbWVudCAtIGlmIGEgTm9kZSBvYmplY3QgaXMgcHJvdmlkZWQgaXQgY3JlYXRlcyBhIGNsb25lIG9mIHRoYXQgbm9kZSxcbiAgICAgKiBvdGhlcndpc2UgaXQgY2xvbmVzIHRoZSBob3N0IGVsZW1lbnQuXG4gICAgICogQmluZCBhbGwgbmVlZGVkIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0gcGFnZVggTGF0ZXN0IHBvaW50ZXIgcG9zaXRpb24gb24gdGhlIFggYXhpcyByZWxhdGl2ZSB0byB0aGUgcGFnZS5cbiAgICAgKiBAcGFyYW0gcGFnZVkgTGF0ZXN0IHBvaW50ZXIgcG9zaXRpb24gb24gdGhlIFkgYXhpcyByZWxhdGl2ZSB0byB0aGUgcGFnZS5cbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgTm9kZSBvYmplY3QgdG8gYmUgY2xvbmVkLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjcmVhdGVHaG9zdChwYWdlWCwgcGFnZVksIG5vZGU6IGFueSA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdob3N0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZHluYW1pY0dob3N0UmVmO1xuICAgICAgICBpZiAodGhpcy5naG9zdFRlbXBsYXRlKSB7XG4gICAgICAgICAgICBkeW5hbWljR2hvc3RSZWYgPSB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMuZ2hvc3RUZW1wbGF0ZSwgdGhpcy5naG9zdENvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQgPSBkeW5hbWljR2hvc3RSZWYucm9vdE5vZGVzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQgPSBub2RlID8gbm9kZS5jbG9uZU5vZGUodHJ1ZSkgOiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b3RhbE1vdmVkWCA9IHBhZ2VYIC0gdGhpcy5fc3RhcnRYO1xuICAgICAgICBjb25zdCB0b3RhbE1vdmVkWSA9IHBhZ2VZIC0gdGhpcy5fc3RhcnRZO1xuICAgICAgICB0aGlzLl9naG9zdEhvc3RYID0gdGhpcy5naG9zdEhvc3QgPyB0aGlzLmdob3N0SG9zdE9mZnNldExlZnQodGhpcy5naG9zdEhvc3QpIDogMDtcbiAgICAgICAgdGhpcy5fZ2hvc3RIb3N0WSA9IHRoaXMuZ2hvc3RIb3N0ID8gdGhpcy5naG9zdEhvc3RPZmZzZXRUb3AodGhpcy5naG9zdEhvc3QpIDogMDtcblxuICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMC4wcyc7XG4gICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuXG4gICAgICAgIGlmICh0aGlzLmdob3N0Q2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5naG9zdEVsZW1lbnQsIHRoaXMuZ2hvc3RDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjcmVhdGVFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgIGdob3N0RWxlbWVudDogdGhpcy5naG9zdEVsZW1lbnQsXG4gICAgICAgICAgICBjYW5jZWw6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2hvc3RDcmVhdGUuZW1pdChjcmVhdGVFdmVudEFyZ3MpO1xuICAgICAgICBpZiAoY3JlYXRlRXZlbnRBcmdzLmNhbmNlbCkge1xuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2hvc3RUZW1wbGF0ZSAmJiBkeW5hbWljR2hvc3RSZWYpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljR2hvc3RSZWYuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ2hvc3RIb3N0KSB7XG4gICAgICAgICAgICB0aGlzLmdob3N0SG9zdC5hcHBlbmRDaGlsZCh0aGlzLmdob3N0RWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZ2hvc3RFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdob3N0TWFyZ2luTGVmdCA9IHBhcnNlSW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5naG9zdEVsZW1lbnQpWydtYXJnaW4tbGVmdCddLCAxMCk7XG4gICAgICAgIGNvbnN0IGdob3N0TWFyZ2luVG9wID0gcGFyc2VJbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmdob3N0RWxlbWVudClbJ21hcmdpbi10b3AnXSwgMTApO1xuICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5zdHlsZS5sZWZ0ID0gKHRoaXMuX2dob3N0U3RhcnRYIC0gZ2hvc3RNYXJnaW5MZWZ0ICsgdG90YWxNb3ZlZFggLSB0aGlzLl9naG9zdEhvc3RYKSArICdweCc7XG4gICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnN0eWxlLnRvcCA9ICh0aGlzLl9naG9zdFN0YXJ0WSAtIGdob3N0TWFyZ2luVG9wICsgdG90YWxNb3ZlZFkgLSB0aGlzLl9naG9zdEhvc3RYKSArICdweCc7XG5cbiAgICAgICAgaWYgKHRoaXMucG9pbnRlckV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIFRoZSBnaG9zdEVsZW1lbnQgdGFrZXMgY29udHJvbCBmb3IgbW92aW5nIGFuZCBkcmFnZ2luZyBhZnRlciBpdCBoYXMgYmVlbiByZW5kZXJlZC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wb2ludGVyRG93bklkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc2V0UG9pbnRlckNhcHR1cmUodGhpcy5fcG9pbnRlckRvd25JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJNb3ZlKGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25Qb2ludGVyVXAoYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvc3Rwb2ludGVyY2FwdHVyZScsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJMb3N0KGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFuc2l0aW9uIGFuaW1hdGlvbiB3aGVuIHRoZSBnaG9zdEVsZW1lbnQgaXMgcmVsZWFzZWQgYW5kIGl0IHJldHVybnMgdG8gaXQncyBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZChhcmdzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSGlkZSB0aGUgYmFzZSBhZnRlciB0aGUgZ2hvc3RFbGVtZW50IGlzIGNyZWF0ZWQsIGJlY2F1c2Ugb3RoZXJ3aXNlIHRoZSBnaG9zdEVsZW1lbnQgd2lsbCBiZSBub3QgdmlzaWJsZS5cbiAgICAgICAgaWYgKHRoaXMuaGlkZUJhc2VPbkRyYWcpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBEaXNwYXRjaCBjdXN0b20gaWd4RHJhZ0VudGVyL2lneERyYWdMZWF2ZSBldmVudHMgYmFzZWQgb24gY3VycmVudCBwb2ludGVyIHBvc2l0aW9uIGFuZCBpZiBkcm9wIGFyZWEgaXMgdW5kZXIuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRpc3BhdGNoRHJhZ0V2ZW50cyhwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyLCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIGxldCB0b3BEcm9wQXJlYTtcbiAgICAgICAgY29uc3QgY3VzdG9tRXZlbnRBcmdzOiBJZ3hEcmFnQ3VzdG9tRXZlbnREZXRhaWxzID0ge1xuICAgICAgICAgICAgc3RhcnRYOiB0aGlzLl9zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IHRoaXMuX3N0YXJ0WSxcbiAgICAgICAgICAgIHBhZ2VYOiBwYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBwYWdlWSxcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzRnJvbVBvaW50ID0gdGhpcy5nZXRFbGVtZW50c0F0UG9pbnQocGFnZVgsIHBhZ2VZKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50c0Zyb21Qb2ludC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzRnJvbVBvaW50W2ldLmdldEF0dHJpYnV0ZSgnZHJvcHBhYmxlJykgPT09ICd0cnVlJyAmJlxuICAgICAgICAgICAgICAgIGVsZW1lbnRzRnJvbVBvaW50W2ldICE9PSB0aGlzLmdob3N0RWxlbWVudCAmJiBlbGVtZW50c0Zyb21Qb2ludFtpXSAhPT0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0b3BEcm9wQXJlYSA9IGVsZW1lbnRzRnJvbVBvaW50W2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvcERyb3BBcmVhICYmXG4gICAgICAgICAgICAoIXRoaXMuX2xhc3REcm9wQXJlYSB8fCAodGhpcy5fbGFzdERyb3BBcmVhICYmIHRoaXMuX2xhc3REcm9wQXJlYSAhPT0gdG9wRHJvcEFyZWEpKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0RHJvcEFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuX2xhc3REcm9wQXJlYSwgJ2lneERyYWdMZWF2ZScsIGN1c3RvbUV2ZW50QXJncyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdERyb3BBcmVhID0gdG9wRHJvcEFyZWE7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuX2xhc3REcm9wQXJlYSwgJ2lneERyYWdFbnRlcicsIGN1c3RvbUV2ZW50QXJncyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0b3BEcm9wQXJlYSAmJiB0aGlzLl9sYXN0RHJvcEFyZWEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fbGFzdERyb3BBcmVhLCAnaWd4RHJhZ0xlYXZlJywgY3VzdG9tRXZlbnRBcmdzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0RHJvcEFyZWEgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICBpZiAodG9wRHJvcEFyZWEpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0b3BEcm9wQXJlYSwgJ2lneERyYWdPdmVyJywgY3VzdG9tRXZlbnRBcmdzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBEaXNwYXRjaCBjdXN0b20gaWd4RHJvcCBldmVudCBiYXNlZCBvbiBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24gaWYgdGhlcmUgaXMgbGFzdCByZWNvcmRlciBkcm9wIGFyZWEgdW5kZXIgdGhlIHBvaW50ZXIuXG4gICAgICogTGFzdCByZWNvcmRlciBkcm9wIGFyZWEgaXMgdXBkYXRlZCBpbiBAZGlzcGF0Y2hEcmFnRXZlbnRzIG1ldGhvZC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZGlzcGF0Y2hEcm9wRXZlbnQocGFnZVg6IG51bWJlciwgcGFnZVk6IG51bWJlciwgb3JpZ2luYWxFdmVudCkge1xuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElneERyYWdDdXN0b21FdmVudERldGFpbHMgPSB7XG4gICAgICAgICAgICBzdGFydFg6IHRoaXMuX3N0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WTogdGhpcy5fc3RhcnRZLFxuICAgICAgICAgICAgcGFnZVg6IHBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IHBhZ2VZLFxuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuX2xhc3REcm9wQXJlYSwgJ2lneERyb3AnLCBldmVudEFyZ3MpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fbGFzdERyb3BBcmVhLCAnaWd4RHJhZ0xlYXZlJywgZXZlbnRBcmdzKTtcbiAgICAgICAgdGhpcy5fbGFzdERyb3BBcmVhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9uVHJhbnNpdGlvbkVuZChldmVudCkge1xuICAgICAgICBpZiAoKCF0aGlzLl9kcmFnU3RhcnRlZCAmJiAhdGhpcy5hbmltSW5Qcm9ncmVzcykgfHwgdGhpcy5fY2xpY2tlZCkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGlmIG5vIGRyYWdnaW5nIHN0YXJ0ZWQgYW5kIHRoZXJlIGlzIG5vIGFuaW1hdGlvbiBpbiBwcm9ncmVzcy5cbiAgICAgICAgICAgIHJldHVybiA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5naG9zdCAmJiB0aGlzLmdob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fZ2hvc3RTdGFydFggPSB0aGlzLmJhc2VMZWZ0ICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxMZWZ0KCk7XG4gICAgICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WSA9IHRoaXMuYmFzZVRvcCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGdob3N0RGVzdHJveUFyZ3M6IElEcmFnR2hvc3RCYXNlRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgICAgICAgICAgIGdob3N0RWxlbWVudDogdGhpcy5naG9zdEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgY2FuY2VsOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3REZXN0cm95LmVtaXQoZ2hvc3REZXN0cm95QXJncyk7XG4gICAgICAgICAgICBpZiAoZ2hvc3REZXN0cm95QXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhpZGVCYXNlT25EcmFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5naG9zdEVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmdob3N0KSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSAnJztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwLjBzJztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9ICcnO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kcmFnU3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEV4ZWN1dGUgdHJhbnNpdGlvbmVkIGFmdGVyIGV2ZXJ5dGhpbmcgaXMgcmVzZXQgc28gaWYgdGhlIHVzZXIgc2V0cyBuZXcgbG9jYXRpb24gb24gdGhlIGJhc2Ugbm93IGl0IHdvdWxkIHdvcmsgYXMgZXhwZWN0ZWQuXG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uZWQuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgc3RhcnRYOiB0aGlzLl9zdGFydFgsXG4gICAgICAgICAgICAgICAgc3RhcnRZOiB0aGlzLl9zdGFydFksXG4gICAgICAgICAgICAgICAgcGFnZVg6IHRoaXMuX3N0YXJ0WCxcbiAgICAgICAgICAgICAgICBwYWdlWTogdGhpcy5fc3RhcnRZXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRFbGVtZW50c0F0UG9pbnQocGFnZVg6IG51bWJlciwgcGFnZVk6IG51bWJlcikge1xuICAgICAgICAvLyBjb3JyZWN0IHRoZSBjb29yZGluYXRlcyB3aXRoIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiwgYmVjYXVzZVxuICAgICAgICAvLyBkb2N1bWVudC5lbGVtZW50c0Zyb21Qb2ludCBjb25zaWRlciBwb3NpdGlvbiB3aXRoaW4gdGhlIGN1cnJlbnQgdmlld3BvcnRcbiAgICAgICAgLy8gd2luZG93LnBhZ2VYT2Zmc2V0ID09IHdpbmRvdy5zY3JvbGxYOyAvLyBhbHdheXMgdHJ1ZVxuICAgICAgICAvLyB1c2luZyB3aW5kb3cucGFnZVhPZmZzZXQgZm9yIElFOSBjb21wYXRpYmlsaXR5XG4gICAgICAgIGNvbnN0IHZpZXdQb3J0WCA9IHBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgICAgICBjb25zdCB2aWV3UG9ydFkgPSBwYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgaWYgKGRvY3VtZW50Wydtc0VsZW1lbnRzRnJvbVBvaW50J10pIHtcbiAgICAgICAgICAgIC8vIEVkZ2UgYW5kIElFIHNwZWNpYWwgc25vd2ZsYWtlc1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBkb2N1bWVudFsnbXNFbGVtZW50c0Zyb21Qb2ludCddKHZpZXdQb3J0WCwgdmlld1BvcnRZKTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50cyA9PT0gbnVsbCA/IFtdIDogZWxlbWVudHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlciBicm93c2VycyBsaWtlIENocm9tZSwgRmlyZWZveCwgT3BlcmFcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5lbGVtZW50c0Zyb21Qb2ludCh2aWV3UG9ydFgsIHZpZXdQb3J0WSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRpc3BhdGNoRXZlbnQodGFyZ2V0LCBldmVudE5hbWU6IHN0cmluZywgZXZlbnRBcmdzOiBJZ3hEcmFnQ3VzdG9tRXZlbnREZXRhaWxzKSB7XG4gICAgICAgIC8vIFRoaXMgd2F5IGlzIElFMTEgY29tcGF0aWJsZS5cbiAgICAgICAgY29uc3QgZHJhZ0xlYXZlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgZHJhZ0xlYXZlRXZlbnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZmFsc2UsIGZhbHNlLCBldmVudEFyZ3MpO1xuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChkcmFnTGVhdmVFdmVudCk7XG4gICAgICAgIC8vIE90aGVyd2lzZSBjYW4gYmUgdXNlZCBgdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZXZlbnRBcmdzKSk7YFxuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRUcmFuc2Zvcm1YKGVsZW0pIHtcbiAgICAgICAgbGV0IHBvc1ggPSAwO1xuICAgICAgICBpZiAoZWxlbS5zdHlsZS50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IGVsZW0uc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gbWF0cml4ID8gbWF0cml4Lm1hdGNoKC8tP1tcXGRcXC5dKy9nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHBvc1ggPSB2YWx1ZXMgPyBOdW1iZXIodmFsdWVzWyAxIF0pIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3NYO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRUcmFuc2Zvcm1ZKGVsZW0pIHtcbiAgICAgICAgbGV0IHBvc1kgPSAwO1xuICAgICAgICBpZiAoZWxlbS5zdHlsZS50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IGVsZW0uc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gbWF0cml4ID8gbWF0cml4Lm1hdGNoKC8tP1tcXGRcXC5dKy9nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHBvc1kgPSB2YWx1ZXMgPyBOdW1iZXIodmFsdWVzWyAyIF0pIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3NZO1xuICAgIH1cblxuICAgIC8qKiBNZXRob2Qgc2V0dGluZyB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgYmFzZSBkcmFnZ2FibGUgZWxlbWVudC4gKi9cbiAgICBwcm90ZWN0ZWQgc2V0VHJhbnNmb3JtWFkoeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJ3B4LCAnICsgeSArICdweCwgMHB4KSc7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldFdpbmRvd1Njcm9sbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxZID8gd2luZG93LnNjcm9sbFkgOiAod2luZG93LnBhZ2VZT2Zmc2V0ID8gd2luZG93LnBhZ2VZT2Zmc2V0IDogMCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldFdpbmRvd1Njcm9sbExlZnQoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuc2Nyb2xsWCA/IHdpbmRvdy5zY3JvbGxYIDogKHdpbmRvdy5wYWdlWE9mZnNldCA/IHdpbmRvdy5wYWdlWE9mZnNldCA6IDApO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnaG9zdEhvc3RPZmZzZXRMZWZ0KGdob3N0SG9zdDogYW55KSB7XG4gICAgICAgIGNvbnN0IGdob3N0UG9zaXRpb24gPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGdob3N0SG9zdCkuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKTtcbiAgICAgICAgaWYgKGdob3N0UG9zaXRpb24gPT09ICdzdGF0aWMnICYmIGdob3N0SG9zdC5vZmZzZXRQYXJlbnQgJiYgZ2hvc3RIb3N0Lm9mZnNldFBhcmVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2hvc3RQb3NpdGlvbiA9PT0gJ3N0YXRpYycgJiYgZ2hvc3RIb3N0Lm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGdob3N0SG9zdC5vZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIHRoaXMuZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnaG9zdEhvc3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIHRoaXMuZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnaG9zdEhvc3RPZmZzZXRUb3AoZ2hvc3RIb3N0OiBhbnkpIHtcbiAgICAgICAgY29uc3QgZ2hvc3RQb3NpdGlvbiA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZ2hvc3RIb3N0KS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpO1xuICAgICAgICBpZiAoZ2hvc3RQb3NpdGlvbiA9PT0gJ3N0YXRpYycgJiYgZ2hvc3RIb3N0Lm9mZnNldFBhcmVudCAmJiBnaG9zdEhvc3Qub2Zmc2V0UGFyZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIGlmIChnaG9zdFBvc2l0aW9uID09PSAnc3RhdGljJyAmJiBnaG9zdEhvc3Qub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2hvc3RIb3N0Lm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLSB0aGlzLmdldFdpbmRvd1Njcm9sbFRvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnaG9zdEhvc3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gdGhpcy5nZXRXaW5kb3dTY3JvbGxUb3AoKTtcbiAgICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIGV4cG9ydEFzOiAnZHJvcCcsXG4gICAgc2VsZWN0b3I6ICdbaWd4RHJvcF0nXG59KVxuZXhwb3J0IGNsYXNzIElneERyb3BEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICAvKipcbiAgICAgKiAtIFNhdmUgZGF0YSBpbnNpZGUgdGhlIGBpZ3hEcm9wYCBkaXJlY3RpdmUuIFRoaXMgY2FuIGJlIHNldCB3aGVuIGluc3RhbmNpbmcgYGlneERyb3BgIG9uIGFuIGVsZW1lbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgW2lneERyb3BdPVwieyBzb3VyY2U6IG15RWxlbWVudCB9XCI+PC9kaXY+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoJ2lneERyb3AnKVxuICAgIHB1YmxpYyBkYXRhOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBwcm92aWRlIGEgd2F5IGZvciBpZ3hEcmFnIGFuZCBpZ3hEcm9wIHRvIGJlIGxpbmtlZCB0aHJvdWdoIGNoYW5uZWxzLlxuICAgICAqIEl0IGFjY2VwdHMgc2luZ2xlIHZhbHVlIG9yIGFuIGFycmF5IG9mIHZhbHVlcyBhbmQgZXZhbHVhdGVzIHRoZW4gdXNpbmcgc3RyaWN0IGVxdWFsaXR5LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2RyYWdDaGFubmVsXT1cIidvZGQnXCI+XG4gICAgICogICAgICAgICA8c3Bhbj45NTwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyb3AgW2Ryb3BDaGFubmVsXT1cIlsnb2RkJywgJ2lycmF0aW9uYWwnXVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+TnVtYmVycyBkcm9wIGFyZWEhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcm9wRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZHJvcENoYW5uZWw6IG51bWJlciB8IHN0cmluZyB8IG51bWJlcltdIHwgc3RyaW5nW107XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzcGVjaWZpZXMgYSBkcm9wIHN0cmF0ZWd5IHR5cGUgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gYW4gYElneERyYWdgIGVsZW1lbnQgaXMgcmVsZWFzZWQgaW5zaWRlXG4gICAgICogIHRoZSBjdXJyZW50IGRyb3AgYXJlYS4gVGhlIHByb3ZpZGVkIHN0cmF0ZWdpZXMgYXJlOlxuICAgICAqICAtIElneERlZmF1bHREcm9wU3RyYXRlZ3kgLSBUaGlzIGlzIHRoZSBkZWZhdWx0IGJhc2Ugc3RyYXRlZ3kgYW5kIGl0IGRvZXNuJ3QgcGVyZm9ybSBhbnkgYWN0aW9ucy5cbiAgICAgKiAgLSBJZ3hBcHBlbmREcm9wU3RyYXRlZ3kgLSBBcHBlbmRzIHRoZSBkcm9wcGVkIGVsZW1lbnQgdG8gbGFzdCBwb3NpdGlvbiBhcyBhIGRpcmVjdCBjaGlsZCB0byB0aGUgYGlneERyb3BgLlxuICAgICAqICAtIElneFByZXBlbmREcm9wU3RyYXRlZ3kgLSBQcmVwZW5kcyB0aGUgZHJvcHBlZCBlbGVtZW50IHRvIGZpcnN0IHBvc2l0aW9uIGFzIGEgZGlyZWN0IGNoaWxkIHRvIHRoZSBgaWd4RHJvcGAuXG4gICAgICogIC0gSWd4SW5zZXJ0RHJvcFN0cmF0ZWd5IC0gSWYgdGhlIGRyb3BwZWQgZWxlbWVudCBpcyByZWxlYXNlZCBhYm92ZSBhIGNoaWxkIGVsZW1lbnQgb2YgdGhlIGBpZ3hEcm9wYCwgaXQgd2lsbCBiZSBpbnNlcnRlZFxuICAgICAqICAgICAgYXQgdGhhdCBwb3NpdGlvbi4gT3RoZXJ3aXNlIHRoZSBkcm9wcGVkIGVsZW1lbnQgd2lsbCBiZSBhcHBlbmRlZCBpZiByZWxlYXNlZCBvdXRzaWRlIGFueSBjaGlsZCBvZiB0aGUgYGlneERyb3BgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWc+XG4gICAgICogICAgICA8c3Bhbj5EcmFnTWU8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogPGRpdiBpZ3hEcm9wIFtkcm9wU3RyYXRlZ3ldPVwibXlEcm9wU3RyYXRlZ3lcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPk51bWJlcnMgZHJvcCBhcmVhITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHsgSWd4QXBwZW5kRHJvcFN0cmF0ZWd5IH0gZnJvbSAnaWduaXRldWktYW5ndWxhcic7XG4gICAgICpcbiAgICAgKiBleHBvcnQgY2xhc3MgQXBwIHtcbiAgICAgKiAgICAgIHB1YmxpYyBteURyb3BTdHJhdGVneSA9IElneEFwcGVuZERyb3BTdHJhdGVneTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgZHJvcFN0cmF0ZWd5KGNsYXNzUmVmOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fZHJvcFN0cmF0ZWd5ID0gbmV3IGNsYXNzUmVmKHRoaXMuX3JlbmRlcmVyKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGRyb3BTdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3BTdHJhdGVneTtcbiAgICB9XG5cbiAgICAvKiogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGVudGVycyB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAoZW50ZXIpPVwiZHJhZ0VudGVyKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0VudGVyKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgZW50ZXJlZCB0aGUgY2hpcCBhcmVhIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZW50ZXIgPSBuZXcgRXZlbnRFbWl0dGVyPElEcm9wQmFzZUV2ZW50QXJncz4oKTtcblxuICAgICAgICAvKiogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGVudGVycyB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAoZW50ZXIpPVwiZHJhZ0VudGVyKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0VudGVyKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgZW50ZXJlZCB0aGUgY2hpcCBhcmVhIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb3ZlciA9IG5ldyBFdmVudEVtaXR0ZXI8SURyb3BCYXNlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIGRyYWdnZWQgZWxlbWVudCBsZWF2ZXMgdGhlIGFyZWEgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgY2xhc3M9XCJjYWdlQXJlYVwiIGlneERyb3AgKGxlYXZlKT1cImRyYWdMZWF2ZSgpXCIgKGlneERyYWdFbnRlcik9XCJvbkRyYWdDYWdlRW50ZXIoKVwiIChpZ3hEcmFnTGVhdmUpPVwib25EcmFnQ2FnZUxlYXZlKClcIj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGRyYWdMZWF2ZSgpe1xuICAgICAqICAgICBhbGVydChcIkEgZHJhZ2dhYmxlIGVsZW1lbnQgaGFzIGxlZnQgdGhlIGNoaXAgYXJlYSFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcm9wRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGxlYXZlID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJvcEJhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKiogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGlzIGRyb3BwZWQgaW4gdGhlIGFyZWEgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogU2luY2UgdGhlIGBpZ3hEcm9wYCBoYXMgZGVmYXVsdCBsb2dpYyB0aGF0IGFwcGVuZHMgdGhlIGRyb3BwZWQgZWxlbWVudCBhcyBhIGNoaWxkLCBpdCBjYW4gYmUgY2FuY2VsZWQgaGVyZS5cbiAgICAgKiBUbyBjYW5jZWwgdGhlIGRlZmF1bHQgbG9naWMgdGhlIGBjYW5jZWxgIHByb3BlcnR5IG9mIHRoZSBldmVudCBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAoZHJvcHBlZCk9XCJkcmFnRHJvcCgpXCIgKGlneERyYWdFbnRlcik9XCJvbkRyYWdDYWdlRW50ZXIoKVwiIChpZ3hEcmFnTGVhdmUpPVwib25EcmFnQ2FnZUxlYXZlKClcIj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGRyYWdEcm9wKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgYmVlbiBkcm9wcGVkIGluIHRoZSBjaGlwIGFyZWEhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJvcERpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBkcm9wcGVkID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJvcERyb3BwZWRFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmRyb3BwYWJsZScpXG4gICAgcHVibGljIGRyb3BwYWJsZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5kcmFnT3ZlcicpXG4gICAgcHVibGljIGRyYWdvdmVyID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9kZXN0cm95ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcbiAgICBwcm90ZWN0ZWQgX2Ryb3BTdHJhdGVneTogSURyb3BTdHJhdGVneTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbGVtZW50OiBFbGVtZW50UmVmLCBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5fZHJvcFN0cmF0ZWd5ID0gbmV3IElneERlZmF1bHREcm9wU3RyYXRlZ3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2lneERyYWdFbnRlcicpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vbkRyYWdFbnRlcihyZXMgYXMgQ3VzdG9tRXZlbnQ8SWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscz4pKTtcblxuICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnaWd4RHJhZ0xlYXZlJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uRHJhZ0xlYXZlKHJlcykpO1xuICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnaWd4RHJhZ092ZXInKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSkuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25EcmFnT3ZlcihyZXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveS5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLl9kZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkRyYWdPdmVyKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQb3NYID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICAgICAgICBjb25zdCBlbGVtZW50UG9zWSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBldmVudC5kZXRhaWwucGFnZVggLSBlbGVtZW50UG9zWDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IGV2ZW50LmRldGFpbC5wYWdlWSAtIGVsZW1lbnRQb3NZO1xuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElEcm9wQmFzZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LmRldGFpbC5vcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBkcmFnOiBldmVudC5kZXRhaWwub3duZXIsXG4gICAgICAgICAgICBkcmFnRGF0YTogZXZlbnQuZGV0YWlsLm93bmVyLmRhdGEsXG4gICAgICAgICAgICBzdGFydFg6IGV2ZW50LmRldGFpbC5zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IGV2ZW50LmRldGFpbC5zdGFydFksXG4gICAgICAgICAgICBwYWdlWDogZXZlbnQuZGV0YWlsLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50LmRldGFpbC5wYWdlWSxcbiAgICAgICAgICAgIG9mZnNldFg6IG9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRZOiBvZmZzZXRZXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5vdmVyLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkRyYWdFbnRlcihldmVudDogQ3VzdG9tRXZlbnQ8SWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscz4pIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ0xpbmtlZChldmVudC5kZXRhaWwub3duZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYWdvdmVyID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZWxlbWVudFBvc1ggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxMZWZ0KCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQb3NZID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxUb3AoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IGV2ZW50LmRldGFpbC5wYWdlWCAtIGVsZW1lbnRQb3NYO1xuICAgICAgICBjb25zdCBvZmZzZXRZID0gZXZlbnQuZGV0YWlsLnBhZ2VZIC0gZWxlbWVudFBvc1k7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJnczogSURyb3BCYXNlRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQuZGV0YWlsLm9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgIGRyYWc6IGV2ZW50LmRldGFpbC5vd25lcixcbiAgICAgICAgICAgIGRyYWdEYXRhOiBldmVudC5kZXRhaWwub3duZXIuZGF0YSxcbiAgICAgICAgICAgIHN0YXJ0WDogZXZlbnQuZGV0YWlsLnN0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WTogZXZlbnQuZGV0YWlsLnN0YXJ0WSxcbiAgICAgICAgICAgIHBhZ2VYOiBldmVudC5kZXRhaWwucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogZXZlbnQuZGV0YWlsLnBhZ2VZLFxuICAgICAgICAgICAgb2Zmc2V0WDogb2Zmc2V0WCxcbiAgICAgICAgICAgIG9mZnNldFk6IG9mZnNldFlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbnRlci5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25EcmFnTGVhdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ0xpbmtlZChldmVudC5kZXRhaWwub3duZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYWdvdmVyID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQb3NYID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICAgICAgICBjb25zdCBlbGVtZW50UG9zWSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBldmVudC5kZXRhaWwucGFnZVggLSBlbGVtZW50UG9zWDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IGV2ZW50LmRldGFpbC5wYWdlWSAtIGVsZW1lbnRQb3NZO1xuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElEcm9wQmFzZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LmRldGFpbC5vcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBkcmFnOiBldmVudC5kZXRhaWwub3duZXIsXG4gICAgICAgICAgICBkcmFnRGF0YTogZXZlbnQuZGV0YWlsLm93bmVyLmRhdGEsXG4gICAgICAgICAgICBzdGFydFg6IGV2ZW50LmRldGFpbC5zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IGV2ZW50LmRldGFpbC5zdGFydFksXG4gICAgICAgICAgICBwYWdlWDogZXZlbnQuZGV0YWlsLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50LmRldGFpbC5wYWdlWSxcbiAgICAgICAgICAgIG9mZnNldFg6IG9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRZOiBvZmZzZXRZXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGVhdmUuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcignaWd4RHJvcCcsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIG9uRHJhZ0Ryb3AoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ0xpbmtlZChldmVudC5kZXRhaWwub3duZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbGVtZW50UG9zWCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyB0aGlzLmdldFdpbmRvd1Njcm9sbExlZnQoKTtcbiAgICAgICAgY29uc3QgZWxlbWVudFBvc1kgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB0aGlzLmdldFdpbmRvd1Njcm9sbFRvcCgpO1xuICAgICAgICBjb25zdCBvZmZzZXRYID0gZXZlbnQuZGV0YWlsLnBhZ2VYIC0gZWxlbWVudFBvc1g7XG4gICAgICAgIGNvbnN0IG9mZnNldFkgPSBldmVudC5kZXRhaWwucGFnZVkgLSBlbGVtZW50UG9zWTtcbiAgICAgICAgY29uc3QgYXJnczogSURyb3BEcm9wcGVkRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudC5kZXRhaWwub3JpZ2luYWxFdmVudCxcbiAgICAgICAgICAgIGRyYWc6IGV2ZW50LmRldGFpbC5vd25lcixcbiAgICAgICAgICAgIGRyYWdEYXRhOiBldmVudC5kZXRhaWwub3duZXIuZGF0YSxcbiAgICAgICAgICAgIHN0YXJ0WDogZXZlbnQuZGV0YWlsLnN0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WTogZXZlbnQuZGV0YWlsLnN0YXJ0WSxcbiAgICAgICAgICAgIHBhZ2VYOiBldmVudC5kZXRhaWwucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogZXZlbnQuZGV0YWlsLnBhZ2VZLFxuICAgICAgICAgICAgb2Zmc2V0WDogb2Zmc2V0WCxcbiAgICAgICAgICAgIG9mZnNldFk6IG9mZnNldFksXG4gICAgICAgICAgICBjYW5jZWw6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJvcHBlZC5lbWl0KGFyZ3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5fZHJvcFN0cmF0ZWd5ICYmICFhcmdzLmNhbmNlbCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHNBdFBvaW50ID0gZXZlbnQuZGV0YWlsLm93bmVyLmdldEVsZW1lbnRzQXRQb2ludChldmVudC5kZXRhaWwucGFnZVgsIGV2ZW50LmRldGFpbC5wYWdlWSk7XG4gICAgICAgICAgICBjb25zdCBpbnNlcnRJbmRleCA9IHRoaXMuZ2V0SW5zZXJ0SW5kZXhBdChldmVudC5kZXRhaWwub3duZXIsIGVsZW1lbnRzQXRQb2ludCk7XG4gICAgICAgICAgICB0aGlzLl9kcm9wU3RyYXRlZ3kuZHJvcEFjdGlvbihldmVudC5kZXRhaWwub3duZXIsIHRoaXMsIGluc2VydEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRXaW5kb3dTY3JvbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuc2Nyb2xsWSA/IHdpbmRvdy5zY3JvbGxZIDogKHdpbmRvdy5wYWdlWU9mZnNldCA/IHdpbmRvdy5wYWdlWU9mZnNldCA6IDApO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRXaW5kb3dTY3JvbGxMZWZ0KCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbFggPyB3aW5kb3cuc2Nyb2xsWCA6ICh3aW5kb3cucGFnZVhPZmZzZXQgPyB3aW5kb3cucGFnZVhPZmZzZXQgOiAwKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgaXNEcmFnTGlua2VkKGRyYWc6IElneERyYWdEaXJlY3RpdmUpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZHJhZ0xpbmtBcnJheSA9IGRyYWcuZHJhZ0NoYW5uZWwgaW5zdGFuY2VvZiBBcnJheTtcbiAgICAgICAgY29uc3QgZHJvcExpbmtBcnJheSA9IHRoaXMuZHJvcENoYW5uZWwgaW5zdGFuY2VvZiBBcnJheTtcblxuICAgICAgICBpZiAoIWRyYWdMaW5rQXJyYXkgJiYgIWRyb3BMaW5rQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BDaGFubmVsID09PSBkcmFnLmRyYWdDaGFubmVsO1xuICAgICAgICB9IGVsc2UgaWYgKCFkcmFnTGlua0FycmF5ICYmIGRyb3BMaW5rQXJyYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRyb3BMaW5rcyA9IDxBcnJheTxhbnk+PnRoaXMuZHJvcENoYW5uZWw7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRyb3BMaW5rcy5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZHJvcExpbmtzW2ldID09PSBkcmFnLmRyYWdDaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkcmFnTGlua0FycmF5ICYmICFkcm9wTGlua0FycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBkcmFnTGlua3MgPSA8QXJyYXk8YW55Pj5kcmFnLmRyYWdDaGFubmVsO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcmFnTGlua3MubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdMaW5rc1tpXSA9PT0gdGhpcy5kcm9wQ2hhbm5lbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkcmFnTGlua3MgPSA8QXJyYXk8YW55Pj5kcmFnLmRyYWdDaGFubmVsO1xuICAgICAgICAgICAgY29uc3QgZHJvcExpbmtzID0gPEFycmF5PGFueT4+dGhpcy5kcm9wQ2hhbm5lbDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHJhZ0xpbmtzLmxlbmd0aDsgaSArKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZHJvcExpbmtzLmxlbmd0aDsgaiArKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ0xpbmtzW2ldID09PSBkcm9wTGlua3Nbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRJbnNlcnRJbmRleEF0KGRyYWdnZWREaXI6IElneERyYWdEaXJlY3RpdmUsIGVsZW1lbnRzQXRQb2ludDogYW55W10pOiBudW1iZXIge1xuICAgICAgICBsZXQgaW5zZXJ0SW5kZXggPSAtMTtcbiAgICAgICAgY29uc3QgZHJvcENoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgICBpZiAoIWRyb3BDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnRJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGNoaWxkVW5kZXIgPSBudWxsO1xuICAgICAgICB3aGlsZSAoIWNoaWxkVW5kZXIgJiYgaSA8IGVsZW1lbnRzQXRQb2ludC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50c0F0UG9pbnRbaV0ucGFyZW50RWxlbWVudCA9PT0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFVuZGVyID0gZWxlbWVudHNBdFBvaW50W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZHJhZ2dlZEVsZW1JbmRleCA9IGRyb3BDaGlsZHJlbi5pbmRleE9mKGRyYWdnZWREaXIuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgaW5zZXJ0SW5kZXggPSBkcm9wQ2hpbGRyZW4uaW5kZXhPZihjaGlsZFVuZGVyKTtcbiAgICAgICAgaWYgKGRyYWdnZWRFbGVtSW5kZXggIT09IC0xICYmIGRyYWdnZWRFbGVtSW5kZXggPCBpbnNlcnRJbmRleCkge1xuICAgICAgICAgICAgaW5zZXJ0SW5kZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnNlcnRJbmRleDtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbSWd4RHJhZ0RpcmVjdGl2ZSwgSWd4RHJvcERpcmVjdGl2ZSwgSWd4RHJhZ0hhbmRsZURpcmVjdGl2ZV0sXG4gICAgZXhwb3J0czogW0lneERyYWdEaXJlY3RpdmUsIElneERyb3BEaXJlY3RpdmUsIElneERyYWdIYW5kbGVEaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIElneERyYWdEcm9wTW9kdWxlIHsgfVxuIl19