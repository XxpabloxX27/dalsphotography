import { ExcelStrings } from './excel-strings';
/**
 * @hidden
 */
export class RootRelsFile {
    writeElement(folder, worksheetData) {
        folder.file('.rels', ExcelStrings.getRels());
    }
}
/**
 * @hidden
 */
export class AppFile {
    writeElement(folder, worksheetData) {
        folder.file('app.xml', ExcelStrings.getApp());
    }
}
/**
 * @hidden
 */
export class CoreFile {
    writeElement(folder, worksheetData) {
        folder.file('core.xml', ExcelStrings.getCore());
    }
}
/**
 * @hidden
 */
export class WorkbookRelsFile {
    writeElement(folder, worksheetData) {
        const hasSharedStrings = worksheetData.isEmpty === false;
        folder.file('workbook.xml.rels', ExcelStrings.getWorkbookRels(hasSharedStrings));
    }
}
/**
 * @hidden
 */
export class ThemeFile {
    writeElement(folder, worksheetData) {
        folder.file('theme1.xml', ExcelStrings.getTheme());
    }
}
/**
 * @hidden
 */
export class WorksheetFile {
    writeElement(folder, worksheetData) {
        const sheetData = [];
        const cols = [];
        let dimension;
        const dictionary = worksheetData.dataDictionary;
        let freezePane = '';
        let maxOutlineLevel = 0;
        if (worksheetData.isEmpty) {
            sheetData.push('<sheetData/>');
            dimension = 'A1';
        }
        else {
            sheetData.push('<sheetData>');
            const height = worksheetData.options.rowHeight;
            const rowHeight = height ? ' ht="' + height + '" customHeight="1"' : '';
            sheetData.push(`<row r="1"${rowHeight}>`);
            for (let i = 0; i < worksheetData.columnCount; i++) {
                const column = ExcelStrings.getExcelColumn(i) + 1;
                const value = dictionary.saveValue(worksheetData.keys[i], i, true);
                sheetData.push(`<c r="${column}" t="s"><v>${value}</v></c>`);
            }
            sheetData.push('</row>');
            for (let i = 1; i < worksheetData.rowCount; i++) {
                if (!worksheetData.isTreeGridData) {
                    sheetData.push(`<row r="${(i + 1)}"${rowHeight}>`);
                }
                else {
                    const rowData = worksheetData.data[i - 1].originalRowData;
                    const sCollapsed = (!rowData.expanded) ? '' : (rowData.expanded === true) ? '' : ` collapsed="1"`;
                    const sHidden = (rowData.parent && this.hasCollapsedParent(rowData)) ? ` hidden="1"` : '';
                    const rowOutlineLevel = rowData.level ? rowData.level : 0;
                    const sOutlineLevel = rowOutlineLevel > 0 ? ` outlineLevel="${rowOutlineLevel}"` : '';
                    maxOutlineLevel = maxOutlineLevel < rowOutlineLevel ? rowOutlineLevel : maxOutlineLevel;
                    sheetData.push(`<row r="${(i + 1)}"${rowHeight}${sOutlineLevel}${sCollapsed}${sHidden}>`);
                }
                for (let j = 0; j < worksheetData.columnCount; j++) {
                    const cellData = WorksheetFile.getCellData(worksheetData, i, j);
                    sheetData.push(cellData);
                }
                sheetData.push('</row>');
            }
            sheetData.push('</sheetData>');
            dimension = 'A1:' + ExcelStrings.getExcelColumn(worksheetData.columnCount - 1) + worksheetData.rowCount;
            cols.push('<cols>');
            for (let i = 0; i < worksheetData.columnCount; i++) {
                const width = dictionary.columnWidths[i];
                // Use the width provided in the options if it exists
                const widthInTwips = worksheetData.options.columnWidth ?
                    worksheetData.options.columnWidth :
                    Math.max(((width / 96) * 14.4), WorksheetFile.MIN_WIDTH);
                cols.push(`<col min="${(i + 1)}" max="${(i + 1)}" width="${widthInTwips}" customWidth="1"/>`);
            }
            cols.push('</cols>');
            if (worksheetData.indexOfLastPinnedColumn !== -1 &&
                !worksheetData.options.ignorePinning &&
                !worksheetData.options.ignoreColumnsOrder) {
                const frozenColumnCount = worksheetData.indexOfLastPinnedColumn + 1;
                const firstCell = ExcelStrings.getExcelColumn(frozenColumnCount) + '1';
                freezePane = `<pane xSplit="${frozenColumnCount}" topLeftCell="${firstCell}" activePane="topRight" state="frozen"/>`;
            }
        }
        const hasTable = !worksheetData.isEmpty && worksheetData.options.exportAsTable;
        folder.file('sheet1.xml', ExcelStrings.getSheetXML(dimension, freezePane, cols.join(''), sheetData.join(''), hasTable, worksheetData.isTreeGridData, maxOutlineLevel));
    }
    hasCollapsedParent(rowData) {
        let result = !rowData.parent.expanded;
        while (rowData.parent) {
            result = result || !rowData.parent.expanded;
            rowData = rowData.parent;
        }
        return result;
    }
    /* tslint:disable member-ordering */
    static getCellData(worksheetData, row, column) {
        const dictionary = worksheetData.dataDictionary;
        const columnName = ExcelStrings.getExcelColumn(column) + (row + 1);
        const columnHeader = worksheetData.keys[column];
        const rowData = worksheetData.data[row - 1].rowData;
        const cellValue = worksheetData.isSpecialData ? rowData : rowData[columnHeader];
        if (cellValue === undefined || cellValue === null) {
            return `<c r="${columnName}" s="1"/>`;
        }
        else {
            const savedValue = dictionary.saveValue(cellValue, column, false);
            const isSavedAsString = savedValue !== -1;
            const value = isSavedAsString ? savedValue : cellValue;
            const type = isSavedAsString ? ` t="s"` : '';
            const format = isSavedAsString ? '' : ` s="1"`;
            return `<c r="${columnName}"${type}${format}><v>${value}</v></c>`;
        }
    }
}
WorksheetFile.MIN_WIDTH = 8.34;
/**
 * @hidden
 */
export class StyleFile {
    writeElement(folder, worksheetData) {
        folder.file('styles.xml', ExcelStrings.getStyles(worksheetData.dataDictionary && worksheetData.dataDictionary.hasNonStringValues));
    }
}
/**
 * @hidden
 */
export class WorkbookFile {
    writeElement(folder, worksheetData) {
        folder.file('workbook.xml', ExcelStrings.getWorkbook());
    }
}
/**
 * @hidden
 */
export class ContentTypesFile {
    writeElement(folder, worksheetData) {
        folder.file('[Content_Types].xml', ExcelStrings.getContentTypesXML(!worksheetData.isEmpty, worksheetData.options.exportAsTable));
    }
}
/**
 * @hidden
 */
export class SharedStringsFile {
    writeElement(folder, worksheetData) {
        const dict = worksheetData.dataDictionary;
        const sortedValues = dict.getKeys();
        const sharedStrings = new Array(sortedValues.length);
        for (const value of sortedValues) {
            sharedStrings[dict.getSanitizedValue(value)] = '<si><t>' + value + '</t></si>';
        }
        folder.file('sharedStrings.xml', ExcelStrings.getSharedStringXML(dict.stringsCount, sortedValues.length, sharedStrings.join('')));
    }
}
/**
 * @hidden
 */
export class TablesFile {
    writeElement(folder, worksheetData) {
        const columnCount = worksheetData.columnCount;
        const lastColumn = ExcelStrings.getExcelColumn(columnCount - 1) + worksheetData.rowCount;
        const dimension = 'A1:' + lastColumn;
        const values = worksheetData.keys;
        let sortString = '';
        let tableColumns = '<tableColumns count="' + columnCount + '">';
        for (let i = 0; i < columnCount; i++) {
            const value = values[i];
            tableColumns += '<tableColumn id="' + (i + 1) + '" name="' + value + '"/>';
        }
        tableColumns += '</tableColumns>';
        if (worksheetData.sort) {
            const sortingExpression = worksheetData.sort;
            const sc = ExcelStrings.getExcelColumn(values.indexOf(sortingExpression.fieldName));
            const dir = sortingExpression.dir - 1;
            sortString = `<sortState ref="A2:${lastColumn}"><sortCondition descending="${dir}" ref="${sc}1:${sc}15"/></sortState>`;
        }
        folder.file('table1.xml', ExcelStrings.getTablesXML(dimension, tableColumns, sortString));
    }
}
/**
 * @hidden
 */
export class WorksheetRelsFile {
    writeElement(folder, worksheetData) {
        folder.file('sheet1.xml.rels', ExcelStrings.getWorksheetRels());
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhjZWwtZmlsZXMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL3NlcnZpY2VzL2V4Y2VsL2V4Y2VsLWZpbGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUsvQzs7R0FFRztBQUNILE1BQU0sT0FBTyxZQUFZO0lBQ2QsWUFBWSxDQUFDLE1BQWEsRUFBRSxhQUE0QjtRQUMzRCxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztJQUNqRCxDQUFDO0NBQ0o7QUFFRDs7R0FFRztBQUNILE1BQU0sT0FBTyxPQUFPO0lBQ1QsWUFBWSxDQUFDLE1BQWEsRUFBRSxhQUE0QjtRQUMzRCxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUNsRCxDQUFDO0NBQ0o7QUFFRDs7R0FFRztBQUNILE1BQU0sT0FBTyxRQUFRO0lBQ1YsWUFBWSxDQUFDLE1BQWEsRUFBRSxhQUE0QjtRQUMzRCxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztJQUNwRCxDQUFDO0NBQ0o7QUFFRDs7R0FFRztBQUNILE1BQU0sT0FBTyxnQkFBZ0I7SUFDbEIsWUFBWSxDQUFDLE1BQWEsRUFBRSxhQUE0QjtRQUMzRCxNQUFNLGdCQUFnQixHQUFHLGFBQWEsQ0FBQyxPQUFPLEtBQUssS0FBSyxDQUFDO1FBQ3pELE1BQU0sQ0FBQyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsWUFBWSxDQUFDLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7SUFDckYsQ0FBQztDQUNKO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sU0FBUztJQUNYLFlBQVksQ0FBQyxNQUFhLEVBQUUsYUFBNEI7UUFDM0QsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsWUFBWSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7SUFDdkQsQ0FBQztDQUNKO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sYUFBYTtJQUdmLFlBQVksQ0FBQyxNQUFhLEVBQUUsYUFBNEI7UUFDM0QsTUFBTSxTQUFTLEdBQUcsRUFBRSxDQUFDO1FBQ3JCLE1BQU0sSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNoQixJQUFJLFNBQWlCLENBQUM7UUFDdEIsTUFBTSxVQUFVLEdBQUcsYUFBYSxDQUFDLGNBQWMsQ0FBQztRQUNoRCxJQUFJLFVBQVUsR0FBRyxFQUFFLENBQUM7UUFDcEIsSUFBSSxlQUFlLEdBQUcsQ0FBQyxDQUFDO1FBRXhCLElBQUksYUFBYSxDQUFDLE9BQU8sRUFBRTtZQUN2QixTQUFTLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQy9CLFNBQVMsR0FBRyxJQUFJLENBQUM7U0FDcEI7YUFBTTtZQUNILFNBQVMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDOUIsTUFBTSxNQUFNLEdBQUksYUFBYSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUM7WUFDaEQsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLEdBQUcsTUFBTSxHQUFHLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFFeEUsU0FBUyxDQUFDLElBQUksQ0FBQyxhQUFhLFNBQVMsR0FBRyxDQUFDLENBQUM7WUFDMUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ2hELE1BQU0sTUFBTSxHQUFHLFlBQVksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUNsRCxNQUFNLEtBQUssR0FBRyxVQUFVLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUNuRSxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsTUFBTSxjQUFjLEtBQUssVUFBVSxDQUFDLENBQUM7YUFDaEU7WUFDRCxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXpCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxhQUFhLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUM3QyxJQUFJLENBQUMsYUFBYSxDQUFDLGNBQWMsRUFBRTtvQkFDL0IsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLFNBQVMsR0FBRyxDQUFDLENBQUM7aUJBQ3REO3FCQUFNO29CQUNILE1BQU0sT0FBTyxHQUFHLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQztvQkFDMUQsTUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUM7b0JBQ2xHLE1BQU0sT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsa0JBQWtCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7b0JBQzFGLE1BQU0sZUFBZSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDMUQsTUFBTSxhQUFhLEdBQUcsZUFBZSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsa0JBQWtCLGVBQWUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7b0JBQ3RGLGVBQWUsR0FBRyxlQUFlLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQztvQkFFeEYsU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLFNBQVMsR0FBRyxhQUFhLEdBQUcsVUFBVSxHQUFHLE9BQU8sR0FBRyxDQUFDLENBQUM7aUJBQzdGO2dCQUNELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxhQUFhLENBQUMsV0FBVyxFQUFFLENBQUMsRUFBRSxFQUFFO29CQUNoRCxNQUFNLFFBQVEsR0FBRyxhQUFhLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7b0JBQ2hFLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7aUJBQzVCO2dCQUNELFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDNUI7WUFDRCxTQUFTLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQy9CLFNBQVMsR0FBRyxLQUFLLEdBQUcsWUFBWSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxRQUFRLENBQUM7WUFFeEcsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUVwQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsYUFBYSxDQUFDLFdBQVcsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDaEQsTUFBTSxLQUFLLEdBQUcsVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDekMscURBQXFEO2dCQUNyRCxNQUFNLFlBQVksR0FBRyxhQUFhLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO29CQUNwQyxhQUFhLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO29CQUNuQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUUsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUU3RSxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFlBQVksWUFBWSxxQkFBcUIsQ0FBQyxDQUFDO2FBQ2pHO1lBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUVyQixJQUFJLGFBQWEsQ0FBQyx1QkFBdUIsS0FBSyxDQUFDLENBQUM7Z0JBQzVDLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxhQUFhO2dCQUNwQyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsa0JBQWtCLEVBQUU7Z0JBQzNDLE1BQU0saUJBQWlCLEdBQUcsYUFBYSxDQUFDLHVCQUF1QixHQUFHLENBQUMsQ0FBQztnQkFDcEUsTUFBTSxTQUFTLEdBQUcsWUFBWSxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDdkUsVUFBVSxHQUFHLGlCQUFpQixpQkFBaUIsa0JBQWtCLFNBQVMsMENBQTBDLENBQUM7YUFDeEg7U0FDSjtRQUNELE1BQU0sUUFBUSxHQUFHLENBQUMsYUFBYSxDQUFDLE9BQU8sSUFBSSxhQUFhLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQztRQUUvRSxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksRUFDWixZQUFZLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxVQUFVLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFFBQVEsRUFDM0YsYUFBYSxDQUFDLGNBQWMsRUFBRSxlQUFlLENBQUMsQ0FBQyxDQUFDO0lBQ2hFLENBQUM7SUFFTyxrQkFBa0IsQ0FBQyxPQUFPO1FBQzlCLElBQUksTUFBTSxHQUFHLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUM7UUFDdEMsT0FBTyxPQUFPLENBQUMsTUFBTSxFQUFFO1lBQ25CLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQztZQUM1QyxPQUFPLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztTQUM1QjtRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7SUFDRCxvQ0FBb0M7SUFDNUIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxhQUE0QixFQUFFLEdBQVcsRUFBRSxNQUFjO1FBQ2hGLE1BQU0sVUFBVSxHQUFHLGFBQWEsQ0FBQyxjQUFjLENBQUM7UUFDaEQsTUFBTSxVQUFVLEdBQUcsWUFBWSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNuRSxNQUFNLFlBQVksR0FBRyxhQUFhLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRWhELE1BQU0sT0FBTyxHQUFHLGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztRQUVwRCxNQUFNLFNBQVMsR0FBRyxhQUFhLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUVoRixJQUFJLFNBQVMsS0FBSyxTQUFTLElBQUksU0FBUyxLQUFLLElBQUksRUFBRTtZQUMvQyxPQUFPLFNBQVMsVUFBVSxXQUFXLENBQUM7U0FDekM7YUFBTTtZQUNILE1BQU0sVUFBVSxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsU0FBUyxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztZQUNsRSxNQUFNLGVBQWUsR0FBRyxVQUFVLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFFMUMsTUFBTSxLQUFLLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztZQUN2RCxNQUFNLElBQUksR0FBRyxlQUFlLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQzdDLE1BQU0sTUFBTSxHQUFHLGVBQWUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7WUFFL0MsT0FBTyxTQUFTLFVBQVUsSUFBSSxJQUFJLEdBQUcsTUFBTSxPQUFPLEtBQUssVUFBVSxDQUFDO1NBQ3JFO0lBQ0wsQ0FBQzs7QUE1R2MsdUJBQVMsR0FBRyxJQUFJLENBQUM7QUFnSHBDOztHQUVHO0FBQ0gsTUFBTSxPQUFPLFNBQVM7SUFDWCxZQUFZLENBQUMsTUFBYSxFQUFFLGFBQTRCO1FBQzNELE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLFlBQVksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLGNBQWMsSUFBSSxhQUFhLENBQUMsY0FBYyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQztJQUN2SSxDQUFDO0NBQ0o7QUFFRDs7R0FFRztBQUNILE1BQU0sT0FBTyxZQUFZO0lBQ2QsWUFBWSxDQUFDLE1BQWEsRUFBRSxhQUE0QjtRQUMzRCxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztJQUM1RCxDQUFDO0NBQ0o7QUFFRDs7R0FFRztBQUNILE1BQU0sT0FBTyxnQkFBZ0I7SUFDbEIsWUFBWSxDQUFDLE1BQWEsRUFBRSxhQUE0QjtRQUMzRCxNQUFNLENBQUMsSUFBSSxDQUFDLHFCQUFxQixFQUFFLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsYUFBYSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO0lBQ3JJLENBQUM7Q0FDSjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLGlCQUFpQjtJQUNuQixZQUFZLENBQUMsTUFBYSxFQUFFLGFBQTRCO1FBQzNELE1BQU0sSUFBSSxHQUFHLGFBQWEsQ0FBQyxjQUFjLENBQUM7UUFDMUMsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3BDLE1BQU0sYUFBYSxHQUFHLElBQUksS0FBSyxDQUFTLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUU3RCxLQUFLLE1BQU0sS0FBSyxJQUFJLFlBQVksRUFBRTtZQUM5QixhQUFhLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsU0FBUyxHQUFHLEtBQUssR0FBRyxXQUFXLENBQUM7U0FDbEY7UUFFRCxNQUFNLENBQUMsSUFBSSxDQUFDLG1CQUFtQixFQUFFLFlBQVksQ0FBQyxrQkFBa0IsQ0FDaEQsSUFBSSxDQUFDLFlBQVksRUFDakIsWUFBWSxDQUFDLE1BQU0sRUFDbkIsYUFBYSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUMxQixDQUFDO0lBQ2xCLENBQUM7Q0FDSjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLFVBQVU7SUFDWixZQUFZLENBQUMsTUFBYSxFQUFFLGFBQTRCO1FBQzNELE1BQU0sV0FBVyxHQUFHLGFBQWEsQ0FBQyxXQUFXLENBQUM7UUFDOUMsTUFBTSxVQUFVLEdBQUcsWUFBWSxDQUFDLGNBQWMsQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLEdBQUcsYUFBYSxDQUFDLFFBQVEsQ0FBQztRQUN6RixNQUFNLFNBQVMsR0FBRyxLQUFLLEdBQUcsVUFBVSxDQUFDO1FBQ3JDLE1BQU0sTUFBTSxHQUFHLGFBQWEsQ0FBQyxJQUFJLENBQUM7UUFDbEMsSUFBSSxVQUFVLEdBQUcsRUFBRSxDQUFDO1FBRXBCLElBQUksWUFBWSxHQUFHLHVCQUF1QixHQUFHLFdBQVcsR0FBRyxJQUFJLENBQUM7UUFDaEUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNsQyxNQUFNLEtBQUssR0FBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDekIsWUFBWSxJQUFJLG1CQUFtQixHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLFVBQVUsR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDO1NBQzlFO1FBRUQsWUFBWSxJQUFJLGlCQUFpQixDQUFDO1FBRWxDLElBQUksYUFBYSxDQUFDLElBQUksRUFBRTtZQUNwQixNQUFNLGlCQUFpQixHQUFHLGFBQWEsQ0FBQyxJQUFJLENBQUM7WUFDN0MsTUFBTSxFQUFFLEdBQUcsWUFBWSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDcEYsTUFBTSxHQUFHLEdBQUcsaUJBQWlCLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztZQUN0QyxVQUFVLEdBQUcsc0JBQXNCLFVBQVUsZ0NBQWdDLEdBQUcsVUFBVSxFQUFFLEtBQUssRUFBRSxtQkFBbUIsQ0FBQztTQUMxSDtRQUVELE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLFlBQVksQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLFlBQVksRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBQzlGLENBQUM7Q0FDSjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLGlCQUFpQjtJQUNuQixZQUFZLENBQUMsTUFBYSxFQUFFLGFBQTRCO1FBQzNELE1BQU0sQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsWUFBWSxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQztJQUNwRSxDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJRXhjZWxGaWxlIH0gZnJvbSAnLi9leGNlbC1pbnRlcmZhY2VzJztcbmltcG9ydCB7IEV4Y2VsU3RyaW5ncyB9IGZyb20gJy4vZXhjZWwtc3RyaW5ncyc7XG5pbXBvcnQgeyBXb3Jrc2hlZXREYXRhIH0gZnJvbSAnLi93b3Jrc2hlZXQtZGF0YSc7XG5cbmltcG9ydCAqIGFzIEpTWmlwIGZyb20gJ2pzemlwL2Rpc3QvanN6aXAnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFJvb3RSZWxzRmlsZSBpbXBsZW1lbnRzIElFeGNlbEZpbGUge1xuICAgIHB1YmxpYyB3cml0ZUVsZW1lbnQoZm9sZGVyOiBKU1ppcCwgd29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSkge1xuICAgICAgICBmb2xkZXIuZmlsZSgnLnJlbHMnLCBFeGNlbFN0cmluZ3MuZ2V0UmVscygpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgQXBwRmlsZSBpbXBsZW1lbnRzIElFeGNlbEZpbGUge1xuICAgIHB1YmxpYyB3cml0ZUVsZW1lbnQoZm9sZGVyOiBKU1ppcCwgd29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSkge1xuICAgICAgICBmb2xkZXIuZmlsZSgnYXBwLnhtbCcsIEV4Y2VsU3RyaW5ncy5nZXRBcHAoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIENvcmVGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHVibGljIHdyaXRlRWxlbWVudChmb2xkZXI6IEpTWmlwLCB3b3Jrc2hlZXREYXRhOiBXb3Jrc2hlZXREYXRhKSB7XG4gICAgICAgIGZvbGRlci5maWxlKCdjb3JlLnhtbCcsIEV4Y2VsU3RyaW5ncy5nZXRDb3JlKCkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3JrYm9va1JlbHNGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHVibGljIHdyaXRlRWxlbWVudChmb2xkZXI6IEpTWmlwLCB3b3Jrc2hlZXREYXRhOiBXb3Jrc2hlZXREYXRhKSB7XG4gICAgICAgIGNvbnN0IGhhc1NoYXJlZFN0cmluZ3MgPSB3b3Jrc2hlZXREYXRhLmlzRW1wdHkgPT09IGZhbHNlO1xuICAgICAgICBmb2xkZXIuZmlsZSgnd29ya2Jvb2sueG1sLnJlbHMnLCBFeGNlbFN0cmluZ3MuZ2V0V29ya2Jvb2tSZWxzKGhhc1NoYXJlZFN0cmluZ3MpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgVGhlbWVGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHVibGljIHdyaXRlRWxlbWVudChmb2xkZXI6IEpTWmlwLCB3b3Jrc2hlZXREYXRhOiBXb3Jrc2hlZXREYXRhKSB7XG4gICAgICAgIGZvbGRlci5maWxlKCd0aGVtZTEueG1sJywgRXhjZWxTdHJpbmdzLmdldFRoZW1lKCkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3Jrc2hlZXRGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHJpdmF0ZSBzdGF0aWMgTUlOX1dJRFRIID0gOC4zNDtcblxuICAgIHB1YmxpYyB3cml0ZUVsZW1lbnQoZm9sZGVyOiBKU1ppcCwgd29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSkge1xuICAgICAgICBjb25zdCBzaGVldERhdGEgPSBbXTtcbiAgICAgICAgY29uc3QgY29scyA9IFtdO1xuICAgICAgICBsZXQgZGltZW5zaW9uOiBzdHJpbmc7XG4gICAgICAgIGNvbnN0IGRpY3Rpb25hcnkgPSB3b3Jrc2hlZXREYXRhLmRhdGFEaWN0aW9uYXJ5O1xuICAgICAgICBsZXQgZnJlZXplUGFuZSA9ICcnO1xuICAgICAgICBsZXQgbWF4T3V0bGluZUxldmVsID0gMDtcblxuICAgICAgICBpZiAod29ya3NoZWV0RGF0YS5pc0VtcHR5KSB7XG4gICAgICAgICAgICBzaGVldERhdGEucHVzaCgnPHNoZWV0RGF0YS8+Jyk7XG4gICAgICAgICAgICBkaW1lbnNpb24gPSAnQTEnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hlZXREYXRhLnB1c2goJzxzaGVldERhdGE+Jyk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSAgd29ya3NoZWV0RGF0YS5vcHRpb25zLnJvd0hlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHJvd0hlaWdodCA9IGhlaWdodCA/ICcgaHQ9XCInICsgaGVpZ2h0ICsgJ1wiIGN1c3RvbUhlaWdodD1cIjFcIicgOiAnJztcblxuICAgICAgICAgICAgc2hlZXREYXRhLnB1c2goYDxyb3cgcj1cIjFcIiR7cm93SGVpZ2h0fT5gKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29ya3NoZWV0RGF0YS5jb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sdW1uID0gRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKGkpICsgMTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRpY3Rpb25hcnkuc2F2ZVZhbHVlKHdvcmtzaGVldERhdGEua2V5c1tpXSwgaSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2hlZXREYXRhLnB1c2goYDxjIHI9XCIke2NvbHVtbn1cIiB0PVwic1wiPjx2PiR7dmFsdWV9PC92PjwvYz5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNoZWV0RGF0YS5wdXNoKCc8L3Jvdz4nKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3b3Jrc2hlZXREYXRhLnJvd0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdvcmtzaGVldERhdGEuaXNUcmVlR3JpZERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hlZXREYXRhLnB1c2goYDxyb3cgcj1cIiR7KGkgKyAxKX1cIiR7cm93SGVpZ2h0fT5gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3dEYXRhID0gd29ya3NoZWV0RGF0YS5kYXRhW2kgLSAxXS5vcmlnaW5hbFJvd0RhdGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNDb2xsYXBzZWQgPSAoIXJvd0RhdGEuZXhwYW5kZWQpID8gJycgOiAocm93RGF0YS5leHBhbmRlZCA9PT0gdHJ1ZSkgPyAnJyA6IGAgY29sbGFwc2VkPVwiMVwiYDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc0hpZGRlbiA9IChyb3dEYXRhLnBhcmVudCAmJiB0aGlzLmhhc0NvbGxhcHNlZFBhcmVudChyb3dEYXRhKSkgPyBgIGhpZGRlbj1cIjFcImAgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93T3V0bGluZUxldmVsID0gcm93RGF0YS5sZXZlbCA/IHJvd0RhdGEubGV2ZWwgOiAwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzT3V0bGluZUxldmVsID0gcm93T3V0bGluZUxldmVsID4gMCA/IGAgb3V0bGluZUxldmVsPVwiJHtyb3dPdXRsaW5lTGV2ZWx9XCJgIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIG1heE91dGxpbmVMZXZlbCA9IG1heE91dGxpbmVMZXZlbCA8IHJvd091dGxpbmVMZXZlbCA/IHJvd091dGxpbmVMZXZlbCA6IG1heE91dGxpbmVMZXZlbDtcblxuICAgICAgICAgICAgICAgICAgICBzaGVldERhdGEucHVzaChgPHJvdyByPVwiJHsoaSArIDEpfVwiJHtyb3dIZWlnaHR9JHtzT3V0bGluZUxldmVsfSR7c0NvbGxhcHNlZH0ke3NIaWRkZW59PmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdvcmtzaGVldERhdGEuY29sdW1uQ291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsRGF0YSA9IFdvcmtzaGVldEZpbGUuZ2V0Q2VsbERhdGEod29ya3NoZWV0RGF0YSwgaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIHNoZWV0RGF0YS5wdXNoKGNlbGxEYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2hlZXREYXRhLnB1c2goJzwvcm93PicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hlZXREYXRhLnB1c2goJzwvc2hlZXREYXRhPicpO1xuICAgICAgICAgICAgZGltZW5zaW9uID0gJ0ExOicgKyBFeGNlbFN0cmluZ3MuZ2V0RXhjZWxDb2x1bW4od29ya3NoZWV0RGF0YS5jb2x1bW5Db3VudCAtIDEpICsgd29ya3NoZWV0RGF0YS5yb3dDb3VudDtcblxuICAgICAgICAgICAgY29scy5wdXNoKCc8Y29scz4nKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jrc2hlZXREYXRhLmNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IGRpY3Rpb25hcnkuY29sdW1uV2lkdGhzW2ldO1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgd2lkdGggcHJvdmlkZWQgaW4gdGhlIG9wdGlvbnMgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGhJblR3aXBzID0gd29ya3NoZWV0RGF0YS5vcHRpb25zLmNvbHVtbldpZHRoID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtzaGVldERhdGEub3B0aW9ucy5jb2x1bW5XaWR0aCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCgoKHdpZHRoIC8gOTYpICogMTQuNCksIFdvcmtzaGVldEZpbGUuTUlOX1dJRFRIKTtcblxuICAgICAgICAgICAgICAgIGNvbHMucHVzaChgPGNvbCBtaW49XCIkeyhpICsgMSl9XCIgbWF4PVwiJHsoaSArIDEpfVwiIHdpZHRoPVwiJHt3aWR0aEluVHdpcHN9XCIgY3VzdG9tV2lkdGg9XCIxXCIvPmApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb2xzLnB1c2goJzwvY29scz4nKTtcblxuICAgICAgICAgICAgaWYgKHdvcmtzaGVldERhdGEuaW5kZXhPZkxhc3RQaW5uZWRDb2x1bW4gIT09IC0xICYmXG4gICAgICAgICAgICAgICAgIXdvcmtzaGVldERhdGEub3B0aW9ucy5pZ25vcmVQaW5uaW5nICYmXG4gICAgICAgICAgICAgICAgIXdvcmtzaGVldERhdGEub3B0aW9ucy5pZ25vcmVDb2x1bW5zT3JkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm96ZW5Db2x1bW5Db3VudCA9IHdvcmtzaGVldERhdGEuaW5kZXhPZkxhc3RQaW5uZWRDb2x1bW4gKyAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Q2VsbCA9IEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbihmcm96ZW5Db2x1bW5Db3VudCkgKyAnMSc7XG4gICAgICAgICAgICAgICAgZnJlZXplUGFuZSA9IGA8cGFuZSB4U3BsaXQ9XCIke2Zyb3plbkNvbHVtbkNvdW50fVwiIHRvcExlZnRDZWxsPVwiJHtmaXJzdENlbGx9XCIgYWN0aXZlUGFuZT1cInRvcFJpZ2h0XCIgc3RhdGU9XCJmcm96ZW5cIi8+YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNUYWJsZSA9ICF3b3Jrc2hlZXREYXRhLmlzRW1wdHkgJiYgd29ya3NoZWV0RGF0YS5vcHRpb25zLmV4cG9ydEFzVGFibGU7XG5cbiAgICAgICAgZm9sZGVyLmZpbGUoJ3NoZWV0MS54bWwnLFxuICAgICAgICAgICAgICAgICAgICBFeGNlbFN0cmluZ3MuZ2V0U2hlZXRYTUwoZGltZW5zaW9uLCBmcmVlemVQYW5lLCBjb2xzLmpvaW4oJycpLCBzaGVldERhdGEuam9pbignJyksIGhhc1RhYmxlLFxuICAgICAgICAgICAgICAgICAgICB3b3Jrc2hlZXREYXRhLmlzVHJlZUdyaWREYXRhLCBtYXhPdXRsaW5lTGV2ZWwpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhc0NvbGxhcHNlZFBhcmVudChyb3dEYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAhcm93RGF0YS5wYXJlbnQuZXhwYW5kZWQ7XG4gICAgICAgIHdoaWxlIChyb3dEYXRhLnBhcmVudCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8ICFyb3dEYXRhLnBhcmVudC5leHBhbmRlZDtcbiAgICAgICAgICAgIHJvd0RhdGEgPSByb3dEYXRhLnBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qIHRzbGludDpkaXNhYmxlIG1lbWJlci1vcmRlcmluZyAqL1xuICAgIHByaXZhdGUgc3RhdGljIGdldENlbGxEYXRhKHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEsIHJvdzogbnVtYmVyLCBjb2x1bW46IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGRpY3Rpb25hcnkgPSB3b3Jrc2hlZXREYXRhLmRhdGFEaWN0aW9uYXJ5O1xuICAgICAgICBjb25zdCBjb2x1bW5OYW1lID0gRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKGNvbHVtbikgKyAocm93ICsgMSk7XG4gICAgICAgIGNvbnN0IGNvbHVtbkhlYWRlciA9IHdvcmtzaGVldERhdGEua2V5c1tjb2x1bW5dO1xuXG4gICAgICAgIGNvbnN0IHJvd0RhdGEgPSB3b3Jrc2hlZXREYXRhLmRhdGFbcm93IC0gMV0ucm93RGF0YTtcblxuICAgICAgICBjb25zdCBjZWxsVmFsdWUgPSB3b3Jrc2hlZXREYXRhLmlzU3BlY2lhbERhdGEgPyByb3dEYXRhIDogcm93RGF0YVtjb2x1bW5IZWFkZXJdO1xuXG4gICAgICAgIGlmIChjZWxsVmFsdWUgPT09IHVuZGVmaW5lZCB8fCBjZWxsVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBgPGMgcj1cIiR7Y29sdW1uTmFtZX1cIiBzPVwiMVwiLz5gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2F2ZWRWYWx1ZSA9IGRpY3Rpb25hcnkuc2F2ZVZhbHVlKGNlbGxWYWx1ZSwgY29sdW1uLCBmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBpc1NhdmVkQXNTdHJpbmcgPSBzYXZlZFZhbHVlICE9PSAtMTtcblxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpc1NhdmVkQXNTdHJpbmcgPyBzYXZlZFZhbHVlIDogY2VsbFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGlzU2F2ZWRBc1N0cmluZyA/IGAgdD1cInNcImAgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IGlzU2F2ZWRBc1N0cmluZyA/ICcnIDogYCBzPVwiMVwiYDtcblxuICAgICAgICAgICAgcmV0dXJuIGA8YyByPVwiJHtjb2x1bW5OYW1lfVwiJHt0eXBlfSR7Zm9ybWF0fT48dj4ke3ZhbHVlfTwvdj48L2M+YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiB0c2xpbnQ6ZW5hYmxlIG1lbWJlci1vcmRlcmluZyAqL1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0eWxlRmlsZSBpbXBsZW1lbnRzIElFeGNlbEZpbGUge1xuICAgIHB1YmxpYyB3cml0ZUVsZW1lbnQoZm9sZGVyOiBKU1ppcCwgd29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSkge1xuICAgICAgICBmb2xkZXIuZmlsZSgnc3R5bGVzLnhtbCcsIEV4Y2VsU3RyaW5ncy5nZXRTdHlsZXMod29ya3NoZWV0RGF0YS5kYXRhRGljdGlvbmFyeSAmJiB3b3Jrc2hlZXREYXRhLmRhdGFEaWN0aW9uYXJ5Lmhhc05vblN0cmluZ1ZhbHVlcykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3JrYm9va0ZpbGUgaW1wbGVtZW50cyBJRXhjZWxGaWxlIHtcbiAgICBwdWJsaWMgd3JpdGVFbGVtZW50KGZvbGRlcjogSlNaaXAsIHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEpIHtcbiAgICAgICAgZm9sZGVyLmZpbGUoJ3dvcmtib29rLnhtbCcsIEV4Y2VsU3RyaW5ncy5nZXRXb3JrYm9vaygpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgQ29udGVudFR5cGVzRmlsZSBpbXBsZW1lbnRzIElFeGNlbEZpbGUge1xuICAgIHB1YmxpYyB3cml0ZUVsZW1lbnQoZm9sZGVyOiBKU1ppcCwgd29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSkge1xuICAgICAgICBmb2xkZXIuZmlsZSgnW0NvbnRlbnRfVHlwZXNdLnhtbCcsIEV4Y2VsU3RyaW5ncy5nZXRDb250ZW50VHlwZXNYTUwoIXdvcmtzaGVldERhdGEuaXNFbXB0eSwgd29ya3NoZWV0RGF0YS5vcHRpb25zLmV4cG9ydEFzVGFibGUpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgU2hhcmVkU3RyaW5nc0ZpbGUgaW1wbGVtZW50cyBJRXhjZWxGaWxlIHtcbiAgICBwdWJsaWMgd3JpdGVFbGVtZW50KGZvbGRlcjogSlNaaXAsIHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEpIHtcbiAgICAgICAgY29uc3QgZGljdCA9IHdvcmtzaGVldERhdGEuZGF0YURpY3Rpb25hcnk7XG4gICAgICAgIGNvbnN0IHNvcnRlZFZhbHVlcyA9IGRpY3QuZ2V0S2V5cygpO1xuICAgICAgICBjb25zdCBzaGFyZWRTdHJpbmdzID0gbmV3IEFycmF5PHN0cmluZz4oc29ydGVkVmFsdWVzLmxlbmd0aCk7XG5cbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBzb3J0ZWRWYWx1ZXMpIHtcbiAgICAgICAgICAgIHNoYXJlZFN0cmluZ3NbZGljdC5nZXRTYW5pdGl6ZWRWYWx1ZSh2YWx1ZSldID0gJzxzaT48dD4nICsgdmFsdWUgKyAnPC90Pjwvc2k+JztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvbGRlci5maWxlKCdzaGFyZWRTdHJpbmdzLnhtbCcsIEV4Y2VsU3RyaW5ncy5nZXRTaGFyZWRTdHJpbmdYTUwoXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWN0LnN0cmluZ3NDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZFZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRTdHJpbmdzLmpvaW4oJycpKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBUYWJsZXNGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHVibGljIHdyaXRlRWxlbWVudChmb2xkZXI6IEpTWmlwLCB3b3Jrc2hlZXREYXRhOiBXb3Jrc2hlZXREYXRhKSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbkNvdW50ID0gd29ya3NoZWV0RGF0YS5jb2x1bW5Db3VudDtcbiAgICAgICAgY29uc3QgbGFzdENvbHVtbiA9IEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbihjb2x1bW5Db3VudCAtIDEpICsgd29ya3NoZWV0RGF0YS5yb3dDb3VudDtcbiAgICAgICAgY29uc3QgZGltZW5zaW9uID0gJ0ExOicgKyBsYXN0Q29sdW1uO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB3b3Jrc2hlZXREYXRhLmtleXM7XG4gICAgICAgIGxldCBzb3J0U3RyaW5nID0gJyc7XG5cbiAgICAgICAgbGV0IHRhYmxlQ29sdW1ucyA9ICc8dGFibGVDb2x1bW5zIGNvdW50PVwiJyArIGNvbHVtbkNvdW50ICsgJ1wiPic7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAgdmFsdWVzW2ldO1xuICAgICAgICAgICAgdGFibGVDb2x1bW5zICs9ICc8dGFibGVDb2x1bW4gaWQ9XCInICsgKGkgKyAxKSArICdcIiBuYW1lPVwiJyArIHZhbHVlICsgJ1wiLz4nO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFibGVDb2x1bW5zICs9ICc8L3RhYmxlQ29sdW1ucz4nO1xuXG4gICAgICAgIGlmICh3b3Jrc2hlZXREYXRhLnNvcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvcnRpbmdFeHByZXNzaW9uID0gd29ya3NoZWV0RGF0YS5zb3J0O1xuICAgICAgICAgICAgY29uc3Qgc2MgPSBFeGNlbFN0cmluZ3MuZ2V0RXhjZWxDb2x1bW4odmFsdWVzLmluZGV4T2Yoc29ydGluZ0V4cHJlc3Npb24uZmllbGROYW1lKSk7XG4gICAgICAgICAgICBjb25zdCBkaXIgPSBzb3J0aW5nRXhwcmVzc2lvbi5kaXIgLSAxO1xuICAgICAgICAgICAgc29ydFN0cmluZyA9IGA8c29ydFN0YXRlIHJlZj1cIkEyOiR7bGFzdENvbHVtbn1cIj48c29ydENvbmRpdGlvbiBkZXNjZW5kaW5nPVwiJHtkaXJ9XCIgcmVmPVwiJHtzY30xOiR7c2N9MTVcIi8+PC9zb3J0U3RhdGU+YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvbGRlci5maWxlKCd0YWJsZTEueG1sJywgRXhjZWxTdHJpbmdzLmdldFRhYmxlc1hNTChkaW1lbnNpb24sIHRhYmxlQ29sdW1ucywgc29ydFN0cmluZykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3Jrc2hlZXRSZWxzRmlsZSBpbXBsZW1lbnRzIElFeGNlbEZpbGUge1xuICAgIHB1YmxpYyB3cml0ZUVsZW1lbnQoZm9sZGVyOiBKU1ppcCwgd29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSkge1xuICAgICAgICBmb2xkZXIuZmlsZSgnc2hlZXQxLnhtbC5yZWxzJywgRXhjZWxTdHJpbmdzLmdldFdvcmtzaGVldFJlbHMoKSk7XG4gICAgfVxufVxuIl19