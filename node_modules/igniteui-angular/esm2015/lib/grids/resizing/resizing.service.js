import { __decorate } from "tslib";
import { Injectable, NgZone } from '@angular/core';
/**
 * @hidden
 * @internal
 */
let IgxColumnResizingService = class IgxColumnResizingService {
    constructor(zone) {
        this.zone = zone;
        /**
         *@hidden
         */
        this.resizeCursor = null;
        /**
         *@hidden
         */
        this.showResizer = false;
    }
    /**
     *@hidden
     */
    get resizerHeight() {
        let height = this.column.grid.getVisibleContentHeight();
        // Column height multiplier in case there are Column Layouts. The resizer height need to take into account rowStart.
        let columnHeightMultiplier = 1;
        if (this.column.columnLayoutChild) {
            columnHeightMultiplier = this.column.grid.multiRowLayoutRowSize - this.column.rowStart + 1;
        }
        if (this.column.level !== 0) {
            height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height * columnHeightMultiplier;
        }
        return height;
    }
    /**
     * Returns the minimal possible width to which the column can be resized.
     */
    get restrictResizeMin() {
        const actualMinWidth = parseFloat(this.column.minWidth);
        const minWidth = actualMinWidth < parseFloat(this.column.width) ? actualMinWidth : parseFloat(this.column.width);
        return this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width - minWidth;
    }
    /**
     * Returns the maximal possible width to which the column can be resized.
     */
    get restrictResizeMax() {
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        if (this.column.maxWidth) {
            return parseFloat(this.column.maxWidth) - actualWidth;
        }
        else {
            return Number.MAX_SAFE_INTEGER;
        }
    }
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     * If the column is pinned and the autosized column width will cause the pinned area to become bigger
     * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
     */
    autosizeColumnOnDblClick() {
        const currentColWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        const size = this.column.getLargestCellWidth();
        if (this.column.maxWidth && (parseFloat(size) > parseFloat(this.column.maxWidth))) {
            this.column.width = parseFloat(this.column.maxWidth) + 'px';
        }
        else if (parseFloat(size) < parseFloat(this.column.minWidth)) {
            this.column.width = this.column.minWidth + 'px';
        }
        else {
            this.column.width = size;
        }
        this.zone.run(() => { });
        this.column.grid.onColumnResized.emit({
            column: this.column,
            prevWidth: currentColWidth.toString(),
            newWidth: this.column.width
        });
    }
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     */
    resizeColumn(event) {
        this.showResizer = false;
        const diff = event.clientX - this.startResizePos;
        let currentColWidth = parseFloat(this.column.width);
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        const colMinWidth = this.getColMinWidth(this.column);
        const colMaxWidth = this.getColMaxWidth(this.column);
        if (this.column.grid.hasColumnLayouts) {
            this.resizeColumnLayoutFor(this.column, diff);
        }
        else {
            if (currentColWidth + diff < colMinWidth) {
                this.column.width = colMinWidth + 'px';
            }
            else if (colMaxWidth && (currentColWidth + diff > colMaxWidth)) {
                this.column.width = colMaxWidth + 'px';
            }
            else {
                this.column.width = (currentColWidth + diff) + 'px';
            }
        }
        this.zone.run(() => { });
        if (currentColWidth !== parseFloat(this.column.width)) {
            this.column.grid.onColumnResized.emit({
                column: this.column,
                prevWidth: currentColWidth.toString(),
                newWidth: this.column.width
            });
        }
        this.isColumnResizing = false;
    }
    getColMinWidth(column) {
        let currentColWidth = parseFloat(column.width);
        const actualWidth = column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        const actualMinWidth = parseFloat(column.minWidth);
        return actualMinWidth < currentColWidth ? actualMinWidth : currentColWidth;
    }
    getColMaxWidth(column) {
        return column.pinned ? parseFloat(this.pinnedMaxWidth) : parseFloat(column.maxWidth);
    }
    resizeColumnLayoutFor(column, diff) {
        const relativeColumns = column.getResizableColUnderEnd();
        const combinedSpan = relativeColumns.reduce((acc, col) => acc + col.spanUsed, 0);
        // Resize first those who might reach min/max width
        let columnsToResize = [...relativeColumns];
        let updatedDiff = diff;
        let updatedCombinedSpan = combinedSpan;
        let setMinMaxCols = false;
        do {
            // Cycle them until there are not ones that reach min/max size, because the diff accumulates after each cycle.
            // This is because we can have at first 2 cols reaching min width and then after
            // recalculating the diff there might be 1 more that reaches min width.
            setMinMaxCols = false;
            let newCombinedSpan = updatedCombinedSpan;
            const newColsToResize = [];
            columnsToResize.forEach((col) => {
                const currentResizeWidth = parseFloat(col.target.calcWidth);
                const resizeScaled = (diff / updatedCombinedSpan) * col.target.gridColumnSpan;
                const minWidth = this.getColMinWidth(col.target);
                const maxWidth = this.getColMaxWidth(col.target);
                if (currentResizeWidth + resizeScaled < minWidth) {
                    col.target.width = minWidth + 'px';
                    updatedDiff += (currentResizeWidth - minWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else if (maxWidth && (currentResizeWidth + resizeScaled > maxWidth)) {
                    col.target.width = maxWidth + 'px';
                    updatedDiff -= (maxWidth - currentResizeWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else {
                    // Save new ones that can be resized
                    newColsToResize.push(col);
                }
            });
            updatedCombinedSpan = newCombinedSpan;
            columnsToResize = newColsToResize;
        } while (setMinMaxCols);
        // Those left that don't reach min/max size resize them normally.
        columnsToResize.forEach((col) => {
            const currentResizeWidth = parseFloat(col.target.calcWidth);
            const resizeScaled = (updatedDiff / updatedCombinedSpan) * col.target.gridColumnSpan;
            col.target.width = (currentResizeWidth + resizeScaled) + 'px';
        });
    }
};
IgxColumnResizingService.ctorParameters = () => [
    { type: NgZone }
];
IgxColumnResizingService = __decorate([
    Injectable()
], IgxColumnResizingService);
export { IgxColumnResizingService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXppbmcuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvcmVzaXppbmcvcmVzaXppbmcuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFHbkQ7OztHQUdHO0FBRUgsSUFBYSx3QkFBd0IsR0FBckMsTUFBYSx3QkFBd0I7SUF5QmpDLFlBQW9CLElBQVk7UUFBWixTQUFJLEdBQUosSUFBSSxDQUFRO1FBYmhDOztXQUVHO1FBQ0ksaUJBQVksR0FBVyxJQUFJLENBQUM7UUFDbkM7O1dBRUc7UUFDSSxnQkFBVyxHQUFHLEtBQUssQ0FBQztJQU1TLENBQUM7SUFFckM7O09BRUc7SUFDSCxJQUFJLGFBQWE7UUFDYixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO1FBRXhELG9IQUFvSDtRQUNwSCxJQUFJLHNCQUFzQixHQUFHLENBQUMsQ0FBQztRQUMvQixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEVBQUU7WUFDL0Isc0JBQXNCLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMscUJBQXFCLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO1NBQzlGO1FBRUQsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssS0FBSyxDQUFDLEVBQUU7WUFDekIsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLHNCQUFzQixDQUFDO1NBQ3JIO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBSSxp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SUFBSSxDQUFDLGtCQUFrQixHQUFHLFlBQVksR0FBRyxRQUFRLENBQUMsRUFBRTtvQkFDbkUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsUUFBUSxHQUFHLElBQUksQ0FBQztvQkFDbkMsV0FBVyxJQUFJLENBQUMsUUFBUSxHQUFHLGtCQUFrQixDQUFDLENBQUM7b0JBQy9DLGVBQWUsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDO29CQUNoQyxhQUFhLEdBQUcsSUFBSSxDQUFDO2lCQUN4QjtxQkFBTTtvQkFDSCxvQ0FBb0M7b0JBQ3BDLGVBQWUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQzdCO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFFSCxtQkFBbUIsR0FBRyxlQUFlLENBQUM7WUFDdEMsZUFBZSxHQUFHLGVBQWUsQ0FBQztTQUNyQyxRQUFRLGFBQWEsRUFBRTtRQUV4QixpRUFBaUU7UUFDakUsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO1lBQzVCLE1BQU0sa0JBQWtCLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDNUQsTUFBTSxZQUFZLEdBQUcsQ0FBQyxXQUFXLEdBQUcsbUJBQW1CLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQztZQUNyRixHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxDQUFDLGtCQUFrQixHQUFHLFlBQVksQ0FBQyxHQUFHLElBQUksQ0FBQztRQUNsRSxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7Q0FDSixDQUFBOztZQTNLNkIsTUFBTTs7QUF6QnZCLHdCQUF3QjtJQURwQyxVQUFVLEVBQUU7R0FDQSx3QkFBd0IsQ0FvTXBDO1NBcE1ZLHdCQUF3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4Q29sdW1uQ29tcG9uZW50IH0gZnJvbSAnLi4vY29sdW1ucy9jb2x1bW4uY29tcG9uZW50JztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBAaW50ZXJuYWxcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIElneENvbHVtblJlc2l6aW5nU2VydmljZSB7XG5cbiAgICBwcml2YXRlIHBpbm5lZE1heFdpZHRoOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhcnRSZXNpemVQb3M6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIGNvbHVtbiBpcyBjdXJyZW50bHkgYmVpbmcgcmVzaXplZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgaXNDb2x1bW5SZXNpemluZzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVzaXplQ3Vyc29yOiBzdHJpbmcgPSBudWxsO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBzaG93UmVzaXplciA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoZSBjb2x1bW4gYmVpbmcgcmVzaXplZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgY29sdW1uOiBJZ3hDb2x1bW5Db21wb25lbnQ7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHpvbmU6IE5nWm9uZSkgeyB9XG5cbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgcmVzaXplckhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5jb2x1bW4uZ3JpZC5nZXRWaXNpYmxlQ29udGVudEhlaWdodCgpO1xuXG4gICAgICAgIC8vIENvbHVtbiBoZWlnaHQgbXVsdGlwbGllciBpbiBjYXNlIHRoZXJlIGFyZSBDb2x1bW4gTGF5b3V0cy4gVGhlIHJlc2l6ZXIgaGVpZ2h0IG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgcm93U3RhcnQuXG4gICAgICAgIGxldCBjb2x1bW5IZWlnaHRNdWx0aXBsaWVyID0gMTtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uLmNvbHVtbkxheW91dENoaWxkKSB7XG4gICAgICAgICAgICBjb2x1bW5IZWlnaHRNdWx0aXBsaWVyID0gdGhpcy5jb2x1bW4uZ3JpZC5tdWx0aVJvd0xheW91dFJvd1NpemUgLSB0aGlzLmNvbHVtbi5yb3dTdGFydCArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb2x1bW4ubGV2ZWwgIT09IDApIHtcbiAgICAgICAgICAgIGhlaWdodCAtPSB0aGlzLmNvbHVtbi50b3BMZXZlbFBhcmVudC5oZWFkZXJHcm91cC5oZWlnaHQgLSB0aGlzLmNvbHVtbi5oZWFkZXJHcm91cC5oZWlnaHQgKiBjb2x1bW5IZWlnaHRNdWx0aXBsaWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtaW5pbWFsIHBvc3NpYmxlIHdpZHRoIHRvIHdoaWNoIHRoZSBjb2x1bW4gY2FuIGJlIHJlc2l6ZWQuXG4gICAgICovXG4gICAgZ2V0IHJlc3RyaWN0UmVzaXplTWluKCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGFjdHVhbE1pbldpZHRoID0gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5taW5XaWR0aCk7XG4gICAgICAgIGNvbnN0IG1pbldpZHRoID0gYWN0dWFsTWluV2lkdGggPCBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLndpZHRoKSA/IGFjdHVhbE1pbldpZHRoIDogcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi53aWR0aCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gbWluV2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF4aW1hbCBwb3NzaWJsZSB3aWR0aCB0byB3aGljaCB0aGUgY29sdW1uIGNhbiBiZSByZXNpemVkLlxuICAgICAqL1xuICAgIGdldCByZXN0cmljdFJlc2l6ZU1heCgpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBhY3R1YWxXaWR0aCA9IHRoaXMuY29sdW1uLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW4ubWF4V2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLm1heFdpZHRoKSAtIGFjdHVhbFdpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXV0b3NpemVzIHRoZSBjb2x1bW4gdG8gdGhlIGxvbmdlc3QgY3VycmVudGx5IHZpc2libGUgY2VsbCB2YWx1ZSwgaW5jbHVkaW5nIHRoZSBoZWFkZXIgY2VsbC5cbiAgICAgKiBJZiB0aGUgY29sdW1uIGhhcyBhIHByZWRpZmluZWQgbWF4V2lkdGggYW5kIHRoZSBhdXRvc2l6ZWQgY29sdW1uIHdpZHRoIHdpbGwgYmVjb21lIGJpZ2dlciB0aGFuIGl0LFxuICAgICAqIHRoZW4gdGhlIGNvbHVtbiBpcyBzaXplZCB0byBpdHMgbWF4V2lkdGguXG4gICAgICogSWYgdGhlIGNvbHVtbiBpcyBwaW5uZWQgYW5kIHRoZSBhdXRvc2l6ZWQgY29sdW1uIHdpZHRoIHdpbGwgY2F1c2UgdGhlIHBpbm5lZCBhcmVhIHRvIGJlY29tZSBiaWdnZXJcbiAgICAgKiB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgcGlubmVkIGFyZWEgd2lkdGggKDgwJSBvZiB0aGUgdG90YWwgZ3JpZCB3aWR0aCksIGF1dG9zaXppbmcgd2lsbCBiZSBkZWlzbWlzc2VkLlxuICAgICAqL1xuICAgIHB1YmxpYyBhdXRvc2l6ZUNvbHVtbk9uRGJsQ2xpY2soKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb2xXaWR0aCA9IHRoaXMuY29sdW1uLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuXG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmNvbHVtbi5nZXRMYXJnZXN0Q2VsbFdpZHRoKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5tYXhXaWR0aCAmJiAocGFyc2VGbG9hdChzaXplKSA+IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ubWF4V2lkdGgpKSkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLm1heFdpZHRoKSArICdweCc7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyc2VGbG9hdChzaXplKSA8IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ubWluV2lkdGgpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbi53aWR0aCA9IHRoaXMuY29sdW1uLm1pbldpZHRoICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uLndpZHRoID0gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge30pO1xuXG4gICAgICAgIHRoaXMuY29sdW1uLmdyaWQub25Db2x1bW5SZXNpemVkLmVtaXQoe1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgIHByZXZXaWR0aDogY3VycmVudENvbFdpZHRoLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBuZXdXaWR0aDogdGhpcy5jb2x1bW4ud2lkdGhcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzaXplcyB0aGUgY29sdW1uIHJlZ2FyaWRuZyB0byB0aGUgY29sdW1uIG1pbldpZHRoIGFuZCBtYXhXaWR0aC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVzaXplQ29sdW1uKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2hvd1Jlc2l6ZXIgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZGlmZiA9IGV2ZW50LmNsaWVudFggLSB0aGlzLnN0YXJ0UmVzaXplUG9zO1xuXG4gICAgICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLndpZHRoKTtcbiAgICAgICAgY29uc3QgYWN0dWFsV2lkdGggPSB0aGlzLmNvbHVtbi5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgY3VycmVudENvbFdpZHRoID0gTnVtYmVyLmlzTmFOKGN1cnJlbnRDb2xXaWR0aCkgfHwgKGN1cnJlbnRDb2xXaWR0aCA8IGFjdHVhbFdpZHRoKSA/IGFjdHVhbFdpZHRoIDogY3VycmVudENvbFdpZHRoO1xuXG4gICAgICAgIGNvbnN0IGNvbE1pbldpZHRoID0gdGhpcy5nZXRDb2xNaW5XaWR0aCh0aGlzLmNvbHVtbik7XG4gICAgICAgIGNvbnN0IGNvbE1heFdpZHRoID0gdGhpcy5nZXRDb2xNYXhXaWR0aCh0aGlzLmNvbHVtbik7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5ncmlkLmhhc0NvbHVtbkxheW91dHMpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplQ29sdW1uTGF5b3V0Rm9yKHRoaXMuY29sdW1uLCBkaWZmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29sV2lkdGggKyBkaWZmIDwgY29sTWluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbi53aWR0aCA9IGNvbE1pbldpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sTWF4V2lkdGggJiYgKGN1cnJlbnRDb2xXaWR0aCArIGRpZmYgPiBjb2xNYXhXaWR0aCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbi53aWR0aCA9IGNvbE1heFdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSAoY3VycmVudENvbFdpZHRoICsgZGlmZikgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7fSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRDb2xXaWR0aCAhPT0gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi53aWR0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uLmdyaWQub25Db2x1bW5SZXNpemVkLmVtaXQoe1xuICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgcHJldldpZHRoOiBjdXJyZW50Q29sV2lkdGgudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBuZXdXaWR0aDogdGhpcy5jb2x1bW4ud2lkdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0NvbHVtblJlc2l6aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldENvbE1pbldpZHRoKGNvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50KSB7XG4gICAgICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSBwYXJzZUZsb2F0KGNvbHVtbi53aWR0aCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbFdpZHRoID0gY29sdW1uLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBjdXJyZW50Q29sV2lkdGggPSBOdW1iZXIuaXNOYU4oY3VycmVudENvbFdpZHRoKSB8fCAoY3VycmVudENvbFdpZHRoIDwgYWN0dWFsV2lkdGgpID8gYWN0dWFsV2lkdGggOiBjdXJyZW50Q29sV2lkdGg7XG5cbiAgICAgICAgY29uc3QgYWN0dWFsTWluV2lkdGggPSBwYXJzZUZsb2F0KGNvbHVtbi5taW5XaWR0aCk7XG4gICAgICAgIHJldHVybiBhY3R1YWxNaW5XaWR0aCA8IGN1cnJlbnRDb2xXaWR0aCA/IGFjdHVhbE1pbldpZHRoIDogY3VycmVudENvbFdpZHRoO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRDb2xNYXhXaWR0aChjb2x1bW46IElneENvbHVtbkNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gY29sdW1uLnBpbm5lZCA/IHBhcnNlRmxvYXQodGhpcy5waW5uZWRNYXhXaWR0aCkgOiBwYXJzZUZsb2F0KGNvbHVtbi5tYXhXaWR0aCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHJlc2l6ZUNvbHVtbkxheW91dEZvcihjb2x1bW46IElneENvbHVtbkNvbXBvbmVudCwgZGlmZjogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlQ29sdW1ucyA9IGNvbHVtbi5nZXRSZXNpemFibGVDb2xVbmRlckVuZCgpO1xuICAgICAgICBjb25zdCBjb21iaW5lZFNwYW4gPSByZWxhdGl2ZUNvbHVtbnMucmVkdWNlKChhY2MsIGNvbCkgPT4gIGFjYyArIGNvbC5zcGFuVXNlZCwgMCk7XG5cbiAgICAgICAgLy8gUmVzaXplIGZpcnN0IHRob3NlIHdobyBtaWdodCByZWFjaCBtaW4vbWF4IHdpZHRoXG4gICAgICAgIGxldCBjb2x1bW5zVG9SZXNpemUgPSBbLi4ucmVsYXRpdmVDb2x1bW5zXTtcbiAgICAgICAgbGV0IHVwZGF0ZWREaWZmID0gZGlmZjtcbiAgICAgICAgbGV0IHVwZGF0ZWRDb21iaW5lZFNwYW4gPSBjb21iaW5lZFNwYW47XG4gICAgICAgIGxldCBzZXRNaW5NYXhDb2xzID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIEN5Y2xlIHRoZW0gdW50aWwgdGhlcmUgYXJlIG5vdCBvbmVzIHRoYXQgcmVhY2ggbWluL21heCBzaXplLCBiZWNhdXNlIHRoZSBkaWZmIGFjY3VtdWxhdGVzIGFmdGVyIGVhY2ggY3ljbGUuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugd2UgY2FuIGhhdmUgYXQgZmlyc3QgMiBjb2xzIHJlYWNoaW5nIG1pbiB3aWR0aCBhbmQgdGhlbiBhZnRlclxuICAgICAgICAgICAgLy8gcmVjYWxjdWxhdGluZyB0aGUgZGlmZiB0aGVyZSBtaWdodCBiZSAxIG1vcmUgdGhhdCByZWFjaGVzIG1pbiB3aWR0aC5cbiAgICAgICAgICAgIHNldE1pbk1heENvbHMgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBuZXdDb21iaW5lZFNwYW4gPSB1cGRhdGVkQ29tYmluZWRTcGFuO1xuICAgICAgICAgICAgY29uc3QgbmV3Q29sc1RvUmVzaXplID0gW107XG4gICAgICAgICAgICBjb2x1bW5zVG9SZXNpemUuZm9yRWFjaCgoY29sKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFJlc2l6ZVdpZHRoID0gcGFyc2VGbG9hdChjb2wudGFyZ2V0LmNhbGNXaWR0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzaXplU2NhbGVkID0gKGRpZmYgLyB1cGRhdGVkQ29tYmluZWRTcGFuKSAqIGNvbC50YXJnZXQuZ3JpZENvbHVtblNwYW47XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtaW5XaWR0aCA9IHRoaXMuZ2V0Q29sTWluV2lkdGgoY29sLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4V2lkdGggPSB0aGlzLmdldENvbE1heFdpZHRoKGNvbC50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UmVzaXplV2lkdGggKyByZXNpemVTY2FsZWQgPCBtaW5XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb2wudGFyZ2V0LndpZHRoID0gbWluV2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkRGlmZiArPSAoY3VycmVudFJlc2l6ZVdpZHRoIC0gbWluV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb21iaW5lZFNwYW4gLT0gY29sLnNwYW5Vc2VkO1xuICAgICAgICAgICAgICAgICAgICBzZXRNaW5NYXhDb2xzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1heFdpZHRoICYmIChjdXJyZW50UmVzaXplV2lkdGggKyByZXNpemVTY2FsZWQgPiBtYXhXaWR0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sLnRhcmdldC53aWR0aCA9IG1heFdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZERpZmYgLT0gKG1heFdpZHRoIC0gY3VycmVudFJlc2l6ZVdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29tYmluZWRTcGFuIC09IGNvbC5zcGFuVXNlZDtcbiAgICAgICAgICAgICAgICAgICAgc2V0TWluTWF4Q29scyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSBuZXcgb25lcyB0aGF0IGNhbiBiZSByZXNpemVkXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbHNUb1Jlc2l6ZS5wdXNoKGNvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHVwZGF0ZWRDb21iaW5lZFNwYW4gPSBuZXdDb21iaW5lZFNwYW47XG4gICAgICAgICAgICBjb2x1bW5zVG9SZXNpemUgPSBuZXdDb2xzVG9SZXNpemU7XG4gICAgICAgIH0gd2hpbGUgKHNldE1pbk1heENvbHMpO1xuXG4gICAgICAgIC8vIFRob3NlIGxlZnQgdGhhdCBkb24ndCByZWFjaCBtaW4vbWF4IHNpemUgcmVzaXplIHRoZW0gbm9ybWFsbHkuXG4gICAgICAgIGNvbHVtbnNUb1Jlc2l6ZS5mb3JFYWNoKChjb2wpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRSZXNpemVXaWR0aCA9IHBhcnNlRmxvYXQoY29sLnRhcmdldC5jYWxjV2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgcmVzaXplU2NhbGVkID0gKHVwZGF0ZWREaWZmIC8gdXBkYXRlZENvbWJpbmVkU3BhbikgKiBjb2wudGFyZ2V0LmdyaWRDb2x1bW5TcGFuO1xuICAgICAgICAgICAgY29sLnRhcmdldC53aWR0aCA9IChjdXJyZW50UmVzaXplV2lkdGggKyByZXNpemVTY2FsZWQpICsgJ3B4JztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl19