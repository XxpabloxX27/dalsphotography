import { __decorate, __param } from "tslib";
import { Component, ChangeDetectorRef, ElementRef, ViewChild, Inject, ChangeDetectionStrategy, NgZone, OnInit, Input, TemplateRef } from '@angular/core';
import { IgxGridCellComponent } from '../cell.component';
import { GridBaseAPIService } from '../api.service';
import { getNodeSizeViaRange, PlatformUtil } from '../../core/utils';
import { DOCUMENT } from '@angular/common';
import { IgxGridSelectionService, IgxGridCRUDService } from '../selection/selection.service';
import { HammerGesturesManager } from '../../core/touch';
let IgxGridExpandableCellComponent = class IgxGridExpandableCellComponent extends IgxGridCellComponent {
    constructor(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, document, platformUtil) {
        super(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, platformUtil);
        this.zone = zone;
        this.document = document;
        this.platformUtil = platformUtil;
        /**
         * @hidden
        */
        this.expanded = false;
    }
    /**
     * @hidden
     */
    toggle(event) {
        event.stopPropagation();
        const expansionState = this.gridAPI.get_row_expansion_state(this.row.rowData);
        this.gridAPI.set_row_expansion_state(this.row.rowID, !expansionState, event);
    }
    /**
     * @hidden
     */
    onIndicatorFocus() {
        this.gridAPI.submit_value();
        this.nativeElement.focus();
    }
    /**
     * @hidden
     */
    calculateSizeToFit(range) {
        const indicatorWidth = this.indicator.nativeElement.getBoundingClientRect().width;
        const indicatorStyle = this.document.defaultView.getComputedStyle(this.indicator.nativeElement);
        const indicatorMargin = parseFloat(indicatorStyle.marginRight);
        let leftPadding = 0;
        if (this.indentationDiv) {
            const indentationStyle = this.document.defaultView.getComputedStyle(this.indentationDiv.nativeElement);
            leftPadding = parseFloat(indentationStyle.paddingLeft);
        }
        const largestWidth = Math.max(...Array.from(this.nativeElement.children)
            .map((child) => getNodeSizeViaRange(range, child)));
        return largestWidth + indicatorWidth + indicatorMargin + leftPadding;
    }
    /**
     * @hidden
    */
    get iconTemplate() {
        if (this.expanded) {
            return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;
        }
        else {
            return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
        }
    }
};
IgxGridExpandableCellComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: HammerGesturesManager },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: PlatformUtil }
];
__decorate([
    Input()
], IgxGridExpandableCellComponent.prototype, "expanded", void 0);
__decorate([
    ViewChild('indicator', { read: ElementRef })
], IgxGridExpandableCellComponent.prototype, "indicator", void 0);
__decorate([
    ViewChild('indentationDiv', { read: ElementRef })
], IgxGridExpandableCellComponent.prototype, "indentationDiv", void 0);
__decorate([
    ViewChild('defaultExpandedTemplate', { read: TemplateRef, static: true })
], IgxGridExpandableCellComponent.prototype, "defaultExpandedTemplate", void 0);
__decorate([
    ViewChild('defaultCollapsedTemplate', { read: TemplateRef, static: true })
], IgxGridExpandableCellComponent.prototype, "defaultCollapsedTemplate", void 0);
IgxGridExpandableCellComponent = __decorate([
    Component({
        changeDetection: ChangeDetectionStrategy.OnPush,
        selector: 'igx-expandable-grid-cell',
        template: "<ng-template #defaultCell>\n    <div igxTextHighlight style=\"pointer-events: none\" [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor  let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"focused\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"focused\"  type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\"\n        [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"focused\" [labelVisibility]=\"false\">\n    </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngIf=\"!editMode\">\n    <div #indicator\n         class=\"igx-grid__tree-grouping-indicator\"\n         (click)=\"toggle($event)\" (focus)=\"onIndicatorFocus()\" tabindex=\"-1\">\n         <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit:  this }\">\n        </ng-container>\n    </div>\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n<ng-template #defaultExpandedTemplate>\n        <igx-icon fontSet=\"material\">expand_more</igx-icon>\n</ng-template>\n<ng-template #defaultCollapsedTemplate>\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n</ng-template>\n",
        providers: [HammerGesturesManager]
    }),
    __param(7, Inject(DOCUMENT))
], IgxGridExpandableCellComponent);
export { IgxGridExpandableCellComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwYW5kYWJsZS1jZWxsLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvZ3JpZC9leHBhbmRhYmxlLWNlbGwuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLGlCQUFpQixFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUMvRCx1QkFBdUIsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDeEYsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDekQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDcEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLFlBQVksRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ3JFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUUzQyxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUM3RixPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQVN6RCxJQUFhLDhCQUE4QixHQUEzQyxNQUFhLDhCQUErQixTQUFRLG9CQUFvQjtJQUVwRSxZQUNZLGdCQUF5QyxFQUN6QyxXQUErQixFQUMvQixPQUE0RCxFQUM1RCxHQUFzQixFQUN0QixPQUFtQixFQUNULElBQVksRUFDdEIsWUFBbUMsRUFDVixRQUFRLEVBQ3ZCLFlBQTBCO1FBQzVDLEtBQUssQ0FBQyxnQkFBZ0IsRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxZQUFZLENBQUMsQ0FBQztRQUo1RSxTQUFJLEdBQUosSUFBSSxDQUFRO1FBRUcsYUFBUSxHQUFSLFFB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UyxDQUFDLDBCQUEwQixFQUFFLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUM7Z0ZBQ3RCO0FBckMzQyw4QkFBOEI7SUFOMUMsU0FBUyxDQUFDO1FBQ1AsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07UUFDL0MsUUFBUSxFQUFFLDBCQUEwQjtRQUNwQywyN0VBQTZDO1FBQzdDLFNBQVMsRUFBRSxDQUFDLHFCQUFxQixDQUFDO0tBQ3JDLENBQUM7SUFXZSxXQUFBLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQTtHQVZwQiw4QkFBOEIsQ0FtRjFDO1NBbkZZLDhCQUE4QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgQ2hhbmdlRGV0ZWN0b3JSZWYsIEVsZW1lbnRSZWYsIFZpZXdDaGlsZCwgSW5qZWN0LFxuICAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgTmdab25lLCBPbkluaXQsIElucHV0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4R3JpZENlbGxDb21wb25lbnQgfSBmcm9tICcuLi9jZWxsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBHcmlkQmFzZUFQSVNlcnZpY2UgfSBmcm9tICcuLi9hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBnZXROb2RlU2l6ZVZpYVJhbmdlLCBQbGF0Zm9ybVV0aWwgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IElneEdyaWRCYXNlRGlyZWN0aXZlIH0gZnJvbSAnLic7XG5pbXBvcnQgeyBJZ3hHcmlkU2VsZWN0aW9uU2VydmljZSwgSWd4R3JpZENSVURTZXJ2aWNlIH0gZnJvbSAnLi4vc2VsZWN0aW9uL3NlbGVjdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IEhhbW1lckdlc3R1cmVzTWFuYWdlciB9IGZyb20gJy4uLy4uL2NvcmUvdG91Y2gnO1xuaW1wb3J0IHsgR3JpZFR5cGUgfSBmcm9tICcuLi9jb21tb24vZ3JpZC5pbnRlcmZhY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBzZWxlY3RvcjogJ2lneC1leHBhbmRhYmxlLWdyaWQtY2VsbCcsXG4gICAgdGVtcGxhdGVVcmw6ICdleHBhbmRhYmxlLWNlbGwuY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW0hhbW1lckdlc3R1cmVzTWFuYWdlcl1cbn0pXG5leHBvcnQgY2xhc3MgSWd4R3JpZEV4cGFuZGFibGVDZWxsQ29tcG9uZW50IGV4dGVuZHMgSWd4R3JpZENlbGxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uU2VydmljZTogSWd4R3JpZFNlbGVjdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgY3J1ZFNlcnZpY2U6IElneEdyaWRDUlVEU2VydmljZSxcbiAgICAgICAgICAgICAgICBncmlkQVBJOiBHcmlkQmFzZUFQSVNlcnZpY2U8SWd4R3JpZEJhc2VEaXJlY3RpdmUgJiBHcmlkVHlwZT4sXG4gICAgICAgICAgICAgICAgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCB6b25lOiBOZ1pvbmUsXG4gICAgICAgICAgICAgICAgdG91Y2hNYW5hZ2VyOiBIYW1tZXJHZXN0dXJlc01hbmFnZXIsXG4gICAgICAgICAgICAgICAgQEluamVjdChET0NVTUVOVCkgcHVibGljIGRvY3VtZW50LFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwbGF0Zm9ybVV0aWw6IFBsYXRmb3JtVXRpbCkge1xuICAgICAgICBzdXBlcihzZWxlY3Rpb25TZXJ2aWNlLCBjcnVkU2VydmljZSwgZ3JpZEFQSSwgY2RyLCBlbGVtZW50LCB6b25lLCB0b3VjaE1hbmFnZXIsIHBsYXRmb3JtVXRpbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICovXG4gICAgQElucHV0KClcbiAgICBleHBhbmRlZCA9IGZhbHNlO1xuXG4gICAgQFZpZXdDaGlsZCgnaW5kaWNhdG9yJywgeyByZWFkOiBFbGVtZW50UmVmIH0pXG4gICAgcHVibGljIGluZGljYXRvcjogRWxlbWVudFJlZjtcblxuICAgIEBWaWV3Q2hpbGQoJ2luZGVudGF0aW9uRGl2JywgeyByZWFkOiBFbGVtZW50UmVmIH0pXG4gICAgcHVibGljIGluZGVudGF0aW9uRGl2OiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgIEBWaWV3Q2hpbGQoJ2RlZmF1bHRFeHBhbmRlZFRlbXBsYXRlJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICBwcm90ZWN0ZWQgZGVmYXVsdEV4cGFuZGVkVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgQFZpZXdDaGlsZCgnZGVmYXVsdENvbGxhcHNlZFRlbXBsYXRlJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICBwcm90ZWN0ZWQgZGVmYXVsdENvbGxhcHNlZFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGUoZXZlbnQ6IEV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb25zdCBleHBhbnNpb25TdGF0ZSA9IHRoaXMuZ3JpZEFQSS5nZXRfcm93X2V4cGFuc2lvbl9zdGF0ZSh0aGlzLnJvdy5yb3dEYXRhKTtcbiAgICAgICAgdGhpcy5ncmlkQVBJLnNldF9yb3dfZXhwYW5zaW9uX3N0YXRlKHRoaXMucm93LnJvd0lELCAhZXhwYW5zaW9uU3RhdGUsIGV2ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9uSW5kaWNhdG9yRm9jdXMoKSB7XG4gICAgICAgIHRoaXMuZ3JpZEFQSS5zdWJtaXRfdmFsdWUoKTtcbiAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBjYWxjdWxhdGVTaXplVG9GaXQocmFuZ2U6IGFueSk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGluZGljYXRvcldpZHRoID0gdGhpcy5pbmRpY2F0b3IubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgY29uc3QgaW5kaWNhdG9yU3R5bGUgPSB0aGlzLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5pbmRpY2F0b3IubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGluZGljYXRvck1hcmdpbiA9IHBhcnNlRmxvYXQoaW5kaWNhdG9yU3R5bGUubWFyZ2luUmlnaHQpO1xuICAgICAgICBsZXQgbGVmdFBhZGRpbmcgPSAwO1xuICAgICAgICBpZiAodGhpcy5pbmRlbnRhdGlvbkRpdikge1xuICAgICAgICAgICAgY29uc3QgaW5kZW50YXRpb25TdHlsZSA9IHRoaXMuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmluZGVudGF0aW9uRGl2Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgbGVmdFBhZGRpbmcgPSBwYXJzZUZsb2F0KGluZGVudGF0aW9uU3R5bGUucGFkZGluZ0xlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhcmdlc3RXaWR0aCA9IE1hdGgubWF4KC4uLkFycmF5LmZyb20odGhpcy5uYXRpdmVFbGVtZW50LmNoaWxkcmVuKVxuICAgICAgICAgICAgLm1hcCgoY2hpbGQpID0+IGdldE5vZGVTaXplVmlhUmFuZ2UocmFuZ2UsIGNoaWxkKSkpO1xuICAgICAgICByZXR1cm4gbGFyZ2VzdFdpZHRoICsgaW5kaWNhdG9yV2lkdGggKyBpbmRpY2F0b3JNYXJnaW4gKyBsZWZ0UGFkZGluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0IGljb25UZW1wbGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyaWQucm93RXhwYW5kZWRJbmRpY2F0b3JUZW1wbGF0ZSB8fCB0aGlzLmRlZmF1bHRFeHBhbmRlZFRlbXBsYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5yb3dDb2xsYXBzZWRJbmRpY2F0b3JUZW1wbGF0ZSB8fCB0aGlzLmRlZmF1bHRDb2xsYXBzZWRUZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==