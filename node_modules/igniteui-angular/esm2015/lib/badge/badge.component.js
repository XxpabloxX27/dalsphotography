import { __decorate } from "tslib";
import { CommonModule } from '@angular/common';
import { Component, HostBinding, Input, NgModule } from '@angular/core';
import { IgxIconModule } from '../icon/index';
let NEXT_ID = 0;
/**
 * Determines the igxBadge type
 */
export var IgxBadgeType;
(function (IgxBadgeType) {
    IgxBadgeType["PRIMARY"] = "primary";
    IgxBadgeType["INFO"] = "info";
    IgxBadgeType["SUCCESS"] = "success";
    IgxBadgeType["WARNING"] = "warning";
    IgxBadgeType["ERROR"] = "error";
})(IgxBadgeType || (IgxBadgeType = {}));
/**
 * Badge provides visual notifications used to decorate avatars, menus, etc.
 *
 * @igxModule IgxBadgeModule
 *
 * @igxTheme igx-badge-theme
 *
 * @igxKeywords badge, icon, notification
 *
 * @igxGroup Data Entry & Display
 *
 * @remarks
 * The Ignite UI Badge is used to decorate avatars, navigation menus, or other components in the
 * application when visual notification is needed. They are usually designed as icons with a predefined
 * style to communicate information, success, warnings, or errors.
 *
 * @example
 * ```html
 * <igx-avatar>
 *   <igx-badge icon="check" type="success"></igx-badge>
 * </igx-avatar>
 */
let IgxBadgeComponent = class IgxBadgeComponent {
    constructor() {
        /**
        * Sets/gets the `id` of the badge.
        *
        * @remarks
        * If not set, the `id` will have value `"igx-badge-0"`.
        *
        * @example
        * ```html
        * <igx-badge id="igx-badge-2"></igx-badge>
        * ```
        */
        this.id = `igx-badge-${NEXT_ID++}`;
        /**
        * Sets/gets the type of the badge.
        *
        * @remarks
        * Allowed values are `primary`, `info`, `success`, `warning`, `error`.
        * Providing an invalid value won't display a badge.
        *
        * @example
        * ```html
        * <igx-badge type="success"></igx-badge>
        * ```
        */
        this.type = IgxBadgeType.PRIMARY;
        /**
        * Sets/gets the value to be displayed inside the badge.
        *
        * @remarks
        * If an `icon` property is already set the `icon` will be displayed.
        * If neither a `value` nor an `icon` is set the content of the badge will be empty.
        *
        * @example
        * ```html
        * <igx-badge value="11"></igx-badge>
        * ```
        */
        this.value = '';
        /**
         * Sets/gets the role attribute value.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.role = 'status';
         * ```
         */
        this.role = 'status';
        /**
         * Sets/gets the the css class to use on the badge.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.cssClass = 'my-badge-class';
         * ```
         */
        this.cssClass = 'igx-badge';
        /**
         * Sets/gets the aria-label attribute value.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.label = 'badge';
         * ```
         */
        this.label = 'badge';
    }
    /**
     * Defines a human-readable, accessor, author-localized description for
     * the `type` and the `icon` or `value` of the element.
     * @hidden
     * @internal
     */
    get roleDescription() {
        let message;
        // tslint:disable-next-line:prefer-conditional-expression
        if (this.icon) {
            message = this.type + ' type badge with icon type ' + this.icon;
        }
        else if (this.value) {
            message = this.type + ' badge type with value ' + this.value;
        }
        else {
            message = this.type + ' badge type without value';
        }
        return message;
    }
    /**
     * Method which makes the name of the class more descriptive.
     * This helps the styling of the badges.
     * @hidden
     * @internal
     */
    setClasses() {
        let classes = {};
        switch (IgxBadgeType[this.type.toUpperCase()]) {
            case IgxBadgeType.INFO:
                classes = {
                    [`${this.cssClass}__circle--info`]: true
                };
                break;
            case IgxBadgeType.SUCCESS:
                classes = {
                    [`${this.cssClass}__circle--success`]: true
                };
                break;
            case IgxBadgeType.WARNING:
                classes = {
                    [`${this.cssClass}__circle--warning`]: true
                };
                break;
            case IgxBadgeType.ERROR:
                classes = {
                    [`${this.cssClass}__circle--error`]: true
                };
                break;
            default:
                classes = {
                    [`${this.cssClass}__circle--default`]: true
                };
        }
        return classes;
    }
};
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxBadgeComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxBadgeComponent.prototype, "type", void 0);
__decorate([
    Input()
], IgxBadgeComponent.prototype, "value", void 0);
__decorate([
    Input()
], IgxBadgeComponent.prototype, "icon", void 0);
__decorate([
    HostBinding('attr.role')
], IgxBadgeComponent.prototype, "role", void 0);
__decorate([
    HostBinding('class.igx-badge')
], IgxBadgeComponent.prototype, "cssClass", void 0);
__decorate([
    HostBinding('attr.aria-label')
], IgxBadgeComponent.prototype, "label", void 0);
IgxBadgeComponent = __decorate([
    Component({
        selector: 'igx-badge',
        template: "<div class=\"igx-badge__circle\" [ngClass]=\"setClasses()\" [attr.aria-roledescription]=\"roleDescription\">\n    <span *ngIf=\"!icon\" class=\"igx-badge__circle-value\">{{value}}</span>\n    <igx-icon *ngIf=\"icon\" fontSet=\"material\">{{icon}}</igx-icon>\n</div>\n"
    })
], IgxBadgeComponent);
export { IgxBadgeComponent };
/**
 * @hidden
 */
let IgxBadgeModule = class IgxBadgeModule {
};
IgxBadgeModule = __decorate([
    NgModule({
        declarations: [IgxBadgeComponent],
        exports: [IgxBadgeComponent],
        imports: [CommonModule, IgxIconModule]
    })
], IgxBadgeModule);
export { IgxBadgeModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFkZ2UuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9iYWRnZS9iYWRnZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFOUMsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO0FBRWhCOztHQUVHO0FBQ0gsTUFBTSxDQUFOLElBQVksWUFNWDtBQU5ELFdBQVksWUFBWTtJQUNwQixtQ0FBbUIsQ0FBQTtJQUNuQiw2QkFBYSxDQUFBO0lBQ2IsbUNBQW1CLENBQUE7SUFDbkIsbUNBQW1CLENBQUE7SUFDbkIsK0JBQWUsQ0FBQTtBQUNuQixDQUFDLEVBTlcsWUFBWSxLQUFaLFlBQVksUUFNdkI7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBcUJHO0FBS0gsSUFBYSxpQkFBaUIsR0FBOUIsTUFBYSxpQkFBaUI7SUFBOUI7UUFFSTs7Ozs7Ozs7OztVQVVFO1FBR0ssT0FBRSxHQUFHLGFBQWEsT0FBTyxFQUFFLEVBQUUsQ0FBQztRQUVyQzs7Ozs7Ozs7Ozs7VUFXRTtRQUVLLFNBQUksR0FBMEIsWUFBWSxDQUFDLE9BQU8sQ0FBQztRQUUxRDs7Ozs7Ozs7Ozs7VUFXRTtRQUVLLFVBQUssR0FBRyxFQUFFLENBQUM7UUFrQmxCOzs7Ozs7Ozs7O1dBVUc7UUFFSSxTQUFJLEdBQUcsUUFBUSxDQUFDO1FBRXZCOzs7Ozs7Ozs7O1dBVUc7UUFFSSxhQUFRLEdBQUcsV0FBVyxDQUFDO1FBRTlCOzs7Ozs7Ozs7O1dBVUc7UUFFSSxVQUFLLEdBQUcsT0FBTyxDQUFDO0lBOEQzQixDQUFDO0lBNURHOzs7OztPQUtHO0lBQ0gsSUFBSSxlQUFlO1FBQ2YsSUFBSSxPQUFlLENBQUM7UUFFcEIseURBQXlEO1FBQ3pELElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtZQUNYLE9BQU8sR0FBRyxJQUFJLENBQUMsSUFBSSxHQUFHLDZCQUE2QixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7U0FDbkU7YUFBTSxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDbkIsT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLEdBQUcseUJBQXlCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztTQUNoRTthQUFNO1lBQ0gsT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLEdBQUcsMkJBQTJCLENBQUM7U0FDckQ7UUFFRCxPQUFPLE9BQU8sQ0FBQztJQUNuQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxVQUFVO1FBQ2IsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBRWpCLFFBQVEsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsRUFBRTtZQUMzQyxLQUFLLFlBQVksQ0FBQyxJQUFJO2dCQUNsQixPQUFPLEdBQUc7b0JBQ04sQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLGdCQUFnQixDQUFDLEVBQUUsSUFBSTtpQkFDM0MsQ0FBQztnQkFDRixNQUFNO1lBQ1YsS0FBSyxZQUFZLENBQUMsT0FBTztnQkFDckIsT0FBTyxHQUFHO29CQUNOLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxtQkFBbUIsQ0FBQyxFQUFFLElBQUk7aUJBQzlDLENBQUM7Z0JBQ0YsTUFBTTtZQUNWLEtBQUssWUFBWSxDQUFDLE9BQU87Z0JBQ3JCLE9BQU8sR0FBRztvQkFDTixDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsbUJBQW1CLENBQUMsRUFBRSxJQUFJO2lCQUM5QyxDQUFDO2dCQUNGLE1BQU07WUFDVixLQUFLLFlBQVksQ0FBQyxLQUFLO2dCQUNuQixPQUFPLEdBQUc7b0JBQ04sQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLGlCQUFpQixDQUFDLEVBQUUsSUFBSTtpQkFDNUMsQ0FBQztnQkFDRixNQUFNO1lBQ1Y7Z0JBQ0ksT0FBTyxHQUFHO29CQUNOLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxtQkFBbUIsQ0FBQyxFQUFFLElBQUk7aUJBQzlDLENBQUM7U0FDVDtRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ25CLENBQUM7Q0FFSixDQUFBO0FBdEpHO0lBRkMsV0FBVyxDQUFDLFNBQVMsQ0FBQztJQUN0QixLQUFLLEVBQUU7NkNBQzZCO0FBZXJDO0lBREMsS0FBSyxFQUFFOytDQUNrRDtBQWUxRDtJQURDLEtBQUssRUFBRTtnREFDVTtBQWdCbEI7SUFEQyxLQUFLLEVBQUU7K0NBQ1k7QUFjcEI7SUFEQyxXQUFXLENBQUMsV0FBVyxDQUFDOytDQUNGO0FBY3ZCO0lBREMsV0FBVyxDQUFDLGlCQUFpQixDQUFDO21EQUNEO0FBYzlCO0lBREMsV0FBVyxDQUFDLGlCQUFpQixDQUFDO2dEQUNSO0FBdkdkLGlCQUFpQjtJQUo3QixTQUFTLENBQUM7UUFDUCxRQUFRLEVBQUUsV0FBVztRQUNyQix1UkFBbUM7S0FDdEMsQ0FBQztHQUNXLGlCQUFpQixDQXFLN0I7U0FyS1ksaUJBQWlCO0FBdUs5Qjs7R0FFRztBQU1ILElBQWEsY0FBYyxHQUEzQixNQUFhLGNBQWM7Q0FBSSxDQUFBO0FBQWxCLGNBQWM7SUFMMUIsUUFBUSxDQUFDO1FBQ04sWUFBWSxFQUFFLENBQUMsaUJBQWlCLENBQUM7UUFDakMsT0FBTyxFQUFFLENBQUMsaUJBQWlCLENBQUM7UUFDNUIsT0FBTyxFQUFFLENBQUMsWUFBWSxFQUFFLGFBQWEsQ0FBQztLQUN6QyxDQUFDO0dBQ1csY0FBYyxDQUFJO1NBQWxCLGNBQWMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBIb3N0QmluZGluZywgSW5wdXQsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZ3hJY29uTW9kdWxlIH0gZnJvbSAnLi4vaWNvbi9pbmRleCc7XG5cbmxldCBORVhUX0lEID0gMDtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBpZ3hCYWRnZSB0eXBlXG4gKi9cbmV4cG9ydCBlbnVtIElneEJhZGdlVHlwZSB7XG4gICAgUFJJTUFSWSA9ICdwcmltYXJ5JyxcbiAgICBJTkZPID0gJ2luZm8nLFxuICAgIFNVQ0NFU1MgPSAnc3VjY2VzcycsXG4gICAgV0FSTklORyA9ICd3YXJuaW5nJyxcbiAgICBFUlJPUiA9ICdlcnJvcidcbn1cbi8qKlxuICogQmFkZ2UgcHJvdmlkZXMgdmlzdWFsIG5vdGlmaWNhdGlvbnMgdXNlZCB0byBkZWNvcmF0ZSBhdmF0YXJzLCBtZW51cywgZXRjLlxuICpcbiAqIEBpZ3hNb2R1bGUgSWd4QmFkZ2VNb2R1bGVcbiAqXG4gKiBAaWd4VGhlbWUgaWd4LWJhZGdlLXRoZW1lXG4gKlxuICogQGlneEtleXdvcmRzIGJhZGdlLCBpY29uLCBub3RpZmljYXRpb25cbiAqXG4gKiBAaWd4R3JvdXAgRGF0YSBFbnRyeSAmIERpc3BsYXlcbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIElnbml0ZSBVSSBCYWRnZSBpcyB1c2VkIHRvIGRlY29yYXRlIGF2YXRhcnMsIG5hdmlnYXRpb24gbWVudXMsIG9yIG90aGVyIGNvbXBvbmVudHMgaW4gdGhlXG4gKiBhcHBsaWNhdGlvbiB3aGVuIHZpc3VhbCBub3RpZmljYXRpb24gaXMgbmVlZGVkLiBUaGV5IGFyZSB1c3VhbGx5IGRlc2lnbmVkIGFzIGljb25zIHdpdGggYSBwcmVkZWZpbmVkXG4gKiBzdHlsZSB0byBjb21tdW5pY2F0ZSBpbmZvcm1hdGlvbiwgc3VjY2Vzcywgd2FybmluZ3MsIG9yIGVycm9ycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICogPGlneC1hdmF0YXI+XG4gKiAgIDxpZ3gtYmFkZ2UgaWNvbj1cImNoZWNrXCIgdHlwZT1cInN1Y2Nlc3NcIj48L2lneC1iYWRnZT5cbiAqIDwvaWd4LWF2YXRhcj5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtYmFkZ2UnLFxuICAgIHRlbXBsYXRlVXJsOiAnYmFkZ2UuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIElneEJhZGdlQ29tcG9uZW50IHtcblxuICAgIC8qKlxuICAgICogU2V0cy9nZXRzIHRoZSBgaWRgIG9mIHRoZSBiYWRnZS5cbiAgICAqXG4gICAgKiBAcmVtYXJrc1xuICAgICogSWYgbm90IHNldCwgdGhlIGBpZGAgd2lsbCBoYXZlIHZhbHVlIGBcImlneC1iYWRnZS0wXCJgLlxuICAgICpcbiAgICAqIEBleGFtcGxlXG4gICAgKiBgYGBodG1sXG4gICAgKiA8aWd4LWJhZGdlIGlkPVwiaWd4LWJhZGdlLTJcIj48L2lneC1iYWRnZT5cbiAgICAqIGBgYFxuICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZCA9IGBpZ3gtYmFkZ2UtJHtORVhUX0lEKyt9YDtcblxuICAgIC8qKlxuICAgICogU2V0cy9nZXRzIHRoZSB0eXBlIG9mIHRoZSBiYWRnZS5cbiAgICAqXG4gICAgKiBAcmVtYXJrc1xuICAgICogQWxsb3dlZCB2YWx1ZXMgYXJlIGBwcmltYXJ5YCwgYGluZm9gLCBgc3VjY2Vzc2AsIGB3YXJuaW5nYCwgYGVycm9yYC5cbiAgICAqIFByb3ZpZGluZyBhbiBpbnZhbGlkIHZhbHVlIHdvbid0IGRpc3BsYXkgYSBiYWRnZS5cbiAgICAqXG4gICAgKiBAZXhhbXBsZVxuICAgICogYGBgaHRtbFxuICAgICogPGlneC1iYWRnZSB0eXBlPVwic3VjY2Vzc1wiPjwvaWd4LWJhZGdlPlxuICAgICogYGBgXG4gICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0eXBlOiBzdHJpbmcgfCBJZ3hCYWRnZVR5cGUgPSBJZ3hCYWRnZVR5cGUuUFJJTUFSWTtcblxuICAgIC8qKlxuICAgICogU2V0cy9nZXRzIHRoZSB2YWx1ZSB0byBiZSBkaXNwbGF5ZWQgaW5zaWRlIHRoZSBiYWRnZS5cbiAgICAqXG4gICAgKiBAcmVtYXJrc1xuICAgICogSWYgYW4gYGljb25gIHByb3BlcnR5IGlzIGFscmVhZHkgc2V0IHRoZSBgaWNvbmAgd2lsbCBiZSBkaXNwbGF5ZWQuXG4gICAgKiBJZiBuZWl0aGVyIGEgYHZhbHVlYCBub3IgYW4gYGljb25gIGlzIHNldCB0aGUgY29udGVudCBvZiB0aGUgYmFkZ2Ugd2lsbCBiZSBlbXB0eS5cbiAgICAqXG4gICAgKiBAZXhhbXBsZVxuICAgICogYGBgaHRtbFxuICAgICogPGlneC1iYWRnZSB2YWx1ZT1cIjExXCI+PC9pZ3gtYmFkZ2U+XG4gICAgKiBgYGBcbiAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHZhbHVlID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgYW4gaWNvbiBmb3IgdGhlIGJhZGdlIGZyb20gdGhlIG1hdGVyaWFsIGljb25zIHNldC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSGFzIHByaW9yaXR5IG92ZXIgdGhlIGB2YWx1ZWAgcHJvcGVydHkuXG4gICAgICogSWYgbmVpdGhlciBhIGB2YWx1ZWAgbm9yIGFuIGBpY29uYCBpcyBzZXQgdGhlIGNvbnRlbnQgb2YgdGhlIGJhZGdlIHdpbGwgYmUgZW1wdHkuXG4gICAgICogUHJvdmlkaW5nIGFuIGludmFsaWQgdmFsdWUgd29uJ3QgZGlzcGxheSBhbnl0aGluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtYmFkZ2UgaWNvbj1cImNoZWNrXCI+PC9pZ3gtYmFkZ2U+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWNvbjogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSByb2xlIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJNeUJhZGdlXCIsIHsgcmVhZDogSWd4QmFkZ2VDb21wb25lbnQgfSlcbiAgICAgKiBwdWJsaWMgYmFkZ2U6IElneEJhZGdlQ29tcG9uZW50O1xuICAgICAqXG4gICAgICogYmFkZ2Uucm9sZSA9ICdzdGF0dXMnO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5yb2xlJylcbiAgICBwdWJsaWMgcm9sZSA9ICdzdGF0dXMnO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSB0aGUgY3NzIGNsYXNzIHRvIHVzZSBvbiB0aGUgYmFkZ2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiTXlCYWRnZVwiLCB7IHJlYWQ6IElneEJhZGdlQ29tcG9uZW50IH0pXG4gICAgICogcHVibGljIGJhZGdlOiBJZ3hCYWRnZUNvbXBvbmVudDtcbiAgICAgKlxuICAgICAqIGJhZGdlLmNzc0NsYXNzID0gJ215LWJhZGdlLWNsYXNzJztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1iYWRnZScpXG4gICAgcHVibGljIGNzc0NsYXNzID0gJ2lneC1iYWRnZSc7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIk15QmFkZ2VcIiwgeyByZWFkOiBJZ3hCYWRnZUNvbXBvbmVudCB9KVxuICAgICAqIHB1YmxpYyBiYWRnZTogSWd4QmFkZ2VDb21wb25lbnQ7XG4gICAgICpcbiAgICAgKiBiYWRnZS5sYWJlbCA9ICdiYWRnZSc7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtbGFiZWwnKVxuICAgIHB1YmxpYyBsYWJlbCA9ICdiYWRnZSc7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgaHVtYW4tcmVhZGFibGUsIGFjY2Vzc29yLCBhdXRob3ItbG9jYWxpemVkIGRlc2NyaXB0aW9uIGZvclxuICAgICAqIHRoZSBgdHlwZWAgYW5kIHRoZSBgaWNvbmAgb3IgYHZhbHVlYCBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0IHJvbGVEZXNjcmlwdGlvbigpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2U6IHN0cmluZztcblxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6cHJlZmVyLWNvbmRpdGlvbmFsLWV4cHJlc3Npb25cbiAgICAgICAgaWYgKHRoaXMuaWNvbikge1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRoaXMudHlwZSArICcgdHlwZSBiYWRnZSB3aXRoIGljb24gdHlwZSAnICsgdGhpcy5pY29uO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLnR5cGUgKyAnIGJhZGdlIHR5cGUgd2l0aCB2YWx1ZSAnICsgdGhpcy52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLnR5cGUgKyAnIGJhZGdlIHR5cGUgd2l0aG91dCB2YWx1ZSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Qgd2hpY2ggbWFrZXMgdGhlIG5hbWUgb2YgdGhlIGNsYXNzIG1vcmUgZGVzY3JpcHRpdmUuXG4gICAgICogVGhpcyBoZWxwcyB0aGUgc3R5bGluZyBvZiB0aGUgYmFkZ2VzLlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0Q2xhc3NlcygpIHtcbiAgICAgICAgbGV0IGNsYXNzZXMgPSB7fTtcblxuICAgICAgICBzd2l0Y2ggKElneEJhZGdlVHlwZVt0aGlzLnR5cGUudG9VcHBlckNhc2UoKV0pIHtcbiAgICAgICAgICAgIGNhc2UgSWd4QmFkZ2VUeXBlLklORk86XG4gICAgICAgICAgICAgICAgY2xhc3NlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgW2Ake3RoaXMuY3NzQ2xhc3N9X19jaXJjbGUtLWluZm9gXTogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIElneEJhZGdlVHlwZS5TVUNDRVNTOlxuICAgICAgICAgICAgICAgIGNsYXNzZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIFtgJHt0aGlzLmNzc0NsYXNzfV9fY2lyY2xlLS1zdWNjZXNzYF06IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBJZ3hCYWRnZVR5cGUuV0FSTklORzpcbiAgICAgICAgICAgICAgICBjbGFzc2VzID0ge1xuICAgICAgICAgICAgICAgICAgICBbYCR7dGhpcy5jc3NDbGFzc31fX2NpcmNsZS0td2FybmluZ2BdOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSWd4QmFkZ2VUeXBlLkVSUk9SOlxuICAgICAgICAgICAgICAgIGNsYXNzZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIFtgJHt0aGlzLmNzc0NsYXNzfV9fY2lyY2xlLS1lcnJvcmBdOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY2xhc3NlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgW2Ake3RoaXMuY3NzQ2xhc3N9X19jaXJjbGUtLWRlZmF1bHRgXTogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbSWd4QmFkZ2VDb21wb25lbnRdLFxuICAgIGV4cG9ydHM6IFtJZ3hCYWRnZUNvbXBvbmVudF0sXG4gICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgSWd4SWNvbk1vZHVsZV1cbn0pXG5leHBvcnQgY2xhc3MgSWd4QmFkZ2VNb2R1bGUgeyB9XG4iXX0=